// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 10.0.0.0
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace Tum.PDE.ToolFramework.Templates.Shell.Model
{
    using Tum.PDE.LanguageDSL;
    using Microsoft.VisualStudio.Modeling;
    using System.Collections;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;
    using System.Linq;
    using System;
    
    
    #line 1 "J:\Uni\CC Processes\Werkzeuge\PDE 2\Tum.PDE.ToolFramework\Tum.PDE.ToolFramework.Templates\Shell\Model\DirectiveProcessorGenerator.tt"
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "10.0.0.0")]
    public partial class DirectiveProcessorGenerator : BaseTemplate
    {
        #region ToString Helpers
        /// <summary>
        /// Utility class to produce culture-oriented representation of an object as a string.
        /// </summary>
        public class ToStringInstanceHelper
        {
            private System.IFormatProvider formatProviderField  = global::System.Globalization.CultureInfo.InvariantCulture;
            /// <summary>
            /// Gets or sets format provider to be used by ToStringWithCulture method.
            /// </summary>
            public System.IFormatProvider FormatProvider
            {
                get
                {
                    return this.formatProviderField ;
                }
                set
                {
                    if ((value != null))
                    {
                        this.formatProviderField  = value;
                    }
                }
            }
            /// <summary>
            /// This is called from the compile/run appdomain to convert objects within an expression block to a string
            /// </summary>
            public string ToStringWithCulture(object objectToConvert)
            {
                if ((objectToConvert == null))
                {
                    throw new global::System.ArgumentNullException("objectToConvert");
                }
                System.Type t = objectToConvert.GetType();
                System.Reflection.MethodInfo method = t.GetMethod("ToString", new System.Type[] {
                            typeof(System.IFormatProvider)});
                if ((method == null))
                {
                    return objectToConvert.ToString();
                }
                else
                {
                    return ((string)(method.Invoke(objectToConvert, new object[] {
                                this.formatProviderField })));
                }
            }
        }
        private ToStringInstanceHelper toStringHelperField = new ToStringInstanceHelper();
        public ToStringInstanceHelper ToStringHelper
        {
            get
            {
                return this.toStringHelperField;
            }
        }
        #endregion
        public override string TransformText()
        {
            this.GenerationEnvironment = null;
            this.Write(" \r\n");
            
            #line 9 "J:\Uni\CC Processes\Werkzeuge\PDE 2\Tum.PDE.ToolFramework\Tum.PDE.ToolFramework.Templates\Shell\Model\DirectiveProcessorGenerator.tt"

	string dslName = this.MetaModel.Name;
	string directiveName = dslName;

            
            #line default
            #line hidden
            this.Write(@"//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
");
            
            #line 21 "J:\Uni\CC Processes\Werkzeuge\PDE 2\Tum.PDE.ToolFramework\Tum.PDE.ToolFramework.Templates\Shell\Model\DirectiveProcessorGenerator.tt"

	string domainModelFullName = this.MetaModel.GetFullName(false)+ "DomainModel";
	
	DomainClass domainModel = null;
	foreach(DomainClass domainClass in this.MetaModel.AllClasses)
	{
		if( domainClass.IsDomainModel )
		{
			domainModel = domainClass;
			break;
		}
	}	
	
	if( domainModel == null )
		return "";
	
	string rootElementName = domainModel.Name;
	string rootElementType = domainModel.GetFullName(true);

            
            #line default
            #line hidden
            this.Write(@"
#region Using directives
using DslModeling = global::Microsoft.VisualStudio.Modeling;
using DslValidation = global::Microsoft.VisualStudio.Modeling.Validation;
using VSTextTemplating = global::Microsoft.VisualStudio.TextTemplating;
#endregion

namespace ");
            
            #line 47 "J:\Uni\CC Processes\Werkzeuge\PDE 2\Tum.PDE.ToolFramework\Tum.PDE.ToolFramework.Templates\Shell\Model\DirectiveProcessorGenerator.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture(this.MetaModel.Namespace));
            
            #line default
            #line hidden
            this.Write("\r\n{\r\n/// <summary>\r\n/// Double-derived template directive processor that provides" +
                    " ");
            
            #line 50 "J:\Uni\CC Processes\Werkzeuge\PDE 2\Tum.PDE.ToolFramework\Tum.PDE.ToolFramework.Templates\Shell\Model\DirectiveProcessorGenerator.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture(directiveName));
            
            #line default
            #line hidden
            this.Write(" files\r\n/// The implementation is done in ");
            
            #line 51 "J:\Uni\CC Processes\Werkzeuge\PDE 2\Tum.PDE.ToolFramework\Tum.PDE.ToolFramework.Templates\Shell\Model\DirectiveProcessorGenerator.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture(directiveName));
            
            #line default
            #line hidden
            this.Write("DirectiveProcessorBase. This class\r\n/// exist so users can customize behavior eas" +
                    "ily.\r\n/// </summary>\r\npublic sealed partial class ");
            
            #line 54 "J:\Uni\CC Processes\Werkzeuge\PDE 2\Tum.PDE.ToolFramework\Tum.PDE.ToolFramework.Templates\Shell\Model\DirectiveProcessorGenerator.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture(directiveName));
            
            #line default
            #line hidden
            this.Write("DirectiveProcessor : ");
            
            #line 54 "J:\Uni\CC Processes\Werkzeuge\PDE 2\Tum.PDE.ToolFramework\Tum.PDE.ToolFramework.Templates\Shell\Model\DirectiveProcessorGenerator.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture(directiveName));
            
            #line default
            #line hidden
            this.Write("DirectiveProcessorBase\r\n{\r\n\t/// <summary>\r\n\t/// Constructor\r\n\t/// </summary>\r\n\tpu" +
                    "blic ");
            
            #line 59 "J:\Uni\CC Processes\Werkzeuge\PDE 2\Tum.PDE.ToolFramework\Tum.PDE.ToolFramework.Templates\Shell\Model\DirectiveProcessorGenerator.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture(directiveName));
            
            #line default
            #line hidden
            this.Write("DirectiveProcessor()\r\n\t\t: base()\r\n\t{\r\n\t}\r\n}\r\n\r\n/// <summary>\r\n/// Base implementa" +
                    "tion for template directive processor that provides ");
            
            #line 66 "J:\Uni\CC Processes\Werkzeuge\PDE 2\Tum.PDE.ToolFramework\Tum.PDE.ToolFramework.Templates\Shell\Model\DirectiveProcessorGenerator.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture(directiveName));
            
            #line default
            #line hidden
            this.Write(" files\r\n/// </summary>\r\npublic class ");
            
            #line 68 "J:\Uni\CC Processes\Werkzeuge\PDE 2\Tum.PDE.ToolFramework\Tum.PDE.ToolFramework.Templates\Shell\Model\DirectiveProcessorGenerator.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture(directiveName));
            
            #line default
            #line hidden
            this.Write("DirectiveProcessorBase : VSTextTemplating::RequiresProvidesDirectiveProcessor\r\n{\r" +
                    "\n\t/// <summary>\r\n\t/// The friendly name of this processor.\r\n\t/// </summary>\r\n\tpu" +
                    "blic const string ");
            
            #line 73 "J:\Uni\CC Processes\Werkzeuge\PDE 2\Tum.PDE.ToolFramework\Tum.PDE.ToolFramework.Templates\Shell\Model\DirectiveProcessorGenerator.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture(directiveName));
            
            #line default
            #line hidden
            this.Write("DirectiveProcessorName = \"");
            
            #line 73 "J:\Uni\CC Processes\Werkzeuge\PDE 2\Tum.PDE.ToolFramework\Tum.PDE.ToolFramework.Templates\Shell\Model\DirectiveProcessorGenerator.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture(directiveName));
            
            #line default
            #line hidden
            this.Write(@"DirectiveProcessor"";

	/// <summary>
	/// The name for the requires parameter that provides the filename of the model
	/// </summary>
	private const string requiresFileParameter = ""FileName"";

	/// <summary>
	/// The name for the requires parameter that provides the validation categories to run. 
	/// The value for this parameter defaults to String.Empty
	/// </summary>
	private const string requiresValidationParameter = ""Validation"";

	/// <summary>
	/// The name for the provides parameter whose value decides the name of the property 
	/// generated by this DirectiveProcessor. The property returns the root element of
	/// the model in the given file. 
	/// </summary>
	private const string providesModelParameter = """);
            
            #line 91 "J:\Uni\CC Processes\Werkzeuge\PDE 2\Tum.PDE.ToolFramework\Tum.PDE.ToolFramework.Templates\Shell\Model\DirectiveProcessorGenerator.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture(rootElementName));
            
            #line default
            #line hidden
            this.Write(@""";

	/// <summary>
	/// The default value of the provides parameter above. It defaults to the name of
	/// the parameter itself.
	/// </summary>
	private const string defaultProvidesModelParameter = providesModelParameter;

	/// <summary>
	/// The directive name that is supported by this direcive processor. This defaults
	/// to the name of the model. 
	/// </summary>
	private const string supportedDirectiveName = """);
            
            #line 103 "J:\Uni\CC Processes\Werkzeuge\PDE 2\Tum.PDE.ToolFramework\Tum.PDE.ToolFramework.Templates\Shell\Model\DirectiveProcessorGenerator.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture(directiveName));
            
            #line default
            #line hidden
            this.Write("\";\r\n\t\r\n\t/// <summary>\r\n\t/// Flag to ensure that some code is only generated once " +
                    "regardless of how many times the processor is used.\r\n\t/// </summary>\r\n\tprivate b" +
                    "ool oneTimeCodeGenerated;\r\n\t\r\n\t/// <summary>\r\n\t/// Constructor\r\n\t/// </summary>\r" +
                    "\n\tpublic ");
            
            #line 113 "J:\Uni\CC Processes\Werkzeuge\PDE 2\Tum.PDE.ToolFramework\Tum.PDE.ToolFramework.Templates\Shell\Model\DirectiveProcessorGenerator.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture(directiveName));
            
            #line default
            #line hidden
            this.Write("DirectiveProcessorBase()\r\n\t\t: base()\r\n\t{\r\n\t}\r\n\r\n\t/// <summary>\r\n\t/// The friendly" +
                    " name of this processor.\r\n\t/// </summary>\r\n\tprotected override string FriendlyNa" +
                    "me\r\n\t{\r\n\t\tget\r\n\t\t{\r\n\t\t\treturn ");
            
            #line 125 "J:\Uni\CC Processes\Werkzeuge\PDE 2\Tum.PDE.ToolFramework\Tum.PDE.ToolFramework.Templates\Shell\Model\DirectiveProcessorGenerator.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture(directiveName));
            
            #line default
            #line hidden
            this.Write("DirectiveProcessorName;\r\n\t\t}\r\n\t}\r\n\r\n\t/// <summary>\r\n\t/// Check if the directive n" +
                    "ame is supported by this directive processor\r\n\t/// </summary>\r\n\t/// <param name=" +
                    "\"directiveName\"></param>\r\n\t/// <returns></returns>\r\n\tpublic override bool IsDire" +
                    "ctiveSupported(string directiveName)\r\n\t{\r\n\t\treturn (global::System.StringCompare" +
                    "r.OrdinalIgnoreCase.Compare(directiveName, supportedDirectiveName) == 0);\r\n\t}\r\n\r" +
                    "\n\t/// <summary>\r\n\t/// Override StartProcessingRun to reset the helpers flag.\r\n\t/" +
                    "// </summary>\r\n\t/// <param name=\"languageProvider\"></param>\r\n\t/// <param name=\"t" +
                    "emplateContents\"></param>\r\n\t/// <param name=\"errors\"></param>\r\n\tpublic override " +
                    "void StartProcessingRun(global::System.CodeDom.Compiler.CodeDomProvider language" +
                    "Provider, string templateContents, global::System.CodeDom.Compiler.CompilerError" +
                    "Collection errors)\r\n\t{\r\n\t\tthis.oneTimeCodeGenerated = false;\r\n\t\tbase.StartProces" +
                    "singRun(languageProvider, templateContents, errors);\r\n\t}\r\n\r\n\r\n\t/// <summary>\r\n\t/" +
                    "// Override to initialize requires dictionary\r\n\t/// </summary>\r\n\t/// <param name" +
                    "=\"directiveName\"></param>\r\n\t/// <param name=\"requiresDictionary\"></param>\r\n\tprot" +
                    "ected override void InitializeRequiresDictionary(string directiveName, global::S" +
                    "ystem.Collections.Generic.IDictionary<string, string> requiresDictionary)\r\n\t{\r\n\t" +
                    "\tif ((global::System.StringComparer.OrdinalIgnoreCase.Compare(directiveName, sup" +
                    "portedDirectiveName) == 0))\r\n\t\t{\r\n\t\t\trequiresDictionary[requiresFileParameter] =" +
                    " null;\r\n\t\t\trequiresDictionary[requiresValidationParameter] = \"\";\r\n\t\t}\r\n\t}\r\n\r\n\t//" +
                    "/ <summary>\r\n\t/// Override to initialize provides dictinoary\r\n\t/// </summary>\r\n\t" +
                    "/// <param name=\"directiveName\"></param>\r\n\t/// <param name=\"providesDictionary\">" +
                    "</param>\r\n\tprotected override void InitializeProvidesDictionary(string directive" +
                    "Name, global::System.Collections.Generic.IDictionary<string, string> providesDic" +
                    "tionary)\r\n\t{\r\n\t\tif ((global::System.StringComparer.OrdinalIgnoreCase.Compare(dir" +
                    "ectiveName, supportedDirectiveName) == 0))\r\n\t\t{\r\n\t\t\tprovidesDictionary[providesM" +
                    "odelParameter] = defaultProvidesModelParameter;\r\n\t\t}\r\n\t}\r\n\r\n\t/// <summary>\r\n\t///" +
                    " Generate the code to access the model. Use to CodeDomProvider so we are languag" +
                    "e-agnostic\r\n\t/// </summary>\r\n\t/// <param name=\"directiveName\"></param>\r\n\t/// <pa" +
                    "ram name=\"codeBuffer\"></param>\r\n\t/// <param name=\"languageProvider\"></param>\r\n\t/" +
                    "// <param name=\"requiresArguments\"></param>\r\n\t/// <param name=\"providesArguments" +
                    "\"></param>\r\n\t[global::System.Diagnostics.CodeAnalysis.SuppressMessage(\"Microsoft" +
                    ".Globalization\", \"CA1308:NormalizeStringsToUppercase\", Justification = \"Generate" +
                    "d code is not meant for normalization purpose.\")]\r\n\t[global::System.Diagnostics." +
                    "CodeAnalysis.SuppressMessage(\"Microsoft.Maintainability\", \"CA1506:AvoidExcessive" +
                    "ClassCoupling\", Justification = \"Generated code.\")]\r\n\tprotected override void Ge" +
                    "nerateTransformCode(string directiveName, global::System.Text.StringBuilder code" +
                    "Buffer, global::System.CodeDom.Compiler.CodeDomProvider languageProvider, global" +
                    "::System.Collections.Generic.IDictionary<string, string> requiresArguments, glob" +
                    "al::System.Collections.Generic.IDictionary<string, string> providesArguments)\r\n\t" +
                    "{\r\n\t\tif ((global::System.StringComparer.OrdinalIgnoreCase.Compare(directiveName," +
                    " supportedDirectiveName) == 0))\r\n\t\t{\r\n\t\t\tif (languageProvider != null)\r\n\t\t\t{\r\n\t\t" +
                    "\t\t// Create a field to store the model once it is loaded\r\n\t\t\t\tglobal::System.Cod" +
                    "eDom.CodeMemberField rootElement = new global::System.CodeDom.CodeMemberField();" +
                    "\r\n\t\t\t\trootElement.Name = providesArguments[providesModelParameter].ToLower(globa" +
                    "l::System.Globalization.CultureInfo.InvariantCulture) + \"Value\";\r\n\t\t\t\trootElemen" +
                    "t.Type = new global::System.CodeDom.CodeTypeReference(typeof(");
            
            #line 198 "J:\Uni\CC Processes\Werkzeuge\PDE 2\Tum.PDE.ToolFramework\Tum.PDE.ToolFramework.Templates\Shell\Model\DirectiveProcessorGenerator.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture(rootElementType));
            
            #line default
            #line hidden
            this.Write(@"));
				rootElement.Attributes = global::System.CodeDom.MemberAttributes.Private;

				// Create a property for the Model that delay-loads the model
				global::System.CodeDom.CodeMemberProperty rootElementProperty = new global::System.CodeDom.CodeMemberProperty();
				rootElementProperty.Name = providesArguments[providesModelParameter];
				rootElementProperty.Type = new global::System.CodeDom.CodeTypeReference(typeof(");
            
            #line 204 "J:\Uni\CC Processes\Werkzeuge\PDE 2\Tum.PDE.ToolFramework\Tum.PDE.ToolFramework.Templates\Shell\Model\DirectiveProcessorGenerator.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture(rootElementType));
            
            #line default
            #line hidden
            this.Write(@"));
				rootElementProperty.Attributes = global::System.CodeDom.MemberAttributes.Private;
				rootElementProperty.HasSet = false;
				rootElementProperty.HasGet = true;
				rootElementProperty.GetStatements.Add(new global::System.CodeDom.CodeMethodReturnStatement(new global::System.CodeDom.CodeFieldReferenceExpression(new global::System.CodeDom.CodeThisReferenceExpression(), rootElement.Name)));

				// Create a helper method for resolving relative paths
				global::System.CodeDom.CodeMemberMethod resolver = null;
				if (!this.oneTimeCodeGenerated && global::System.IO.File.Exists(this.Host.TemplateFile))
				{
					resolver = new global::System.CodeDom.CodeMemberMethod();
					resolver.Name = ""Convert"" + """);
            
            #line 215 "J:\Uni\CC Processes\Werkzeuge\PDE 2\Tum.PDE.ToolFramework\Tum.PDE.ToolFramework.Templates\Shell\Model\DirectiveProcessorGenerator.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture(rootElementName));
            
            #line default
            #line hidden
            this.Write("\" + \"RelativePathToTemplateRelativePath\";\r\n\t\t\t\t\tresolver.ReturnType = new global:" +
                    ":System.CodeDom.CodeTypeReference(typeof(string));\r\n\t\t\t\t\tresolver.Parameters.Add" +
                    "(new global::System.CodeDom.CodeParameterDeclarationExpression(typeof(string), \"" +
                    "path\"));\r\n\t\t\t\t\tresolver.Attributes = global::System.CodeDom.MemberAttributes.Pub" +
                    "lic;\r\n\t\t\t\t\tglobal::System.CodeDom.CodeVariableDeclarationStatement declaration =" +
                    " new global::System.CodeDom.CodeVariableDeclarationStatement(typeof(string), \"mo" +
                    "delPath\", new global::System.CodeDom.CodePrimitiveExpression((string)(requiresAr" +
                    "guments[requiresFileParameter])));\r\n\t\t\t\t\tresolver.Statements.Add(declaration);\r\n" +
                    "\t\t\t\t\tdeclaration = new global::System.CodeDom.CodeVariableDeclarationStatement(t" +
                    "ypeof(string), \"templatePath\", new global::System.CodeDom.CodePrimitiveExpressio" +
                    "n((string)(this.Host.TemplateFile)));\r\n\t\t\t\t\tresolver.Statements.Add(declaration)" +
                    ";\r\n\t\t\t\t\tglobal::System.CodeDom.CodeMethodReturnStatement returnStatement = new g" +
                    "lobal::System.CodeDom.CodeMethodReturnStatement(\r\n\t\t\t\t\t\tnew global::System.CodeD" +
                    "om.CodeMethodInvokeExpression(\r\n\t\t\t\t\t\t\tnew global::System.CodeDom.CodeMethodRefe" +
                    "renceExpression(new global::System.CodeDom.CodeTypeReferenceExpression(\"Microsof" +
                    "t.VisualStudio.TextTemplating.VSHost.ModelingTextTransformation\"), \"ConvertModel" +
                    "RelativePathToTemplateRelativePath\"),\r\n\t\t\t\t\t\t\tnew global::System.CodeDom.CodeVar" +
                    "iableReferenceExpression(\"modelPath\"),\r\n\t\t\t\t\t\t\tnew global::System.CodeDom.CodeVa" +
                    "riableReferenceExpression(\"templatePath\"),\r\n\t\t\t\t\t\t\tnew global::System.CodeDom.Co" +
                    "deVariableReferenceExpression(\"path\")));\r\n\t\t\t\t\tresolver.Statements.Add(returnSta" +
                    "tement);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Generate the actual code using the CodeDomProvider\r\n\t\t" +
                    "\t\tglobal::System.CodeDom.Compiler.CodeGeneratorOptions options = new global::Sys" +
                    "tem.CodeDom.Compiler.CodeGeneratorOptions();\r\n\t\t\t\toptions.BlankLinesBetweenMembe" +
                    "rs = true;\r\n\t\t\t\toptions.IndentString = \"    \";\r\n\t\t\t\toptions.VerbatimOrder = true" +
                    ";\r\n\t\t\t\toptions.BracingStyle = \"C\";\r\n\t\t\t\tusing (global::System.IO.StringWriter wr" +
                    "iter = new global::System.IO.StringWriter(codeBuffer, global::System.Globalizati" +
                    "on.CultureInfo.InvariantCulture))\r\n\t\t\t\t{\r\n\t\t\t\t\tlanguageProvider.GenerateCodeFrom" +
                    "Member(rootElement, writer, options);\r\n\t\t\t\t\tlanguageProvider.GenerateCodeFromMem" +
                    "ber(rootElementProperty, writer, options);\r\n\t\t\t\t\tif (resolver != null)\r\n\t\t\t\t\t{\r\n" +
                    "\t\t\t\t\t\tlanguageProvider.GenerateCodeFromMember(resolver, writer, options);\r\n\t\t\t\t\t" +
                    "}\r\n\t\t\t\t}\r\n\t\t\t\tthis.oneTimeCodeGenerated = true;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/// <summary>" +
                    "\r\n\t/// Contribute additively to initialization code for the TextTransformation g" +
                    "enerated class.\r\n\t/// </summary>\r\n\t/// <remarks>\r\n\t/// This code will be added b" +
                    "efore the call to the base class.\r\n\t/// </remarks>\r\n\t/// <param name=\"directiveN" +
                    "ame\"></param>\r\n\t/// <param name=\"codeBuffer\"></param>\r\n\t/// <param name=\"languag" +
                    "eProvider\"></param>\r\n\t/// <param name=\"requiresArguments\"></param>\r\n\t/// <param " +
                    "name=\"providesArguments\"></param>\r\n\tprotected override void GeneratePreInitializ" +
                    "ationCode(string directiveName, global::System.Text.StringBuilder codeBuffer, gl" +
                    "obal::System.CodeDom.Compiler.CodeDomProvider languageProvider, global::System.C" +
                    "ollections.Generic.IDictionary<string, string> requiresArguments, global::System" +
                    ".Collections.Generic.IDictionary<string, string> providesArguments)\r\n\t{\r\n\t\tif ((" +
                    "global::System.StringComparer.OrdinalIgnoreCase.Compare(directiveName, supported" +
                    "DirectiveName) == 0))\r\n\t\t{\r\n\t\t\tif (languageProvider != null)\r\n\t\t\t{\r\n\t\t\t\tstring[]" +
                    " domainModels = {\r\n\t\t\t\t\t\"");
            
            #line 270 "J:\Uni\CC Processes\Werkzeuge\PDE 2\Tum.PDE.ToolFramework\Tum.PDE.ToolFramework.Templates\Shell\Model\DirectiveProcessorGenerator.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture(domainModelFullName));
            
            #line default
            #line hidden
            this.Write("\",\r\n\t\t\t\t};\r\n\r\n\t\t\t\tglobal::System.CodeDom.Compiler.CodeGeneratorOptions options = " +
                    "new global::System.CodeDom.Compiler.CodeGeneratorOptions();\r\n\t\t\t\toptions.BlankLi" +
                    "nesBetweenMembers = true;\r\n\t\t\t\toptions.IndentString = \"    \";\r\n\t\t\t\toptions.Verba" +
                    "timOrder = true;\r\n\t\t\t\toptions.BracingStyle = \"C\";\r\n\t\t\t\tusing (global::System.IO." +
                    "StringWriter writer = new global::System.IO.StringWriter(codeBuffer, global::Sys" +
                    "tem.Globalization.CultureInfo.InvariantCulture))\r\n\t\t\t\t{\r\n\t\t\t\t\tforeach (string do" +
                    "mainModel in domainModels)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tglobal::System.CodeDom.CodeExpressionS" +
                    "tatement addModel = new global::System.CodeDom.CodeExpressionStatement(new globa" +
                    "l::System.CodeDom.CodeMethodInvokeExpression(new global::System.CodeDom.CodeMeth" +
                    "odReferenceExpression(new global::System.CodeDom.CodeThisReferenceExpression(), " +
                    "\"AddDomainModel\"), new global::System.CodeDom.CodeTypeOfExpression(domainModel))" +
                    ");\r\n\t\t\t\t\t\tlanguageProvider.GenerateCodeFromStatement(addModel, writer, options);" +
                    "\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t/// <summary>\r\n\t/// Property that indicates " +
                    "whether this directive processor needs access to diagram data as well as\r\n\t/// m" +
                    "odel data.  Normally, this is not the case so the default value of this property" +
                    " is false.\r\n\t/// Derived classes may override this property to change the value." +
                    "\r\n\t/// </summary>\r\n\tprotected virtual bool LoadDiagramData\r\n\t{\r\n \t\tget\r\n\t\t{\r\n\t\t\t" +
                    "return false;\r\n\t\t}\r\n\t}\r\n\r\n\t/// <summary>\r\n\t/// Contribute additively to initiali" +
                    "zation code for the TextTransformation generated class.\r\n\t/// </summary>\r\n\t/// <" +
                    "remarks>\r\n\t/// This code will be added after the call to the base class.\r\n\t/// <" +
                    "/remarks>\r\n\t/// <param name=\"directiveName\"></param>\r\n\t/// <param name=\"codeBuff" +
                    "er\"></param>\r\n\t/// <param name=\"languageProvider\"></param>\r\n\t/// <param name=\"re" +
                    "quiresArguments\"></param>\r\n\t/// <param name=\"providesArguments\"></param>\r\n\t[glob" +
                    "al::System.Diagnostics.CodeAnalysis.SuppressMessage(\"Microsoft.Globalization\", \"" +
                    "CA1308:NormalizeStringsToUppercase\", Justification = \"Generated code is not mean" +
                    "t for normalization purpose.\")]\r\n\t[global::System.Diagnostics.CodeAnalysis.Suppr" +
                    "essMessage(\"Microsoft.Maintainability\", \"CA1506:AvoidExcessiveClassCoupling\", Ju" +
                    "stification = \"Generated code.\")]\r\n\tprotected override void GeneratePostInitiali" +
                    "zationCode(string directiveName, global::System.Text.StringBuilder codeBuffer, g" +
                    "lobal::System.CodeDom.Compiler.CodeDomProvider languageProvider, global::System." +
                    "Collections.Generic.IDictionary<string, string> requiresArguments, global::Syste" +
                    "m.Collections.Generic.IDictionary<string, string> providesArguments)\r\n\t{\r\n\t\tif (" +
                    "(global::System.StringComparer.OrdinalIgnoreCase.Compare(directiveName, supporte" +
                    "dDirectiveName) == 0))\r\n\t\t{\r\n\t\t\t// We check the encoding of the model file, and " +
                    "ask the host to use that\r\n\t\t\t// encoding to write the output. This is to make su" +
                    "re we use the correct encoding\r\n\t\t\t// if the model file contains international c" +
                    "haracters that could be used in \r\n\t\t\t// the template output.\r\n\t\t\tstring fileName" +
                    " = requiresArguments[requiresFileParameter];\r\n\t\t\tif (!string.IsNullOrEmpty(fileN" +
                    "ame) && global::System.IO.File.Exists(fileName))\r\n\t\t\t{\r\n\t\t\t\tHost.SetOutputEncodi" +
                    "ng(VSTextTemplating::EncodingHelper.GetEncoding(fileName), false);\r\n\t\t\t}\r\n\r\n\t\t\ti" +
                    "f (languageProvider != null)\r\n\t\t\t{\r\n\t\t\t\tglobal::System.CodeDom.CodeMethodInvokeE" +
                    "xpression invokeLoad;\r\n\t\t\t\tglobal::System.String transactionName = providesArgum" +
                    "ents[providesModelParameter].ToLower(global::System.Globalization.CultureInfo.In" +
                    "variantCulture) + \"Transaction\";\r\n\t\t\t\tglobal::System.CodeDom.CodeVariableDeclara" +
                    "tionStatement transactionDeclaration = new global::System.CodeDom.CodeVariableDe" +
                    "clarationStatement(new global::System.CodeDom.CodeTypeReference(typeof(DslModeli" +
                    "ng::Transaction)), transactionName, new global::System.CodeDom.CodePrimitiveExpr" +
                    "ession(null));\r\n\t\t\t\tglobal::System.CodeDom.CodeStatement finallyStatement = new " +
                    "global::System.CodeDom.CodeConditionStatement(new global::System.CodeDom.CodeBin" +
                    "aryOperatorExpression(new global::System.CodeDom.CodeVariableReferenceExpression" +
                    "(transactionName), global::System.CodeDom.CodeBinaryOperatorType.IdentityInequal" +
                    "ity, new global::System.CodeDom.CodePrimitiveExpression(null)), new global::Syst" +
                    "em.CodeDom.CodeExpressionStatement(new global::System.CodeDom.CodeMethodInvokeEx" +
                    "pression(new global::System.CodeDom.CodeVariableReferenceExpression(transactionN" +
                    "ame), \"Dispose\")));\r\n\t\t\t\tglobal::System.Collections.Generic.List<global::System." +
                    "CodeDom.CodeStatement> txTryStatements = new global::System.Collections.Generic." +
                    "List<global::System.CodeDom.CodeStatement>();\r\n\t\t\t\tglobal::System.CodeDom.CodeVa" +
                    "riableDeclarationStatement serializationResultDeclaration = new global::System.C" +
                    "odeDom.CodeVariableDeclarationStatement(new global::System.CodeDom.CodeTypeRefer" +
                    "ence(typeof(DslModeling::SerializationResult)), \"serializationResult\", new globa" +
                    "l::System.CodeDom.CodeObjectCreateExpression(new global::System.CodeDom.CodeType" +
                    "Reference(typeof(DslModeling::SerializationResult))));\r\n\r\n\t\t\t\tinvokeLoad = new g" +
                    "lobal::System.CodeDom.CodeMethodInvokeExpression(\r\n\t\t\t\t\tnew global::System.CodeD" +
                    "om.CodeMethodReferenceExpression(new global::System.CodeDom.CodeFieldReferenceEx" +
                    "pression(new global::System.CodeDom.CodeTypeReferenceExpression(typeof(");
            
            #line 340 "J:\Uni\CC Processes\Werkzeuge\PDE 2\Tum.PDE.ToolFramework\Tum.PDE.ToolFramework.Templates\Shell\Model\DirectiveProcessorGenerator.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture(this.MetaModel.Name));
            
            #line default
            #line hidden
            this.Write("SerializationHelper)), \"Instance\"), \"LoadModel\"), new global::System.CodeDom.Code" +
                    "VariableReferenceExpression(\"serializationResult\"), new global::System.CodeDom.C" +
                    "odePropertyReferenceExpression(new global::System.CodeDom.CodeThisReferenceExpre" +
                    "ssion(), \"Store\"), new global::System.CodeDom.CodePrimitiveExpression(requiresAr" +
                    "guments[requiresFileParameter]), new global::System.CodeDom.CodePrimitiveExpress" +
                    "ion(null), new global::System.CodeDom.CodePrimitiveExpression(null), new global:" +
                    ":System.CodeDom.CodePrimitiveExpression(null));\r\n\r\n\t\t\t\tglobal::System.CodeDom.Co" +
                    "deAssignStatement loadAssign = new global::System.CodeDom.CodeAssignStatement(ne" +
                    "w global::System.CodeDom.CodeFieldReferenceExpression(new global::System.CodeDom" +
                    ".CodeThisReferenceExpression(), providesArguments[providesModelParameter].ToLowe" +
                    "r(global::System.Globalization.CultureInfo.InvariantCulture) + \"Value\"), invokeL" +
                    "oad);\r\n\t\t\t\ttxTryStatements.Add(serializationResultDeclaration);\r\n\t\t\t\ttxTryStatem" +
                    "ents.Add(new global::System.CodeDom.CodeAssignStatement(new global::System.CodeD" +
                    "om.CodeVariableReferenceExpression(transactionName), new global::System.CodeDom." +
                    "CodeMethodInvokeExpression(new global::System.CodeDom.CodePropertyReferenceExpre" +
                    "ssion(new global::System.CodeDom.CodePropertyReferenceExpression(new global::Sys" +
                    "tem.CodeDom.CodeThisReferenceExpression(), \"Store\"), \"TransactionManager\"), \"Beg" +
                    "inTransaction\", new global::System.CodeDom.CodePrimitiveExpression(\"Load\"), new " +
                    "global::System.CodeDom.CodePrimitiveExpression(true))));\r\n\t\t\t\ttxTryStatements.Ad" +
                    "d(loadAssign);\r\n\t\t\t\tglobal::System.CodeDom.CodeConditionStatement serializationR" +
                    "esultCheck = new global::System.CodeDom.CodeConditionStatement(\r\n\t\t\t\t\tnew global" +
                    "::System.CodeDom.CodePropertyReferenceExpression(new global::System.CodeDom.Code" +
                    "VariableReferenceExpression(\"serializationResult\"), \"Failed\"),\r\n\t\t\t\t\tnew global:" +
                    ":System.CodeDom.CodeThrowExceptionStatement(new global::System.CodeDom.CodeObjec" +
                    "tCreateExpression(new global::System.CodeDom.CodeTypeReference(typeof(DslModelin" +
                    "g::SerializationException)), new global::System.CodeDom.CodeVariableReferenceExp" +
                    "ression(\"serializationResult\")))\r\n\t\t\t\t);\r\n\t\t\t\ttxTryStatements.Add(serializationR" +
                    "esultCheck);\r\n\t\t\t\ttxTryStatements.Add(new global::System.CodeDom.CodeExpressionS" +
                    "tatement(new global::System.CodeDom.CodeMethodInvokeExpression(new global::Syste" +
                    "m.CodeDom.CodeVariableReferenceExpression(transactionName), \"Commit\")));\r\n\t\t\t\tgl" +
                    "obal::System.CodeDom.CodeTryCatchFinallyStatement txTryStatement = new global::S" +
                    "ystem.CodeDom.CodeTryCatchFinallyStatement(txTryStatements.ToArray(), new global" +
                    "::System.CodeDom.CodeCatchClause[] { }, new global::System.CodeDom.CodeStatement" +
                    "[] { finallyStatement });\r\n\r\n\r\n\t\t\t\t// We check if the user has requested validat" +
                    "ion to be performed. If so, we call\r\n\t\t\t\t// ValidateStore() on the base Modeling" +
                    "TextTransformation class.\r\n\t\t\t\tstring validationCategories = requiresArguments[r" +
                    "equiresValidationParameter];\r\n\t\t\t\tglobal::System.CodeDom.CodeMethodInvokeExpress" +
                    "ion validationInvoke = null;\r\n\t\t\t\tif (!string.IsNullOrEmpty(validationCategories" +
                    "))\r\n\t\t\t\t{\r\n\t\t\t\t\tvalidationInvoke = new global::System.CodeDom.CodeMethodInvokeEx" +
                    "pression(new global::System.CodeDom.CodeThisReferenceExpression(), \"ValidateStor" +
                    "e\", new global::System.CodeDom.CodePrimitiveExpression(validationCategories), ne" +
                    "w global::System.CodeDom.CodePropertyReferenceExpression(new global::System.Code" +
                    "Dom.CodeThisReferenceExpression(), \"Errors\"));\r\n\t\t\t\t}\r\n\r\n\t\t\t\tglobal::System.Code" +
                    "Dom.Compiler.CodeGeneratorOptions options = new global::System.CodeDom.Compiler." +
                    "CodeGeneratorOptions();\r\n\t\t\t\toptions.BlankLinesBetweenMembers = true;\r\n\t\t\t\toptio" +
                    "ns.IndentString = \"    \";\r\n\t\t\t\toptions.VerbatimOrder = true;\r\n\t\t\t\toptions.Bracin" +
                    "gStyle = \"C\";\r\n\t\t\t\tusing (global::System.IO.StringWriter writer = new global::Sy" +
                    "stem.IO.StringWriter(codeBuffer, global::System.Globalization.CultureInfo.Invari" +
                    "antCulture))\r\n\t\t\t\t{\r\n\t\t\t\t\tlanguageProvider.GenerateCodeFromStatement(transaction" +
                    "Declaration, writer, options);\r\n\t\t\t\t\tlanguageProvider.GenerateCodeFromStatement(" +
                    "txTryStatement, writer, options);\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (validationInvoke != null)\r\n\t\t" +
                    "\t\t\t{\r\n\t\t\t\t\t\tlanguageProvider.GenerateCodeFromStatement(new global::System.CodeDo" +
                    "m.CodeExpressionStatement(validationInvoke), writer, options);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t" +
                    "\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/// <summary>\r\n\t/// Process arguments\r\n\t/// </summary>\r\n\t/// <p" +
                    "aram name=\"directiveName\"></param>\r\n\t/// <param name=\"requiresArguments\"></param" +
                    ">\r\n\t/// <param name=\"providesArguments\"></param>\r\n\tprotected override void PostP" +
                    "rocessArguments(string directiveName, global::System.Collections.Generic.IDictio" +
                    "nary<string, string> requiresArguments, global::System.Collections.Generic.IDict" +
                    "ionary<string, string> providesArguments)\r\n\t{\r\n\t\tif ((global::System.StringCompa" +
                    "rer.OrdinalIgnoreCase.Compare(directiveName, supportedDirectiveName) == 0))\r\n\t\t{" +
                    "\r\n\t\t\t// Give the host a chance to resolve the fileName\r\n\t\t\trequiresArguments[req" +
                    "uiresFileParameter] = this.Host.ResolvePath(requiresArguments[requiresFileParame" +
                    "ter]);\r\n\t\t}\r\n\t}\r\n\r\n\t/// <summary>\r\n\t/// Return namespace imports necessary for r" +
                    "unning template\r\n\t/// </summary>\r\n\t/// <returns></returns>\r\n\tpublic override str" +
                    "ing[] GetImportsForProcessingRun()\r\n\t{\r\n\t\tglobal::System.Collections.Generic.Lis" +
                    "t<string> imports = new global::System.Collections.Generic.List<string>(base.Get" +
                    "ImportsForProcessingRun());\r\n\r\n\t\timports.Add(\"Microsoft.VisualStudio.Modeling\");" +
                    "\r\n\t\timports.Add(\"System.CodeDom.Compiler\");\r\n");
            
            #line 408 "J:\Uni\CC Processes\Werkzeuge\PDE 2\Tum.PDE.ToolFramework\Tum.PDE.ToolFramework.Templates\Shell\Model\DirectiveProcessorGenerator.tt"

	if (!String.IsNullOrEmpty(this.MetaModel.Namespace))
	{

            
            #line default
            #line hidden
            this.Write("\t\timports.Add(\"");
            
            #line 412 "J:\Uni\CC Processes\Werkzeuge\PDE 2\Tum.PDE.ToolFramework\Tum.PDE.ToolFramework.Templates\Shell\Model\DirectiveProcessorGenerator.tt"
            this.Write(this.ToStringHelper.ToStringWithCulture(this.MetaModel.Namespace));
            
            #line default
            #line hidden
            this.Write("\");\r\n");
            
            #line 413 "J:\Uni\CC Processes\Werkzeuge\PDE 2\Tum.PDE.ToolFramework\Tum.PDE.ToolFramework.Templates\Shell\Model\DirectiveProcessorGenerator.tt"

	}

            
            #line default
            #line hidden
            this.Write(@"
		return imports.ToArray();
	}

	/// <summary>
	/// Get assembly references needed for running template
	/// </summary>
	/// <returns></returns>
	public override string[] GetReferencesForProcessingRun()
	{
		global::System.Collections.Generic.List<string> references = new global::System.Collections.Generic.List<string>(base.GetReferencesForProcessingRun());
		references.Add(this.GetType().Assembly.Location);
		references.Add(typeof(DslModeling::Store).Assembly.Location);
		references.Add(""Microsoft.VisualStudio.TextTemplating.Modeling.10.0.dll"");
		return references.ToArray();
	}
}
}

");
            return this.GenerationEnvironment.ToString();
        }
    }
    
    #line default
    #line hidden
}
