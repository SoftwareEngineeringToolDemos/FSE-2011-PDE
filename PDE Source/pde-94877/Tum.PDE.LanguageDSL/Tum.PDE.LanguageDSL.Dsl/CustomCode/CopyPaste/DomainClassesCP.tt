<#@ template inherits="Microsoft.VisualStudio.TextTemplating.VSHost.ModelingTextTransformation" #>
<#@ Dsl processor="DslDirectiveProcessor"  requires="fileName='..\..\DslDefinition.dsl'" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Globalization" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ output extension=".cs" #>

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using DslModeling = global::Microsoft.VisualStudio.Modeling;
using DslDesign = global::Microsoft.VisualStudio.Modeling.Design;
using DslEditorModeling = global::Tum.PDE.LanguageDSL.CopyPaste;

<#
// Generate code for all the classes in this domain model
foreach(DomainClass domainClass in this.DslLibrary.Classes)
{
	GenerateModelMergeMembers(domainClass);
}
#>

<#+
private void GenerateModelMergeMembers(DomainClass domainClass)
{
	string baseClass = "Tum.PDE.LanguageDSL.CopyPaste.IModelMergeElements";
	if( domainClass.BaseClass != null )
		baseClass = domainClass.BaseClass.Name;
	
	string dcName = domainClass.Name;
	if( domainClass.GeneratesDoubleDerived )
		dcName += "Base";
#>
namespace Tum.PDE.LanguageDSL
{
    public partial class <#= dcName #> : <#= baseClass #>
    {
<#+
	this.PushIndent("\t\t");
	GenerateModelMergeMembersInternal(domainClass);
	this.PopIndent();
#>
	}
}
<#+
}

private void GenerateModelMergeMembersInternal(DomainClass domainClass)
{
	List<DomainRole> embRoles = new List<DomainRole>();
	List<DomainRole> refRoles = new List<DomainRole>();
	foreach(DomainRole role in domainClass.RolesPlayed)
	{
		if( role.Relationship.InheritanceModifier == InheritanceModifier.Abstract )
			continue;
			
		if(role.Relationship.IsEmbedding && role.Relationship.Source == role)
			embRoles.Add(role);
		
		if(!role.Relationship.IsEmbedding)
			refRoles.Add(role);		
	}
	List<DomainRole> domainRoles = new List<DomainRole>();	
	domainRoles.AddRange(embRoles);
	domainRoles.AddRange(refRoles);
	
	IEnumerable<DomainRole> sortedRoles = domainRoles;
	IEnumerable<DomainRole> sortedEmbRoles = embRoles;
	IEnumerable<DomainRole> sortedRefRoles = refRoles;
	
	CodeGenerationUtilities.SortRoles(domainRoles);
	CodeGenerationUtilities.SortRoles(embRoles);
	CodeGenerationUtilities.SortRoles(refRoles);
	
	//IEnumerable<DomainRole> sortedRoles = CodeGenerationUtilities.SortRolesByInheritance(domainRoles);
	//IEnumerable<DomainRole> sortedEmbRoles = CodeGenerationUtilities.SortRolesByInheritance(embRoles);
	//IEnumerable<DomainRole> sortedRefRoles = CodeGenerationUtilities.SortRolesByInheritance(refRoles);
	
	string modifier = "virtual";
	if( domainClass.BaseClass != null )
		modifier = "override";
#>
#region IModelMergeElements
/// <summary>
/// Decides whether the element can be copied or not.
/// </summary>
/// <returns>True if the element can be copied. False otherwise.</returns>
public <#= modifier #> bool ModelIsCopyAllowed()
{
<#+
		if( domainClass.BaseClass != null )
		{
#>
	if( !base.ModelIsCopyAllowed() )
		return false;

<#+
		}
#>
	return true;
}

/// <summary>
/// Decides whether the element can be moved or not.
/// </summary>
/// <returns>True if the element can be moved. False otherwise.</returns>
public <#= modifier #> bool ModelIsMoveAllowed()
{
<#+
		if( domainClass.BaseClass != null )
		{
#>
	if( !base.ModelIsMoveAllowed() )
		return false;

<#+
		}
#>

	return true;
}

/// <summary>
/// Decides whether the element can be pasted or not based on the operation.
/// </summary>
/// <param name="protoGroupOperation">Proto group operation.</param>
/// <returns>True if the element can be pasted. False otherwise.</returns>
public <#= modifier #> bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
{
	if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
		return ModelIsMoveAllowed();

<#+
		if( domainClass.BaseClass != null )
		{
#>
	if( !base.ModelIsPasteAllowed(protoGroupOperation) )
		return false;

<#+
		}
#>
	return true;
}

/// <summary>
/// Create a proto element representation of the element, which can be used for paste later.
/// </summary>
/// <param name="protoGroup">Proto group to add the element to.</param>
/// <returns>Proto element representation of the element.</returns>
public <#= modifier #> DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
{
	if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
        if (!ModelIsCopyAllowed())
            return null;

    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
    	return null;

	DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
	protoGroup.AddNewElement(protoElement);
	ModelProcessMergeCopy(protoElement, protoGroup);
	
	return protoElement;
}

/// <summary>
/// Create a proto element representation of the element, which can be used for paste later.
/// </summary>
/// <param name="protoGroup">Proto group to add the element to.</param>
/// <returns>Proto element representation of the element.</returns>
public <#= modifier #> DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
{
	if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
        if (!ModelIsMoveAllowed())
            return null;
			
	if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		return null;
		
	DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
	protoGroup.AddNewElement(protoElement);
	
	return protoElement;		
}

/// <summary>
/// Processes a proto element representation of the element and adds required proto links. 
/// This method is called on base classes from derived classes.
/// 
/// Hint: Properties do not need to be added in this method.
/// </summary>
/// <param name="protoElement">Proto element representation of the element.</param>
/// <param name="protoGroup">Proto group the proto element belongs to.</param>
public <#= modifier #> void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
{
<#+
		if( domainClass.BaseClass != null )
		{
#>
	base.ModelProcessMergeCopy(protoElement, protoGroup);

<#+
		}
		if( sortedRoles.Count() >  0 )
		{	
			foreach (DomainRole role in sortedRoles)
			{
				if( role.Relationship.Source != role )
					continue;
				
				if(!role.Relationship.IsEmbedding)
				{
					if( role.PropagatesCopy == PropagatesCopyOption.DoNotPropagateCopy )
						continue;
				}				
#>
	// <#= role.Relationship.Name #>
	foreach (<#= role.Relationship.GetFullName(true) #> link in DslModeling::DomainRoleInfo.GetElementLinks<<#= role.Relationship.GetFullName(true) #>>(this, <#= role.Relationship.GetFullName(true) #>.<#= role.Name #>DomainRoleId))
	{
		DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
<#+
		string addLink = "AddNewEmbeddingLink";
		if(!role.Relationship.IsEmbedding)
			addLink = "AddNewReferenceLink";
		
#>
		protoGroup.<#= addLink #>(protoLink);
<#+
				if( role.Relationship.IsEmbedding || 
					role.PropagatesCopy == PropagatesCopyOption.PropagatesCopyToLinkAndOppositeRolePlayer)
				{
#>
		
		DslEditorModeling::ModelProtoElement protoElementRS = new DslEditorModeling::ModelProtoElement(link.<#= role.Opposite.Name #>);
		protoGroup.AddNewElement(protoElementRS);
		
		// continue with target element
		if( link.<#= role.Opposite.Name #> is DslEditorModeling::IModelMergeElements )
		{
			(link.<#= role.Opposite.Name #> as DslEditorModeling::IModelMergeElements).ModelCreateMergeCopy(protoGroup);
		}
<#+
				}
#>
	}
<#+
			}
		}
#>
}

/// <summary>
/// Decides whether the element that is represented by the proto element can be pasted or not.
/// </summary>
/// <param name="protoElement">Proto element representation of the element.</param>
/// <param name="protoGroup">Proto group the proto element belongs to.</param>
/// <returns>True if the element can be pasted. False otherwise.</returns>
public <#= modifier #> bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
{
<#+
		
	if( sortedEmbRoles.Count() > 0 )
	{
#>
	if (protoElement != null)
	{
		DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
<#+
		foreach (DomainRole role in sortedEmbRoles)
		{
#>
		if (elementDomainInfo.IsDerivedFrom(<#= role.Opposite.RolePlayer.GetFullName(true) #>.DomainClassId)) 
		{
<#+
			if( role.Multiplicity == Microsoft.VisualStudio.Modeling.DslDefinition.Multiplicity.One || role.Multiplicity == Microsoft.VisualStudio.Modeling.DslDefinition.Multiplicity.ZeroOne )
			{
#>
			// Check that creating a link with this path doesn't cause multiplicity overflow: <#= role.Relationship.Name #>.<#= role.Opposite.Name #>
			if( DslModeling::DomainRoleInfo.GetLinkedElement(this, <#= role.Relationship.GetFullName(true) #>.<#= role.Name #>DomainRoleId) != null )
				return false;
			return true;
<#+
			}
			else
			{
#>
			if( protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
			{
				foreach (<#= role.Relationship.GetFullName(true) #> link in DslModeling::DomainRoleInfo.GetElementLinks<<#= role.Relationship.GetFullName(true) #>>(this, <#= role.Relationship.GetFullName(true) #>.<#= role.Name #>DomainRoleId))				
					if( link.<#= role.Opposite.Name #>.Id == protoElement.ElementId )
						return false;
			}
			return true;
<#+
			}
#>
		}
<#+
		}
#>
	}
<#+
	}
	if( domainClass.BaseClass != null )
	{
#>
	return base.ModelCanMerge(protoElement, protoGroup);
<#+
	}
	else
	{
#>
	return false;
<#+
	}
#>
}

/// <summary>
/// Adds a proto element to the current element.
/// </summary>
/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
/// <param name="groupMerger">
/// Group merger class used to track id mapping, merge errors/warnings and 
/// postprocess merging by rebuilding reference relationships.
/// </param>
/// <param name="isRoot">Root element?</param>
public <#= modifier #> void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
{
	if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
	{
		// add warning message
		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to <#= domainClass.Name #> because paste is not allowed."));
		return;
	}
<#+
	if( sortedEmbRoles.Count() > 0 )
	{
#>
	if (protoElement != null)
	{
		DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
<#+
		foreach (DomainRole role in sortedEmbRoles)
		{
#>
		if (elementDomainInfo.IsDerivedFrom(<#= role.Opposite.RolePlayer.GetFullName(true) #>.DomainClassId)) 
		{
			// get element id
			System.Guid newElementId = System.Guid.NewGuid();
			
			// create property assignments
			DslModeling::PropertyAssignment[] propertyAssignemnts = protoElement.GetPropertyAssignments(this.Store.DefaultPartition, newElementId);
			
            // create the actual model element
			<#= role.Opposite.RolePlayer.GetFullName(true) #> element = null;			
<#+
			List<DomainClass> elementsDerived = new List<DomainClass>();
			if( role.Opposite.RolePlayer.InheritanceModifier != InheritanceModifier.Abstract )
				elementsDerived.Add(role.Opposite.RolePlayer);
			foreach(DomainClass d in GetDerivedClasses(role.Opposite.RolePlayer) )
				 if(d.InheritanceModifier != InheritanceModifier.Abstract )
					elementsDerived.Add(d);
				
			foreach(DomainClass d in elementsDerived )	
			{
#>
			if( <#= d.GetFullName(true) #>.DomainClassId == elementDomainInfo.Id )
				element = new <#= d.GetFullName(true) #>(this.Store, propertyAssignemnts);
<#+
			}
#>
			if( element == null )
				throw new System.ArgumentNullException("Element is null in ModelMerge: " + elementDomainInfo.Name);
			
			if( !element.ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling.ValidationMessage("ModelMergePasteDisallowedId",
                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to <#= role.RolePlayer.Name #> because paste is not allowed."));
				
				element.Delete();
				return;
 			}
			
			if( isRoot && groupMerger.ProtoGroup.Operation != DslEditorModeling.ModelProtoGroupOperation.Move)
			{
				//element.Name = "Copy of " + element.Name;
			}
			
			// update id mapping
			groupMerger.SetIdMapping(protoElement.ElementId, newElementId);
			
			// add child element
<#+
		if( role.Multiplicity == Microsoft.VisualStudio.Modeling.DslDefinition.Multiplicity.One || role.Multiplicity == Microsoft.VisualStudio.Modeling.DslDefinition.Multiplicity.ZeroOne )
		{
#>
			DslModeling::DomainRoleInfo.SetLinkedElement(this, <#= role.Relationship.GetFullName(true) #>.<#= role.Name #>DomainRoleId, element);
<#+
		}
		else
		{
#>
			GetRoleCollection<DslModeling::LinkedElementCollection<<#= role.Opposite.RolePlayer.GetFullName(true) #>>, <#= role.Opposite.RolePlayer.GetFullName(true)#>>(<#= role.Relationship.GetFullName(true) #>.<#= role.Name #>DomainRoleId).Add(element);
<#+
		}
#>

			// continue with child elements (Embedding Relationship)
			System.Collections.Generic.List<DslEditorModeling::ModelProtoElement> embeddedProtoElements = groupMerger.GetEmbeddedElements(this.Store.DefaultPartition, protoElement);
			if( embeddedProtoElements.Count > 0 )
			{
				foreach (DslEditorModeling::ModelProtoElement p in embeddedProtoElements)
					(element as DslEditorModeling::IModelMergeElements).ModelMerge(p, groupMerger, false);
			}
		}
<#+
		}
#>
	}
<#+	
	}
	if( domainClass.BaseClass != null )
	{
#>

	base.ModelMerge(protoElement, groupMerger, isRoot);
<#+
	}
#>
}

/// <summary>
/// Adds a proto link to the current element.
/// </summary>
/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
/// <param name="groupMerger">
/// Group merger class used to track id mapping, merge errors/warnings and 
/// postprocess merging by rebuilding reference relationships.
/// </param>
public <#= modifier #> void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
{
<#+
	if( sortedRefRoles.Count() > 0 )
	{
		List<DomainRelationship> relationships = new List<DomainRelationship>();
		foreach (DomainRole role in sortedRefRoles)
		{
			if( !relationships.Contains(role.Relationship) && role.Relationship.Source == role )
				relationships.Add(role.Relationship);
		}
#>

	DslModeling::DomainRelationshipInfo linkDomainInfo = null;
	if (protoLink != null)
	{
		linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(protoLink.DomainClassId);
	}
	else
	{
		// try getting the linkDomainInfo from name
<#+
		foreach (DomainRelationship relationship in relationships)
		{
#>
		if( protoLink.Name == "<#= relationship.Name #>" && linkDomainInfo == null)
		{
			linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(<#= relationship.Name #>.DomainClassId);
		}
<#+
		}
#>
	}
	
	if( linkDomainInfo == null )
	{
		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkDomainTypeMissing",
			             DslEditorModeling.ModelValidationViolationType.Error, "Element link can not be created as the corresponding domain type is missing."));
		return;
	}

<#+
		foreach (DomainRelationship relationship in relationships)
		{
#>
		if (linkDomainInfo.IsDerivedFrom(<#= relationship.GetFullName(true) #>.DomainClassId)) 
		{
			// see if this element is taking part in this role
			bool bTakesPart = false;
			
			DslEditorModeling::ModelProtoRolePlayer sourceRolePlayer = protoLink.GetSourceRolePlayer(this.Store.DefaultPartition);
			DslEditorModeling::ModelProtoElement sourceProtoElement = groupMerger.GetElementById(sourceRolePlayer.RolePlayerId);
			System.Guid mappedSourceIdTP = System.Guid.Empty;
			if( sourceProtoElement != null )
			{
				mappedSourceIdTP = groupMerger.GetIdMapping(sourceRolePlayer.RolePlayerId);
				if( mappedSourceIdTP == this.Id )
					bTakesPart = true;
			}

			if( bTakesPart )
			{		
				bool bExists = true;
        	    if( this.Store.ElementDirectory.FindElement(protoLink.ElementId) == null )
        	        bExists = false;
					
				if( bExists && groupMerger.ProtoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
        	    {
        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkExistsOnMoveId",
			             DslEditorModeling.ModelValidationViolationType.Error, "Element link exists although the operation = Move."));
				}
				
				#region Target
				// see if target element was copied
				DslEditorModeling::ModelProtoRolePlayer targetRolePlayer = protoLink.GetTargetRolePlayer(this.Store.DefaultPartition);
				DslEditorModeling::ModelProtoElement targetProtoElement = groupMerger.GetElementById(targetRolePlayer.RolePlayerId);
				System.Guid mappedTargetId = System.Guid.Empty;
				if( targetProtoElement != null )
				{
				 	mappedTargetId= groupMerger.GetIdMapping(targetRolePlayer.RolePlayerId);
				}
				
				if( mappedTargetId == System.Guid.Empty )
				{
					// try creating relationship to existing element
					mappedTargetId = targetRolePlayer.RolePlayerId;
				}
				
				if( mappedTargetId == System.Guid.Empty )
				{
					// try creating relationship to existing element with the same name as the previous element
					// TODO
				}

				if( mappedTargetId == System.Guid.Empty )
				{
					// log warning
        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotCopiedId",
			             DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not copied. Relationship: <#= relationship.Name #>"));
				}
				else
				{
					DslModeling::ModelElement targetElement = this.Store.ElementDirectory.FindElement(mappedTargetId);
					if( targetElement == null )
					{
						// log error
        	        	groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotFoundId",
			            	DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not found. Relationship: <#= relationship.Name #>"));
					}
					else
					{
						bool bContinue = true;

						// check cardinalities, so we don't violate them by additing a new relationship
<#+
							if( relationship.Source.Multiplicity == Microsoft.VisualStudio.Modeling.DslDefinition.Multiplicity.One ||
								relationship.Source.Multiplicity == Microsoft.VisualStudio.Modeling.DslDefinition.Multiplicity.ZeroOne )
							{
#>
						if( DslModeling::DomainRoleInfo.GetLinkedElement(this, <#= relationship.GetFullName(true) #>.<#= relationship.Source.Name #>DomainRoleId) != null )
						{
							// log warning
        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
			            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: <#= relationship.Name #>"));
							
							bContinue = false;
						}
<#+
							}
							
							if( relationship.Target.Multiplicity == Microsoft.VisualStudio.Modeling.DslDefinition.Multiplicity.One ||
								relationship.Target.Multiplicity == Microsoft.VisualStudio.Modeling.DslDefinition.Multiplicity.ZeroOne )
							{
#>
						if( DslModeling::DomainRoleInfo.GetLinkedElement(targetElement, <#= relationship.GetFullName(true) #>.<#= relationship.Target.Name #>DomainRoleId) != null )
						{
							// log warning
        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
			            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: <#= relationship.Name #>"));
							
							bContinue = false;
						}
<#+
							}
#>
						
						if( bContinue )
						{
							// create property assignments
							DslModeling::PropertyAssignment[] propertyAssignemnts = protoLink.GetPropertyAssignments(this.Store.DefaultPartition, 
								System.Guid.NewGuid());
						
							// create role assignments
							DslModeling.RoleAssignment[] roleAssignments = new DslModeling.RoleAssignment[2];
                	        roleAssignments[0] = new DslModeling.RoleAssignment(<#= relationship.GetFullName(true) #>.<#= relationship.Source.Name #>DomainRoleId, this);
							roleAssignments[1] = new DslModeling.RoleAssignment(<#= relationship.GetFullName(true) #>.<#= relationship.Target.Name #>DomainRoleId, targetElement);
							
							// create new relationship
							new <#= relationship.GetFullName(true) #>(this.Store, roleAssignments, propertyAssignemnts);
						}
					}
				}
				#endregion
			}
		}
<#+
		}
	}
	if( domainClass.BaseClass != null )
	{
#>

	base.ModelMerge(protoLink, groupMerger);
<#+
	}
#>	
}

/// <summary>
/// Moves a proto element to the current element.
/// </summary>
/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
/// <param name="groupMerger">
/// Group merger class used to track id mapping, merge errors/warnings and 
/// postprocess merging by rebuilding reference relationships.
/// </param>
public <#= modifier #> void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
{
	if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
	{
		// add warning message
		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to <#= domainClass.Name #> because move is not allowed."));
		return;
	}
<#+
	if( sortedEmbRoles.Count() > 0 )
	{
#>
	if (protoElement != null)
	{
		DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
<#+
		foreach (DomainRole role in sortedEmbRoles)
		{
#>
		if (elementDomainInfo.IsDerivedFrom(<#= role.Opposite.RolePlayer.GetFullName(true) #>.DomainClassId)) 
		{
            DslModeling::ModelElement modelElement = this.Store.ElementDirectory.FindElement(protoElement.ElementId);
            if( modelElement == null )
            {
                groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementMissingOnMoveId",
		             DslEditorModeling.ModelValidationViolationType.Error, "Element exists although the operation = Move."));
                return;
			}

			// change parent
			DslModeling::DomainRoleInfo.SetLinkedElement(modelElement, <#= role.Relationship.GetFullName(true) #>.<#= role.Opposite.Name #>DomainRoleId, this);
			return;
		}
<#+
		}
#>
	}
<#+	
	}
	if( domainClass.BaseClass != null )
	{
#>

	base.ModelMove(protoElement, groupMerger);
<#+
	}
#>
}

/// <summary>
/// Finalize. This method is called on each copied element once all the elements and links are processed.
/// </summary>
/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
/// <param name="groupMerger">
/// Group merger class used to track id mapping, merge errors/warnings and 
/// postprocess merging by rebuilding reference relationships.
/// </param>
public <#= modifier #> void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
{
<#+	
	if( domainClass.BaseClass != null )
	{
#>

	base.ModelFinalize(protoElement, groupMerger);
<#+
	}
#>
}

/// <summary>
/// Finalize merge.
/// </summary>
/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
/// <param name="groupMerger">
/// Group merger class used to track id mapping, merge errors/warnings and 
/// postprocess merging by rebuilding reference relationships.
/// </param>
public <#= modifier #> void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
{
<#+	
	if( domainClass.BaseClass != null )
	{
#>

	base.ModelFinalizeMerge(protoElement, groupMerger);
<#+
	}
#>
}
#endregion
<#+
}#>

<#+
private IList<DomainClass> GetDerivedClasses(DomainClass d)
{
	List<DomainClass> derivedClasses = new List<DomainClass>();
	
	for(int i = 0; i < d.SubClasses.Count; i++ )
	{
		derivedClasses.Add(d.SubClasses[i]);
		derivedClasses.AddRange(GetDerivedClasses(d.SubClasses[i]));
	}
	
	return derivedClasses;
}
#>
