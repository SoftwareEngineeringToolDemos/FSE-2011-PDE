
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using DslModeling = global::Microsoft.VisualStudio.Modeling;
using DslDesign = global::Microsoft.VisualStudio.Modeling.Design;
using DslEditorModeling = global::Tum.PDE.LanguageDSL.CopyPaste;

namespace Tum.PDE.LanguageDSL
{
    public partial class MetaModelBase : BaseMetaModel
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
			// MetaModelHasDomainTypes
			foreach (global::Tum.PDE.LanguageDSL.MetaModelHasDomainTypes link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.MetaModelHasDomainTypes>(this, global::Tum.PDE.LanguageDSL.MetaModelHasDomainTypes.MetaModelDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewEmbeddingLink(protoLink);
				
				DslEditorModeling::ModelProtoElement protoElementRS = new DslEditorModeling::ModelProtoElement(link.DomainType);
				protoGroup.AddNewElement(protoElementRS);
				
				// continue with target element
				if( link.DomainType is DslEditorModeling::IModelMergeElements )
				{
					(link.DomainType as DslEditorModeling::IModelMergeElements).ModelCreateMergeCopy(protoGroup);
				}
			}
			// MetaModelHasValidation
			foreach (global::Tum.PDE.LanguageDSL.MetaModelHasValidation link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.MetaModelHasValidation>(this, global::Tum.PDE.LanguageDSL.MetaModelHasValidation.MetaModelDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewEmbeddingLink(protoLink);
				
				DslEditorModeling::ModelProtoElement protoElementRS = new DslEditorModeling::ModelProtoElement(link.Validation);
				protoGroup.AddNewElement(protoElementRS);
				
				// continue with target element
				if( link.Validation is DslEditorModeling::IModelMergeElements )
				{
					(link.Validation as DslEditorModeling::IModelMergeElements).ModelCreateMergeCopy(protoGroup);
				}
			}
			// MetaModelHasAdditionalInformation
			foreach (global::Tum.PDE.LanguageDSL.MetaModelHasAdditionalInformation link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.MetaModelHasAdditionalInformation>(this, global::Tum.PDE.LanguageDSL.MetaModelHasAdditionalInformation.MetaModelDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewEmbeddingLink(protoLink);
				
				DslEditorModeling::ModelProtoElement protoElementRS = new DslEditorModeling::ModelProtoElement(link.AdditionalInformation);
				protoGroup.AddNewElement(protoElementRS);
				
				// continue with target element
				if( link.AdditionalInformation is DslEditorModeling::IModelMergeElements )
				{
					(link.AdditionalInformation as DslEditorModeling::IModelMergeElements).ModelCreateMergeCopy(protoGroup);
				}
			}
			// MetaModelHasMetaModelLibraries
			foreach (global::Tum.PDE.LanguageDSL.MetaModelHasMetaModelLibraries link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.MetaModelHasMetaModelLibraries>(this, global::Tum.PDE.LanguageDSL.MetaModelHasMetaModelLibraries.MetaModelDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewEmbeddingLink(protoLink);
				
				DslEditorModeling::ModelProtoElement protoElementRS = new DslEditorModeling::ModelProtoElement(link.MetaModelLibrary);
				protoGroup.AddNewElement(protoElementRS);
				
				// continue with target element
				if( link.MetaModelLibrary is DslEditorModeling::IModelMergeElements )
				{
					(link.MetaModelLibrary as DslEditorModeling::IModelMergeElements).ModelCreateMergeCopy(protoGroup);
				}
			}
			// MetaModelHasView
			foreach (global::Tum.PDE.LanguageDSL.MetaModelHasView link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.MetaModelHasView>(this, global::Tum.PDE.LanguageDSL.MetaModelHasView.MetaModelDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewEmbeddingLink(protoLink);
				
				DslEditorModeling::ModelProtoElement protoElementRS = new DslEditorModeling::ModelProtoElement(link.View);
				protoGroup.AddNewElement(protoElementRS);
				
				// continue with target element
				if( link.View is DslEditorModeling::IModelMergeElements )
				{
					(link.View as DslEditorModeling::IModelMergeElements).ModelCreateMergeCopy(protoGroup);
				}
			}
			// MetaModelHasModelContexts
			foreach (global::Tum.PDE.LanguageDSL.MetaModelHasModelContexts link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.MetaModelHasModelContexts>(this, global::Tum.PDE.LanguageDSL.MetaModelHasModelContexts.MetaModelDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewEmbeddingLink(protoLink);
				
				DslEditorModeling::ModelProtoElement protoElementRS = new DslEditorModeling::ModelProtoElement(link.BaseModelContext);
				protoGroup.AddNewElement(protoElementRS);
				
				// continue with target element
				if( link.BaseModelContext is DslEditorModeling::IModelMergeElements )
				{
					(link.BaseModelContext as DslEditorModeling::IModelMergeElements).ModelCreateMergeCopy(protoGroup);
				}
			}
			// MetaModelHasPropertyGridEditors
			foreach (global::Tum.PDE.LanguageDSL.MetaModelHasPropertyGridEditors link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.MetaModelHasPropertyGridEditors>(this, global::Tum.PDE.LanguageDSL.MetaModelHasPropertyGridEditors.MetaModelDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewEmbeddingLink(protoLink);
				
				DslEditorModeling::ModelProtoElement protoElementRS = new DslEditorModeling::ModelProtoElement(link.PropertyGridEditor);
				protoGroup.AddNewElement(protoElementRS);
				
				// continue with target element
				if( link.PropertyGridEditor is DslEditorModeling::IModelMergeElements )
				{
					(link.PropertyGridEditor as DslEditorModeling::IModelMergeElements).ModelCreateMergeCopy(protoGroup);
				}
			}
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.DomainType.DomainClassId)) 
				{
					if( protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
					{
						foreach (global::Tum.PDE.LanguageDSL.MetaModelHasDomainTypes link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.MetaModelHasDomainTypes>(this, global::Tum.PDE.LanguageDSL.MetaModelHasDomainTypes.MetaModelDomainRoleId))				
							if( link.DomainType.Id == protoElement.ElementId )
								return false;
					}
					return true;
				}
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.Validation.DomainClassId)) 
				{
					// Check that creating a link with this path doesn't cause multiplicity overflow: MetaModelHasValidation.Validation
					if( DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Tum.PDE.LanguageDSL.MetaModelHasValidation.MetaModelDomainRoleId) != null )
						return false;
					return true;
				}
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.AdditionalInformation.DomainClassId)) 
				{
					// Check that creating a link with this path doesn't cause multiplicity overflow: MetaModelHasAdditionalInformation.AdditionalInformation
					if( DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Tum.PDE.LanguageDSL.MetaModelHasAdditionalInformation.MetaModelDomainRoleId) != null )
						return false;
					return true;
				}
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.MetaModelLibrary.DomainClassId)) 
				{
					if( protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
					{
						foreach (global::Tum.PDE.LanguageDSL.MetaModelHasMetaModelLibraries link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.MetaModelHasMetaModelLibraries>(this, global::Tum.PDE.LanguageDSL.MetaModelHasMetaModelLibraries.MetaModelDomainRoleId))				
							if( link.MetaModelLibrary.Id == protoElement.ElementId )
								return false;
					}
					return true;
				}
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.View.DomainClassId)) 
				{
					// Check that creating a link with this path doesn't cause multiplicity overflow: MetaModelHasView.View
					if( DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Tum.PDE.LanguageDSL.MetaModelHasView.MetaModelDomainRoleId) != null )
						return false;
					return true;
				}
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.BaseModelContext.DomainClassId)) 
				{
					if( protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
					{
						foreach (global::Tum.PDE.LanguageDSL.MetaModelHasModelContexts link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.MetaModelHasModelContexts>(this, global::Tum.PDE.LanguageDSL.MetaModelHasModelContexts.MetaModelDomainRoleId))				
							if( link.BaseModelContext.Id == protoElement.ElementId )
								return false;
					}
					return true;
				}
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.PropertyGridEditor.DomainClassId)) 
				{
					if( protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
					{
						foreach (global::Tum.PDE.LanguageDSL.MetaModelHasPropertyGridEditors link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.MetaModelHasPropertyGridEditors>(this, global::Tum.PDE.LanguageDSL.MetaModelHasPropertyGridEditors.MetaModelDomainRoleId))				
							if( link.PropertyGridEditor.Id == protoElement.ElementId )
								return false;
					}
					return true;
				}
			}
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to MetaModel because paste is not allowed."));
				return;
			}
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.DomainType.DomainClassId)) 
				{
					// get element id
					System.Guid newElementId = System.Guid.NewGuid();
					
					// create property assignments
					DslModeling::PropertyAssignment[] propertyAssignemnts = protoElement.GetPropertyAssignments(this.Store.DefaultPartition, newElementId);
					
		            // create the actual model element
					global::Tum.PDE.LanguageDSL.DomainType element = null;			
					if( global::Tum.PDE.LanguageDSL.ExternalType.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.ExternalType(this.Store, propertyAssignemnts);
					if( global::Tum.PDE.LanguageDSL.DomainEnumeration.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.DomainEnumeration(this.Store, propertyAssignemnts);
					if( element == null )
						throw new System.ArgumentNullException("Element is null in ModelMerge: " + elementDomainInfo.Name);
					
					if( !element.ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
					{
						// add warning message
						groupMerger.MergeResult.AddMessage(new DslEditorModeling.ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to MetaModel because paste is not allowed."));
						
						element.Delete();
						return;
		 			}
					
					if( isRoot && groupMerger.ProtoGroup.Operation != DslEditorModeling.ModelProtoGroupOperation.Move)
					{
						//element.Name = "Copy of " + element.Name;
					}
					
					// update id mapping
					groupMerger.SetIdMapping(protoElement.ElementId, newElementId);
					
					// add child element
					GetRoleCollection<DslModeling::LinkedElementCollection<global::Tum.PDE.LanguageDSL.DomainType>, global::Tum.PDE.LanguageDSL.DomainType>(global::Tum.PDE.LanguageDSL.MetaModelHasDomainTypes.MetaModelDomainRoleId).Add(element);
		
					// continue with child elements (Embedding Relationship)
					System.Collections.Generic.List<DslEditorModeling::ModelProtoElement> embeddedProtoElements = groupMerger.GetEmbeddedElements(this.Store.DefaultPartition, protoElement);
					if( embeddedProtoElements.Count > 0 )
					{
						foreach (DslEditorModeling::ModelProtoElement p in embeddedProtoElements)
							(element as DslEditorModeling::IModelMergeElements).ModelMerge(p, groupMerger, false);
					}
				}
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.Validation.DomainClassId)) 
				{
					// get element id
					System.Guid newElementId = System.Guid.NewGuid();
					
					// create property assignments
					DslModeling::PropertyAssignment[] propertyAssignemnts = protoElement.GetPropertyAssignments(this.Store.DefaultPartition, newElementId);
					
		            // create the actual model element
					global::Tum.PDE.LanguageDSL.Validation element = null;			
					if( global::Tum.PDE.LanguageDSL.Validation.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.Validation(this.Store, propertyAssignemnts);
					if( element == null )
						throw new System.ArgumentNullException("Element is null in ModelMerge: " + elementDomainInfo.Name);
					
					if( !element.ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
					{
						// add warning message
						groupMerger.MergeResult.AddMessage(new DslEditorModeling.ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to MetaModel because paste is not allowed."));
						
						element.Delete();
						return;
		 			}
					
					if( isRoot && groupMerger.ProtoGroup.Operation != DslEditorModeling.ModelProtoGroupOperation.Move)
					{
						//element.Name = "Copy of " + element.Name;
					}
					
					// update id mapping
					groupMerger.SetIdMapping(protoElement.ElementId, newElementId);
					
					// add child element
					DslModeling::DomainRoleInfo.SetLinkedElement(this, global::Tum.PDE.LanguageDSL.MetaModelHasValidation.MetaModelDomainRoleId, element);
		
					// continue with child elements (Embedding Relationship)
					System.Collections.Generic.List<DslEditorModeling::ModelProtoElement> embeddedProtoElements = groupMerger.GetEmbeddedElements(this.Store.DefaultPartition, protoElement);
					if( embeddedProtoElements.Count > 0 )
					{
						foreach (DslEditorModeling::ModelProtoElement p in embeddedProtoElements)
							(element as DslEditorModeling::IModelMergeElements).ModelMerge(p, groupMerger, false);
					}
				}
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.AdditionalInformation.DomainClassId)) 
				{
					// get element id
					System.Guid newElementId = System.Guid.NewGuid();
					
					// create property assignments
					DslModeling::PropertyAssignment[] propertyAssignemnts = protoElement.GetPropertyAssignments(this.Store.DefaultPartition, newElementId);
					
		            // create the actual model element
					global::Tum.PDE.LanguageDSL.AdditionalInformation element = null;			
					if( global::Tum.PDE.LanguageDSL.AdditionalInformation.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.AdditionalInformation(this.Store, propertyAssignemnts);
					if( element == null )
						throw new System.ArgumentNullException("Element is null in ModelMerge: " + elementDomainInfo.Name);
					
					if( !element.ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
					{
						// add warning message
						groupMerger.MergeResult.AddMessage(new DslEditorModeling.ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to MetaModel because paste is not allowed."));
						
						element.Delete();
						return;
		 			}
					
					if( isRoot && groupMerger.ProtoGroup.Operation != DslEditorModeling.ModelProtoGroupOperation.Move)
					{
						//element.Name = "Copy of " + element.Name;
					}
					
					// update id mapping
					groupMerger.SetIdMapping(protoElement.ElementId, newElementId);
					
					// add child element
					DslModeling::DomainRoleInfo.SetLinkedElement(this, global::Tum.PDE.LanguageDSL.MetaModelHasAdditionalInformation.MetaModelDomainRoleId, element);
		
					// continue with child elements (Embedding Relationship)
					System.Collections.Generic.List<DslEditorModeling::ModelProtoElement> embeddedProtoElements = groupMerger.GetEmbeddedElements(this.Store.DefaultPartition, protoElement);
					if( embeddedProtoElements.Count > 0 )
					{
						foreach (DslEditorModeling::ModelProtoElement p in embeddedProtoElements)
							(element as DslEditorModeling::IModelMergeElements).ModelMerge(p, groupMerger, false);
					}
				}
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.MetaModelLibrary.DomainClassId)) 
				{
					// get element id
					System.Guid newElementId = System.Guid.NewGuid();
					
					// create property assignments
					DslModeling::PropertyAssignment[] propertyAssignemnts = protoElement.GetPropertyAssignments(this.Store.DefaultPartition, newElementId);
					
		            // create the actual model element
					global::Tum.PDE.LanguageDSL.MetaModelLibrary element = null;			
					if( global::Tum.PDE.LanguageDSL.MetaModelLibrary.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.MetaModelLibrary(this.Store, propertyAssignemnts);
					if( element == null )
						throw new System.ArgumentNullException("Element is null in ModelMerge: " + elementDomainInfo.Name);
					
					if( !element.ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
					{
						// add warning message
						groupMerger.MergeResult.AddMessage(new DslEditorModeling.ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to MetaModel because paste is not allowed."));
						
						element.Delete();
						return;
		 			}
					
					if( isRoot && groupMerger.ProtoGroup.Operation != DslEditorModeling.ModelProtoGroupOperation.Move)
					{
						//element.Name = "Copy of " + element.Name;
					}
					
					// update id mapping
					groupMerger.SetIdMapping(protoElement.ElementId, newElementId);
					
					// add child element
					GetRoleCollection<DslModeling::LinkedElementCollection<global::Tum.PDE.LanguageDSL.MetaModelLibrary>, global::Tum.PDE.LanguageDSL.MetaModelLibrary>(global::Tum.PDE.LanguageDSL.MetaModelHasMetaModelLibraries.MetaModelDomainRoleId).Add(element);
		
					// continue with child elements (Embedding Relationship)
					System.Collections.Generic.List<DslEditorModeling::ModelProtoElement> embeddedProtoElements = groupMerger.GetEmbeddedElements(this.Store.DefaultPartition, protoElement);
					if( embeddedProtoElements.Count > 0 )
					{
						foreach (DslEditorModeling::ModelProtoElement p in embeddedProtoElements)
							(element as DslEditorModeling::IModelMergeElements).ModelMerge(p, groupMerger, false);
					}
				}
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.View.DomainClassId)) 
				{
					// get element id
					System.Guid newElementId = System.Guid.NewGuid();
					
					// create property assignments
					DslModeling::PropertyAssignment[] propertyAssignemnts = protoElement.GetPropertyAssignments(this.Store.DefaultPartition, newElementId);
					
		            // create the actual model element
					global::Tum.PDE.LanguageDSL.View element = null;			
					if( global::Tum.PDE.LanguageDSL.View.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.View(this.Store, propertyAssignemnts);
					if( element == null )
						throw new System.ArgumentNullException("Element is null in ModelMerge: " + elementDomainInfo.Name);
					
					if( !element.ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
					{
						// add warning message
						groupMerger.MergeResult.AddMessage(new DslEditorModeling.ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to MetaModel because paste is not allowed."));
						
						element.Delete();
						return;
		 			}
					
					if( isRoot && groupMerger.ProtoGroup.Operation != DslEditorModeling.ModelProtoGroupOperation.Move)
					{
						//element.Name = "Copy of " + element.Name;
					}
					
					// update id mapping
					groupMerger.SetIdMapping(protoElement.ElementId, newElementId);
					
					// add child element
					DslModeling::DomainRoleInfo.SetLinkedElement(this, global::Tum.PDE.LanguageDSL.MetaModelHasView.MetaModelDomainRoleId, element);
		
					// continue with child elements (Embedding Relationship)
					System.Collections.Generic.List<DslEditorModeling::ModelProtoElement> embeddedProtoElements = groupMerger.GetEmbeddedElements(this.Store.DefaultPartition, protoElement);
					if( embeddedProtoElements.Count > 0 )
					{
						foreach (DslEditorModeling::ModelProtoElement p in embeddedProtoElements)
							(element as DslEditorModeling::IModelMergeElements).ModelMerge(p, groupMerger, false);
					}
				}
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.BaseModelContext.DomainClassId)) 
				{
					// get element id
					System.Guid newElementId = System.Guid.NewGuid();
					
					// create property assignments
					DslModeling::PropertyAssignment[] propertyAssignemnts = protoElement.GetPropertyAssignments(this.Store.DefaultPartition, newElementId);
					
		            // create the actual model element
					global::Tum.PDE.LanguageDSL.BaseModelContext element = null;			
					if( global::Tum.PDE.LanguageDSL.LibraryModelContext.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.LibraryModelContext(this.Store, propertyAssignemnts);
					if( global::Tum.PDE.LanguageDSL.ModelContext.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.ModelContext(this.Store, propertyAssignemnts);
					if( global::Tum.PDE.LanguageDSL.ExternModelContext.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.ExternModelContext(this.Store, propertyAssignemnts);
					if( element == null )
						throw new System.ArgumentNullException("Element is null in ModelMerge: " + elementDomainInfo.Name);
					
					if( !element.ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
					{
						// add warning message
						groupMerger.MergeResult.AddMessage(new DslEditorModeling.ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to MetaModel because paste is not allowed."));
						
						element.Delete();
						return;
		 			}
					
					if( isRoot && groupMerger.ProtoGroup.Operation != DslEditorModeling.ModelProtoGroupOperation.Move)
					{
						//element.Name = "Copy of " + element.Name;
					}
					
					// update id mapping
					groupMerger.SetIdMapping(protoElement.ElementId, newElementId);
					
					// add child element
					GetRoleCollection<DslModeling::LinkedElementCollection<global::Tum.PDE.LanguageDSL.BaseModelContext>, global::Tum.PDE.LanguageDSL.BaseModelContext>(global::Tum.PDE.LanguageDSL.MetaModelHasModelContexts.MetaModelDomainRoleId).Add(element);
		
					// continue with child elements (Embedding Relationship)
					System.Collections.Generic.List<DslEditorModeling::ModelProtoElement> embeddedProtoElements = groupMerger.GetEmbeddedElements(this.Store.DefaultPartition, protoElement);
					if( embeddedProtoElements.Count > 0 )
					{
						foreach (DslEditorModeling::ModelProtoElement p in embeddedProtoElements)
							(element as DslEditorModeling::IModelMergeElements).ModelMerge(p, groupMerger, false);
					}
				}
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.PropertyGridEditor.DomainClassId)) 
				{
					// get element id
					System.Guid newElementId = System.Guid.NewGuid();
					
					// create property assignments
					DslModeling::PropertyAssignment[] propertyAssignemnts = protoElement.GetPropertyAssignments(this.Store.DefaultPartition, newElementId);
					
		            // create the actual model element
					global::Tum.PDE.LanguageDSL.PropertyGridEditor element = null;			
					if( global::Tum.PDE.LanguageDSL.PropertyGridEditor.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.PropertyGridEditor(this.Store, propertyAssignemnts);
					if( element == null )
						throw new System.ArgumentNullException("Element is null in ModelMerge: " + elementDomainInfo.Name);
					
					if( !element.ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
					{
						// add warning message
						groupMerger.MergeResult.AddMessage(new DslEditorModeling.ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to MetaModel because paste is not allowed."));
						
						element.Delete();
						return;
		 			}
					
					if( isRoot && groupMerger.ProtoGroup.Operation != DslEditorModeling.ModelProtoGroupOperation.Move)
					{
						//element.Name = "Copy of " + element.Name;
					}
					
					// update id mapping
					groupMerger.SetIdMapping(protoElement.ElementId, newElementId);
					
					// add child element
					GetRoleCollection<DslModeling::LinkedElementCollection<global::Tum.PDE.LanguageDSL.PropertyGridEditor>, global::Tum.PDE.LanguageDSL.PropertyGridEditor>(global::Tum.PDE.LanguageDSL.MetaModelHasPropertyGridEditors.MetaModelDomainRoleId).Add(element);
		
					// continue with child elements (Embedding Relationship)
					System.Collections.Generic.List<DslEditorModeling::ModelProtoElement> embeddedProtoElements = groupMerger.GetEmbeddedElements(this.Store.DefaultPartition, protoElement);
					if( embeddedProtoElements.Count > 0 )
					{
						foreach (DslEditorModeling::ModelProtoElement p in embeddedProtoElements)
							(element as DslEditorModeling::IModelMergeElements).ModelMerge(p, groupMerger, false);
					}
				}
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to MetaModel because move is not allowed."));
				return;
			}
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.DomainType.DomainClassId)) 
				{
		            DslModeling::ModelElement modelElement = this.Store.ElementDirectory.FindElement(protoElement.ElementId);
		            if( modelElement == null )
		            {
		                groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementMissingOnMoveId",
				             DslEditorModeling.ModelValidationViolationType.Error, "Element exists although the operation = Move."));
		                return;
					}
		
					// change parent
					DslModeling::DomainRoleInfo.SetLinkedElement(modelElement, global::Tum.PDE.LanguageDSL.MetaModelHasDomainTypes.DomainTypeDomainRoleId, this);
					return;
				}
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.Validation.DomainClassId)) 
				{
		            DslModeling::ModelElement modelElement = this.Store.ElementDirectory.FindElement(protoElement.ElementId);
		            if( modelElement == null )
		            {
		                groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementMissingOnMoveId",
				             DslEditorModeling.ModelValidationViolationType.Error, "Element exists although the operation = Move."));
		                return;
					}
		
					// change parent
					DslModeling::DomainRoleInfo.SetLinkedElement(modelElement, global::Tum.PDE.LanguageDSL.MetaModelHasValidation.ValidationDomainRoleId, this);
					return;
				}
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.AdditionalInformation.DomainClassId)) 
				{
		            DslModeling::ModelElement modelElement = this.Store.ElementDirectory.FindElement(protoElement.ElementId);
		            if( modelElement == null )
		            {
		                groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementMissingOnMoveId",
				             DslEditorModeling.ModelValidationViolationType.Error, "Element exists although the operation = Move."));
		                return;
					}
		
					// change parent
					DslModeling::DomainRoleInfo.SetLinkedElement(modelElement, global::Tum.PDE.LanguageDSL.MetaModelHasAdditionalInformation.AdditionalInformationDomainRoleId, this);
					return;
				}
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.MetaModelLibrary.DomainClassId)) 
				{
		            DslModeling::ModelElement modelElement = this.Store.ElementDirectory.FindElement(protoElement.ElementId);
		            if( modelElement == null )
		            {
		                groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementMissingOnMoveId",
				             DslEditorModeling.ModelValidationViolationType.Error, "Element exists although the operation = Move."));
		                return;
					}
		
					// change parent
					DslModeling::DomainRoleInfo.SetLinkedElement(modelElement, global::Tum.PDE.LanguageDSL.MetaModelHasMetaModelLibraries.MetaModelLibraryDomainRoleId, this);
					return;
				}
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.View.DomainClassId)) 
				{
		            DslModeling::ModelElement modelElement = this.Store.ElementDirectory.FindElement(protoElement.ElementId);
		            if( modelElement == null )
		            {
		                groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementMissingOnMoveId",
				             DslEditorModeling.ModelValidationViolationType.Error, "Element exists although the operation = Move."));
		                return;
					}
		
					// change parent
					DslModeling::DomainRoleInfo.SetLinkedElement(modelElement, global::Tum.PDE.LanguageDSL.MetaModelHasView.ViewDomainRoleId, this);
					return;
				}
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.BaseModelContext.DomainClassId)) 
				{
		            DslModeling::ModelElement modelElement = this.Store.ElementDirectory.FindElement(protoElement.ElementId);
		            if( modelElement == null )
		            {
		                groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementMissingOnMoveId",
				             DslEditorModeling.ModelValidationViolationType.Error, "Element exists although the operation = Move."));
		                return;
					}
		
					// change parent
					DslModeling::DomainRoleInfo.SetLinkedElement(modelElement, global::Tum.PDE.LanguageDSL.MetaModelHasModelContexts.BaseModelContextDomainRoleId, this);
					return;
				}
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.PropertyGridEditor.DomainClassId)) 
				{
		            DslModeling::ModelElement modelElement = this.Store.ElementDirectory.FindElement(protoElement.ElementId);
		            if( modelElement == null )
		            {
		                groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementMissingOnMoveId",
				             DslEditorModeling.ModelValidationViolationType.Error, "Element exists although the operation = Move."));
		                return;
					}
		
					// change parent
					DslModeling::DomainRoleInfo.SetLinkedElement(modelElement, global::Tum.PDE.LanguageDSL.MetaModelHasPropertyGridEditors.PropertyGridEditorDomainRoleId, this);
					return;
				}
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class DomainElement : Tum.PDE.LanguageDSL.CopyPaste.IModelMergeElements
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public virtual bool ModelIsCopyAllowed()
		{
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public virtual bool ModelIsMoveAllowed()
		{
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public virtual bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public virtual DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public virtual DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public virtual void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public virtual bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return false;
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public virtual void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to DomainElement because paste is not allowed."));
				return;
			}
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to DomainElement because move is not allowed."));
				return;
			}
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class NamedDomainElement : DomainElement
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to NamedDomainElement because paste is not allowed."));
				return;
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to NamedDomainElement because move is not allowed."));
				return;
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class AttributedDomainElement : GeneratedDomainElement
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
			// AttributedDomainElementHasProperties
			foreach (global::Tum.PDE.LanguageDSL.AttributedDomainElementHasProperties link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.AttributedDomainElementHasProperties>(this, global::Tum.PDE.LanguageDSL.AttributedDomainElementHasProperties.DomainElementDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewEmbeddingLink(protoLink);
				
				DslEditorModeling::ModelProtoElement protoElementRS = new DslEditorModeling::ModelProtoElement(link.DomainProperty);
				protoGroup.AddNewElement(protoElementRS);
				
				// continue with target element
				if( link.DomainProperty is DslEditorModeling::IModelMergeElements )
				{
					(link.DomainProperty as DslEditorModeling::IModelMergeElements).ModelCreateMergeCopy(protoGroup);
				}
			}
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.DomainProperty.DomainClassId)) 
				{
					if( protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
					{
						foreach (global::Tum.PDE.LanguageDSL.AttributedDomainElementHasProperties link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.AttributedDomainElementHasProperties>(this, global::Tum.PDE.LanguageDSL.AttributedDomainElementHasProperties.DomainElementDomainRoleId))				
							if( link.DomainProperty.Id == protoElement.ElementId )
								return false;
					}
					return true;
				}
			}
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to AttributedDomainElement because paste is not allowed."));
				return;
			}
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.DomainProperty.DomainClassId)) 
				{
					// get element id
					System.Guid newElementId = System.Guid.NewGuid();
					
					// create property assignments
					DslModeling::PropertyAssignment[] propertyAssignemnts = protoElement.GetPropertyAssignments(this.Store.DefaultPartition, newElementId);
					
		            // create the actual model element
					global::Tum.PDE.LanguageDSL.DomainProperty element = null;			
					if( global::Tum.PDE.LanguageDSL.DomainProperty.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.DomainProperty(this.Store, propertyAssignemnts);
					if( element == null )
						throw new System.ArgumentNullException("Element is null in ModelMerge: " + elementDomainInfo.Name);
					
					if( !element.ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
					{
						// add warning message
						groupMerger.MergeResult.AddMessage(new DslEditorModeling.ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to AttributedDomainElement because paste is not allowed."));
						
						element.Delete();
						return;
		 			}
					
					if( isRoot && groupMerger.ProtoGroup.Operation != DslEditorModeling.ModelProtoGroupOperation.Move)
					{
						//element.Name = "Copy of " + element.Name;
					}
					
					// update id mapping
					groupMerger.SetIdMapping(protoElement.ElementId, newElementId);
					
					// add child element
					GetRoleCollection<DslModeling::LinkedElementCollection<global::Tum.PDE.LanguageDSL.DomainProperty>, global::Tum.PDE.LanguageDSL.DomainProperty>(global::Tum.PDE.LanguageDSL.AttributedDomainElementHasProperties.DomainElementDomainRoleId).Add(element);
		
					// continue with child elements (Embedding Relationship)
					System.Collections.Generic.List<DslEditorModeling::ModelProtoElement> embeddedProtoElements = groupMerger.GetEmbeddedElements(this.Store.DefaultPartition, protoElement);
					if( embeddedProtoElements.Count > 0 )
					{
						foreach (DslEditorModeling::ModelProtoElement p in embeddedProtoElements)
							(element as DslEditorModeling::IModelMergeElements).ModelMerge(p, groupMerger, false);
					}
				}
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			DslModeling::DomainRelationshipInfo linkDomainInfo = null;
			if (protoLink != null)
			{
				linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(protoLink.DomainClassId);
			}
			else
			{
				// try getting the linkDomainInfo from name
			}
			
			if( linkDomainInfo == null )
			{
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkDomainTypeMissing",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link can not be created as the corresponding domain type is missing."));
				return;
			}
		
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to AttributedDomainElement because move is not allowed."));
				return;
			}
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.DomainProperty.DomainClassId)) 
				{
		            DslModeling::ModelElement modelElement = this.Store.ElementDirectory.FindElement(protoElement.ElementId);
		            if( modelElement == null )
		            {
		                groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementMissingOnMoveId",
				             DslEditorModeling.ModelValidationViolationType.Error, "Element exists although the operation = Move."));
		                return;
					}
		
					// change parent
					DslModeling::DomainRoleInfo.SetLinkedElement(modelElement, global::Tum.PDE.LanguageDSL.AttributedDomainElementHasProperties.DomainPropertyDomainRoleId, this);
					return;
				}
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class DomainProperty : DomainElement
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
			// DomainPropertyReferencesType
			foreach (global::Tum.PDE.LanguageDSL.DomainPropertyReferencesType link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.DomainPropertyReferencesType>(this, global::Tum.PDE.LanguageDSL.DomainPropertyReferencesType.DomainPropertyDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewReferenceLink(protoLink);
			}
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to DomainProperty because paste is not allowed."));
				return;
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			DslModeling::DomainRelationshipInfo linkDomainInfo = null;
			if (protoLink != null)
			{
				linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(protoLink.DomainClassId);
			}
			else
			{
				// try getting the linkDomainInfo from name
				if( protoLink.Name == "DomainPropertyReferencesType" && linkDomainInfo == null)
				{
					linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(DomainPropertyReferencesType.DomainClassId);
				}
			}
			
			if( linkDomainInfo == null )
			{
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkDomainTypeMissing",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link can not be created as the corresponding domain type is missing."));
				return;
			}
		
				if (linkDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.DomainPropertyReferencesType.DomainClassId)) 
				{
					// see if this element is taking part in this role
					bool bTakesPart = false;
					
					DslEditorModeling::ModelProtoRolePlayer sourceRolePlayer = protoLink.GetSourceRolePlayer(this.Store.DefaultPartition);
					DslEditorModeling::ModelProtoElement sourceProtoElement = groupMerger.GetElementById(sourceRolePlayer.RolePlayerId);
					System.Guid mappedSourceIdTP = System.Guid.Empty;
					if( sourceProtoElement != null )
					{
						mappedSourceIdTP = groupMerger.GetIdMapping(sourceRolePlayer.RolePlayerId);
						if( mappedSourceIdTP == this.Id )
							bTakesPart = true;
					}
		
					if( bTakesPart )
					{		
						bool bExists = true;
		        	    if( this.Store.ElementDirectory.FindElement(protoLink.ElementId) == null )
		        	        bExists = false;
							
						if( bExists && groupMerger.ProtoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
		        	    {
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkExistsOnMoveId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link exists although the operation = Move."));
						}
						
						#region Target
						// see if target element was copied
						DslEditorModeling::ModelProtoRolePlayer targetRolePlayer = protoLink.GetTargetRolePlayer(this.Store.DefaultPartition);
						DslEditorModeling::ModelProtoElement targetProtoElement = groupMerger.GetElementById(targetRolePlayer.RolePlayerId);
						System.Guid mappedTargetId = System.Guid.Empty;
						if( targetProtoElement != null )
						{
						 	mappedTargetId= groupMerger.GetIdMapping(targetRolePlayer.RolePlayerId);
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element
							mappedTargetId = targetRolePlayer.RolePlayerId;
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element with the same name as the previous element
							// TODO
						}
		
						if( mappedTargetId == System.Guid.Empty )
						{
							// log warning
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotCopiedId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not copied. Relationship: DomainPropertyReferencesType"));
						}
						else
						{
							DslModeling::ModelElement targetElement = this.Store.ElementDirectory.FindElement(mappedTargetId);
							if( targetElement == null )
							{
								// log error
		        	        	groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotFoundId",
					            	DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not found. Relationship: DomainPropertyReferencesType"));
							}
							else
							{
								bool bContinue = true;
		
								// check cardinalities, so we don't violate them by additing a new relationship
								if( DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Tum.PDE.LanguageDSL.DomainPropertyReferencesType.DomainPropertyDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: DomainPropertyReferencesType"));
									
									bContinue = false;
								}
								
								if( bContinue )
								{
									// create property assignments
									DslModeling::PropertyAssignment[] propertyAssignemnts = protoLink.GetPropertyAssignments(this.Store.DefaultPartition, 
										System.Guid.NewGuid());
								
									// create role assignments
									DslModeling.RoleAssignment[] roleAssignments = new DslModeling.RoleAssignment[2];
		                	        roleAssignments[0] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.DomainPropertyReferencesType.DomainPropertyDomainRoleId, this);
									roleAssignments[1] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.DomainPropertyReferencesType.DomainTypeDomainRoleId, targetElement);
									
									// create new relationship
									new global::Tum.PDE.LanguageDSL.DomainPropertyReferencesType(this.Store, roleAssignments, propertyAssignemnts);
								}
							}
						}
						#endregion
					}
				}
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to DomainProperty because move is not allowed."));
				return;
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class DomainRelationshipBase : AttributedDomainElement
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
			// DomainRelationshipHasRoles
			foreach (global::Tum.PDE.LanguageDSL.DomainRelationshipHasRoles link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.DomainRelationshipHasRoles>(this, global::Tum.PDE.LanguageDSL.DomainRelationshipHasRoles.RelationshipDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewEmbeddingLink(protoLink);
				
				DslEditorModeling::ModelProtoElement protoElementRS = new DslEditorModeling::ModelProtoElement(link.Role);
				protoGroup.AddNewElement(protoElementRS);
				
				// continue with target element
				if( link.Role is DslEditorModeling::IModelMergeElements )
				{
					(link.Role as DslEditorModeling::IModelMergeElements).ModelCreateMergeCopy(protoGroup);
				}
			}
			// DomainRelationshipReferencesSource
			foreach (global::Tum.PDE.LanguageDSL.DomainRelationshipReferencesSource link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.DomainRelationshipReferencesSource>(this, global::Tum.PDE.LanguageDSL.DomainRelationshipReferencesSource.RelationshipDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewReferenceLink(protoLink);
			}
			// DomainRelationshipReferencesTarget
			foreach (global::Tum.PDE.LanguageDSL.DomainRelationshipReferencesTarget link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.DomainRelationshipReferencesTarget>(this, global::Tum.PDE.LanguageDSL.DomainRelationshipReferencesTarget.RelationshipDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewReferenceLink(protoLink);
			}
			// DomainRelationshipReferencesBaseRelationship
			foreach (global::Tum.PDE.LanguageDSL.DomainRelationshipReferencesBaseRelationship link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.DomainRelationshipReferencesBaseRelationship>(this, global::Tum.PDE.LanguageDSL.DomainRelationshipReferencesBaseRelationship.DerivedRelationshipDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewReferenceLink(protoLink);
			}
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.DomainRole.DomainClassId)) 
				{
					if( protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
					{
						foreach (global::Tum.PDE.LanguageDSL.DomainRelationshipHasRoles link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.DomainRelationshipHasRoles>(this, global::Tum.PDE.LanguageDSL.DomainRelationshipHasRoles.RelationshipDomainRoleId))				
							if( link.Role.Id == protoElement.ElementId )
								return false;
					}
					return true;
				}
			}
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to DomainRelationship because paste is not allowed."));
				return;
			}
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.DomainRole.DomainClassId)) 
				{
					// get element id
					System.Guid newElementId = System.Guid.NewGuid();
					
					// create property assignments
					DslModeling::PropertyAssignment[] propertyAssignemnts = protoElement.GetPropertyAssignments(this.Store.DefaultPartition, newElementId);
					
		            // create the actual model element
					global::Tum.PDE.LanguageDSL.DomainRole element = null;			
					if( global::Tum.PDE.LanguageDSL.DomainRole.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.DomainRole(this.Store, propertyAssignemnts);
					if( element == null )
						throw new System.ArgumentNullException("Element is null in ModelMerge: " + elementDomainInfo.Name);
					
					if( !element.ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
					{
						// add warning message
						groupMerger.MergeResult.AddMessage(new DslEditorModeling.ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to DomainRelationship because paste is not allowed."));
						
						element.Delete();
						return;
		 			}
					
					if( isRoot && groupMerger.ProtoGroup.Operation != DslEditorModeling.ModelProtoGroupOperation.Move)
					{
						//element.Name = "Copy of " + element.Name;
					}
					
					// update id mapping
					groupMerger.SetIdMapping(protoElement.ElementId, newElementId);
					
					// add child element
					GetRoleCollection<DslModeling::LinkedElementCollection<global::Tum.PDE.LanguageDSL.DomainRole>, global::Tum.PDE.LanguageDSL.DomainRole>(global::Tum.PDE.LanguageDSL.DomainRelationshipHasRoles.RelationshipDomainRoleId).Add(element);
		
					// continue with child elements (Embedding Relationship)
					System.Collections.Generic.List<DslEditorModeling::ModelProtoElement> embeddedProtoElements = groupMerger.GetEmbeddedElements(this.Store.DefaultPartition, protoElement);
					if( embeddedProtoElements.Count > 0 )
					{
						foreach (DslEditorModeling::ModelProtoElement p in embeddedProtoElements)
							(element as DslEditorModeling::IModelMergeElements).ModelMerge(p, groupMerger, false);
					}
				}
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			DslModeling::DomainRelationshipInfo linkDomainInfo = null;
			if (protoLink != null)
			{
				linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(protoLink.DomainClassId);
			}
			else
			{
				// try getting the linkDomainInfo from name
				if( protoLink.Name == "DomainRelationshipReferencesSource" && linkDomainInfo == null)
				{
					linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(DomainRelationshipReferencesSource.DomainClassId);
				}
				if( protoLink.Name == "DomainRelationshipReferencesTarget" && linkDomainInfo == null)
				{
					linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(DomainRelationshipReferencesTarget.DomainClassId);
				}
				if( protoLink.Name == "DomainRelationshipReferencesBaseRelationship" && linkDomainInfo == null)
				{
					linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(DomainRelationshipReferencesBaseRelationship.DomainClassId);
				}
			}
			
			if( linkDomainInfo == null )
			{
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkDomainTypeMissing",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link can not be created as the corresponding domain type is missing."));
				return;
			}
		
				if (linkDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.DomainRelationshipReferencesSource.DomainClassId)) 
				{
					// see if this element is taking part in this role
					bool bTakesPart = false;
					
					DslEditorModeling::ModelProtoRolePlayer sourceRolePlayer = protoLink.GetSourceRolePlayer(this.Store.DefaultPartition);
					DslEditorModeling::ModelProtoElement sourceProtoElement = groupMerger.GetElementById(sourceRolePlayer.RolePlayerId);
					System.Guid mappedSourceIdTP = System.Guid.Empty;
					if( sourceProtoElement != null )
					{
						mappedSourceIdTP = groupMerger.GetIdMapping(sourceRolePlayer.RolePlayerId);
						if( mappedSourceIdTP == this.Id )
							bTakesPart = true;
					}
		
					if( bTakesPart )
					{		
						bool bExists = true;
		        	    if( this.Store.ElementDirectory.FindElement(protoLink.ElementId) == null )
		        	        bExists = false;
							
						if( bExists && groupMerger.ProtoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
		        	    {
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkExistsOnMoveId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link exists although the operation = Move."));
						}
						
						#region Target
						// see if target element was copied
						DslEditorModeling::ModelProtoRolePlayer targetRolePlayer = protoLink.GetTargetRolePlayer(this.Store.DefaultPartition);
						DslEditorModeling::ModelProtoElement targetProtoElement = groupMerger.GetElementById(targetRolePlayer.RolePlayerId);
						System.Guid mappedTargetId = System.Guid.Empty;
						if( targetProtoElement != null )
						{
						 	mappedTargetId= groupMerger.GetIdMapping(targetRolePlayer.RolePlayerId);
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element
							mappedTargetId = targetRolePlayer.RolePlayerId;
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element with the same name as the previous element
							// TODO
						}
		
						if( mappedTargetId == System.Guid.Empty )
						{
							// log warning
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotCopiedId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not copied. Relationship: DomainRelationshipReferencesSource"));
						}
						else
						{
							DslModeling::ModelElement targetElement = this.Store.ElementDirectory.FindElement(mappedTargetId);
							if( targetElement == null )
							{
								// log error
		        	        	groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotFoundId",
					            	DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not found. Relationship: DomainRelationshipReferencesSource"));
							}
							else
							{
								bool bContinue = true;
		
								// check cardinalities, so we don't violate them by additing a new relationship
								if( DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Tum.PDE.LanguageDSL.DomainRelationshipReferencesSource.RelationshipDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: DomainRelationshipReferencesSource"));
									
									bContinue = false;
								}
								if( DslModeling::DomainRoleInfo.GetLinkedElement(targetElement, global::Tum.PDE.LanguageDSL.DomainRelationshipReferencesSource.RoleDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: DomainRelationshipReferencesSource"));
									
									bContinue = false;
								}
								
								if( bContinue )
								{
									// create property assignments
									DslModeling::PropertyAssignment[] propertyAssignemnts = protoLink.GetPropertyAssignments(this.Store.DefaultPartition, 
										System.Guid.NewGuid());
								
									// create role assignments
									DslModeling.RoleAssignment[] roleAssignments = new DslModeling.RoleAssignment[2];
		                	        roleAssignments[0] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.DomainRelationshipReferencesSource.RelationshipDomainRoleId, this);
									roleAssignments[1] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.DomainRelationshipReferencesSource.RoleDomainRoleId, targetElement);
									
									// create new relationship
									new global::Tum.PDE.LanguageDSL.DomainRelationshipReferencesSource(this.Store, roleAssignments, propertyAssignemnts);
								}
							}
						}
						#endregion
					}
				}
				if (linkDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.DomainRelationshipReferencesTarget.DomainClassId)) 
				{
					// see if this element is taking part in this role
					bool bTakesPart = false;
					
					DslEditorModeling::ModelProtoRolePlayer sourceRolePlayer = protoLink.GetSourceRolePlayer(this.Store.DefaultPartition);
					DslEditorModeling::ModelProtoElement sourceProtoElement = groupMerger.GetElementById(sourceRolePlayer.RolePlayerId);
					System.Guid mappedSourceIdTP = System.Guid.Empty;
					if( sourceProtoElement != null )
					{
						mappedSourceIdTP = groupMerger.GetIdMapping(sourceRolePlayer.RolePlayerId);
						if( mappedSourceIdTP == this.Id )
							bTakesPart = true;
					}
		
					if( bTakesPart )
					{		
						bool bExists = true;
		        	    if( this.Store.ElementDirectory.FindElement(protoLink.ElementId) == null )
		        	        bExists = false;
							
						if( bExists && groupMerger.ProtoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
		        	    {
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkExistsOnMoveId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link exists although the operation = Move."));
						}
						
						#region Target
						// see if target element was copied
						DslEditorModeling::ModelProtoRolePlayer targetRolePlayer = protoLink.GetTargetRolePlayer(this.Store.DefaultPartition);
						DslEditorModeling::ModelProtoElement targetProtoElement = groupMerger.GetElementById(targetRolePlayer.RolePlayerId);
						System.Guid mappedTargetId = System.Guid.Empty;
						if( targetProtoElement != null )
						{
						 	mappedTargetId= groupMerger.GetIdMapping(targetRolePlayer.RolePlayerId);
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element
							mappedTargetId = targetRolePlayer.RolePlayerId;
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element with the same name as the previous element
							// TODO
						}
		
						if( mappedTargetId == System.Guid.Empty )
						{
							// log warning
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotCopiedId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not copied. Relationship: DomainRelationshipReferencesTarget"));
						}
						else
						{
							DslModeling::ModelElement targetElement = this.Store.ElementDirectory.FindElement(mappedTargetId);
							if( targetElement == null )
							{
								// log error
		        	        	groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotFoundId",
					            	DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not found. Relationship: DomainRelationshipReferencesTarget"));
							}
							else
							{
								bool bContinue = true;
		
								// check cardinalities, so we don't violate them by additing a new relationship
								if( DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Tum.PDE.LanguageDSL.DomainRelationshipReferencesTarget.RelationshipDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: DomainRelationshipReferencesTarget"));
									
									bContinue = false;
								}
								if( DslModeling::DomainRoleInfo.GetLinkedElement(targetElement, global::Tum.PDE.LanguageDSL.DomainRelationshipReferencesTarget.RoleDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: DomainRelationshipReferencesTarget"));
									
									bContinue = false;
								}
								
								if( bContinue )
								{
									// create property assignments
									DslModeling::PropertyAssignment[] propertyAssignemnts = protoLink.GetPropertyAssignments(this.Store.DefaultPartition, 
										System.Guid.NewGuid());
								
									// create role assignments
									DslModeling.RoleAssignment[] roleAssignments = new DslModeling.RoleAssignment[2];
		                	        roleAssignments[0] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.DomainRelationshipReferencesTarget.RelationshipDomainRoleId, this);
									roleAssignments[1] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.DomainRelationshipReferencesTarget.RoleDomainRoleId, targetElement);
									
									// create new relationship
									new global::Tum.PDE.LanguageDSL.DomainRelationshipReferencesTarget(this.Store, roleAssignments, propertyAssignemnts);
								}
							}
						}
						#endregion
					}
				}
				if (linkDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.DomainRelationshipReferencesBaseRelationship.DomainClassId)) 
				{
					// see if this element is taking part in this role
					bool bTakesPart = false;
					
					DslEditorModeling::ModelProtoRolePlayer sourceRolePlayer = protoLink.GetSourceRolePlayer(this.Store.DefaultPartition);
					DslEditorModeling::ModelProtoElement sourceProtoElement = groupMerger.GetElementById(sourceRolePlayer.RolePlayerId);
					System.Guid mappedSourceIdTP = System.Guid.Empty;
					if( sourceProtoElement != null )
					{
						mappedSourceIdTP = groupMerger.GetIdMapping(sourceRolePlayer.RolePlayerId);
						if( mappedSourceIdTP == this.Id )
							bTakesPart = true;
					}
		
					if( bTakesPart )
					{		
						bool bExists = true;
		        	    if( this.Store.ElementDirectory.FindElement(protoLink.ElementId) == null )
		        	        bExists = false;
							
						if( bExists && groupMerger.ProtoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
		        	    {
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkExistsOnMoveId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link exists although the operation = Move."));
						}
						
						#region Target
						// see if target element was copied
						DslEditorModeling::ModelProtoRolePlayer targetRolePlayer = protoLink.GetTargetRolePlayer(this.Store.DefaultPartition);
						DslEditorModeling::ModelProtoElement targetProtoElement = groupMerger.GetElementById(targetRolePlayer.RolePlayerId);
						System.Guid mappedTargetId = System.Guid.Empty;
						if( targetProtoElement != null )
						{
						 	mappedTargetId= groupMerger.GetIdMapping(targetRolePlayer.RolePlayerId);
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element
							mappedTargetId = targetRolePlayer.RolePlayerId;
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element with the same name as the previous element
							// TODO
						}
		
						if( mappedTargetId == System.Guid.Empty )
						{
							// log warning
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotCopiedId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not copied. Relationship: DomainRelationshipReferencesBaseRelationship"));
						}
						else
						{
							DslModeling::ModelElement targetElement = this.Store.ElementDirectory.FindElement(mappedTargetId);
							if( targetElement == null )
							{
								// log error
		        	        	groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotFoundId",
					            	DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not found. Relationship: DomainRelationshipReferencesBaseRelationship"));
							}
							else
							{
								bool bContinue = true;
		
								// check cardinalities, so we don't violate them by additing a new relationship
								if( DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Tum.PDE.LanguageDSL.DomainRelationshipReferencesBaseRelationship.DerivedRelationshipDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: DomainRelationshipReferencesBaseRelationship"));
									
									bContinue = false;
								}
								
								if( bContinue )
								{
									// create property assignments
									DslModeling::PropertyAssignment[] propertyAssignemnts = protoLink.GetPropertyAssignments(this.Store.DefaultPartition, 
										System.Guid.NewGuid());
								
									// create role assignments
									DslModeling.RoleAssignment[] roleAssignments = new DslModeling.RoleAssignment[2];
		                	        roleAssignments[0] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.DomainRelationshipReferencesBaseRelationship.DerivedRelationshipDomainRoleId, this);
									roleAssignments[1] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.DomainRelationshipReferencesBaseRelationship.BaseRelationshipDomainRoleId, targetElement);
									
									// create new relationship
									new global::Tum.PDE.LanguageDSL.DomainRelationshipReferencesBaseRelationship(this.Store, roleAssignments, propertyAssignemnts);
								}
							}
						}
						#endregion
					}
				}
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to DomainRelationship because move is not allowed."));
				return;
			}
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.DomainRole.DomainClassId)) 
				{
		            DslModeling::ModelElement modelElement = this.Store.ElementDirectory.FindElement(protoElement.ElementId);
		            if( modelElement == null )
		            {
		                groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementMissingOnMoveId",
				             DslEditorModeling.ModelValidationViolationType.Error, "Element exists although the operation = Move."));
		                return;
					}
		
					// change parent
					DslModeling::DomainRoleInfo.SetLinkedElement(modelElement, global::Tum.PDE.LanguageDSL.DomainRelationshipHasRoles.RoleDomainRoleId, this);
					return;
				}
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class DomainClassBase : AttributedDomainElement
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
			// DomainClassReferencesBaseClass
			foreach (global::Tum.PDE.LanguageDSL.DomainClassReferencesBaseClass link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.DomainClassReferencesBaseClass>(this, global::Tum.PDE.LanguageDSL.DomainClassReferencesBaseClass.DerivedClassDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewReferenceLink(protoLink);
			}
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to DomainClass because paste is not allowed."));
				return;
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			DslModeling::DomainRelationshipInfo linkDomainInfo = null;
			if (protoLink != null)
			{
				linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(protoLink.DomainClassId);
			}
			else
			{
				// try getting the linkDomainInfo from name
				if( protoLink.Name == "DomainClassReferencesBaseClass" && linkDomainInfo == null)
				{
					linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(DomainClassReferencesBaseClass.DomainClassId);
				}
			}
			
			if( linkDomainInfo == null )
			{
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkDomainTypeMissing",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link can not be created as the corresponding domain type is missing."));
				return;
			}
		
				if (linkDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.DomainClassReferencesBaseClass.DomainClassId)) 
				{
					// see if this element is taking part in this role
					bool bTakesPart = false;
					
					DslEditorModeling::ModelProtoRolePlayer sourceRolePlayer = protoLink.GetSourceRolePlayer(this.Store.DefaultPartition);
					DslEditorModeling::ModelProtoElement sourceProtoElement = groupMerger.GetElementById(sourceRolePlayer.RolePlayerId);
					System.Guid mappedSourceIdTP = System.Guid.Empty;
					if( sourceProtoElement != null )
					{
						mappedSourceIdTP = groupMerger.GetIdMapping(sourceRolePlayer.RolePlayerId);
						if( mappedSourceIdTP == this.Id )
							bTakesPart = true;
					}
		
					if( bTakesPart )
					{		
						bool bExists = true;
		        	    if( this.Store.ElementDirectory.FindElement(protoLink.ElementId) == null )
		        	        bExists = false;
							
						if( bExists && groupMerger.ProtoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
		        	    {
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkExistsOnMoveId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link exists although the operation = Move."));
						}
						
						#region Target
						// see if target element was copied
						DslEditorModeling::ModelProtoRolePlayer targetRolePlayer = protoLink.GetTargetRolePlayer(this.Store.DefaultPartition);
						DslEditorModeling::ModelProtoElement targetProtoElement = groupMerger.GetElementById(targetRolePlayer.RolePlayerId);
						System.Guid mappedTargetId = System.Guid.Empty;
						if( targetProtoElement != null )
						{
						 	mappedTargetId= groupMerger.GetIdMapping(targetRolePlayer.RolePlayerId);
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element
							mappedTargetId = targetRolePlayer.RolePlayerId;
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element with the same name as the previous element
							// TODO
						}
		
						if( mappedTargetId == System.Guid.Empty )
						{
							// log warning
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotCopiedId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not copied. Relationship: DomainClassReferencesBaseClass"));
						}
						else
						{
							DslModeling::ModelElement targetElement = this.Store.ElementDirectory.FindElement(mappedTargetId);
							if( targetElement == null )
							{
								// log error
		        	        	groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotFoundId",
					            	DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not found. Relationship: DomainClassReferencesBaseClass"));
							}
							else
							{
								bool bContinue = true;
		
								// check cardinalities, so we don't violate them by additing a new relationship
								if( DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Tum.PDE.LanguageDSL.DomainClassReferencesBaseClass.DerivedClassDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: DomainClassReferencesBaseClass"));
									
									bContinue = false;
								}
								
								if( bContinue )
								{
									// create property assignments
									DslModeling::PropertyAssignment[] propertyAssignemnts = protoLink.GetPropertyAssignments(this.Store.DefaultPartition, 
										System.Guid.NewGuid());
								
									// create role assignments
									DslModeling.RoleAssignment[] roleAssignments = new DslModeling.RoleAssignment[2];
		                	        roleAssignments[0] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.DomainClassReferencesBaseClass.DerivedClassDomainRoleId, this);
									roleAssignments[1] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.DomainClassReferencesBaseClass.BaseClassDomainRoleId, targetElement);
									
									// create new relationship
									new global::Tum.PDE.LanguageDSL.DomainClassReferencesBaseClass(this.Store, roleAssignments, propertyAssignemnts);
								}
							}
						}
						#endregion
					}
				}
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to DomainClass because move is not allowed."));
				return;
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class DomainRole : NamedDomainElement
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
			// DomainRoleReferencesOpposite
			foreach (global::Tum.PDE.LanguageDSL.DomainRoleReferencesOpposite link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.DomainRoleReferencesOpposite>(this, global::Tum.PDE.LanguageDSL.DomainRoleReferencesOpposite.SourceDomainRoleDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewReferenceLink(protoLink);
			}
			// DomainRoleReferencesRolePlayer
			foreach (global::Tum.PDE.LanguageDSL.DomainRoleReferencesRolePlayer link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.DomainRoleReferencesRolePlayer>(this, global::Tum.PDE.LanguageDSL.DomainRoleReferencesRolePlayer.DomainRoleDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewReferenceLink(protoLink);
			}
			// DomainRoleReferencesCustomPropertyGridEditor
			foreach (global::Tum.PDE.LanguageDSL.DomainRoleReferencesCustomPropertyGridEditor link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.DomainRoleReferencesCustomPropertyGridEditor>(this, global::Tum.PDE.LanguageDSL.DomainRoleReferencesCustomPropertyGridEditor.DomainRoleDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewReferenceLink(protoLink);
			}
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to DomainRole because paste is not allowed."));
				return;
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			DslModeling::DomainRelationshipInfo linkDomainInfo = null;
			if (protoLink != null)
			{
				linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(protoLink.DomainClassId);
			}
			else
			{
				// try getting the linkDomainInfo from name
				if( protoLink.Name == "DomainRoleReferencesOpposite" && linkDomainInfo == null)
				{
					linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(DomainRoleReferencesOpposite.DomainClassId);
				}
				if( protoLink.Name == "DomainRoleReferencesRolePlayer" && linkDomainInfo == null)
				{
					linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(DomainRoleReferencesRolePlayer.DomainClassId);
				}
				if( protoLink.Name == "DomainRoleReferencesCustomPropertyGridEditor" && linkDomainInfo == null)
				{
					linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(DomainRoleReferencesCustomPropertyGridEditor.DomainClassId);
				}
			}
			
			if( linkDomainInfo == null )
			{
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkDomainTypeMissing",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link can not be created as the corresponding domain type is missing."));
				return;
			}
		
				if (linkDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.DomainRoleReferencesOpposite.DomainClassId)) 
				{
					// see if this element is taking part in this role
					bool bTakesPart = false;
					
					DslEditorModeling::ModelProtoRolePlayer sourceRolePlayer = protoLink.GetSourceRolePlayer(this.Store.DefaultPartition);
					DslEditorModeling::ModelProtoElement sourceProtoElement = groupMerger.GetElementById(sourceRolePlayer.RolePlayerId);
					System.Guid mappedSourceIdTP = System.Guid.Empty;
					if( sourceProtoElement != null )
					{
						mappedSourceIdTP = groupMerger.GetIdMapping(sourceRolePlayer.RolePlayerId);
						if( mappedSourceIdTP == this.Id )
							bTakesPart = true;
					}
		
					if( bTakesPart )
					{		
						bool bExists = true;
		        	    if( this.Store.ElementDirectory.FindElement(protoLink.ElementId) == null )
		        	        bExists = false;
							
						if( bExists && groupMerger.ProtoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
		        	    {
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkExistsOnMoveId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link exists although the operation = Move."));
						}
						
						#region Target
						// see if target element was copied
						DslEditorModeling::ModelProtoRolePlayer targetRolePlayer = protoLink.GetTargetRolePlayer(this.Store.DefaultPartition);
						DslEditorModeling::ModelProtoElement targetProtoElement = groupMerger.GetElementById(targetRolePlayer.RolePlayerId);
						System.Guid mappedTargetId = System.Guid.Empty;
						if( targetProtoElement != null )
						{
						 	mappedTargetId= groupMerger.GetIdMapping(targetRolePlayer.RolePlayerId);
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element
							mappedTargetId = targetRolePlayer.RolePlayerId;
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element with the same name as the previous element
							// TODO
						}
		
						if( mappedTargetId == System.Guid.Empty )
						{
							// log warning
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotCopiedId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not copied. Relationship: DomainRoleReferencesOpposite"));
						}
						else
						{
							DslModeling::ModelElement targetElement = this.Store.ElementDirectory.FindElement(mappedTargetId);
							if( targetElement == null )
							{
								// log error
		        	        	groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotFoundId",
					            	DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not found. Relationship: DomainRoleReferencesOpposite"));
							}
							else
							{
								bool bContinue = true;
		
								// check cardinalities, so we don't violate them by additing a new relationship
								if( DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Tum.PDE.LanguageDSL.DomainRoleReferencesOpposite.SourceDomainRoleDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: DomainRoleReferencesOpposite"));
									
									bContinue = false;
								}
								
								if( bContinue )
								{
									// create property assignments
									DslModeling::PropertyAssignment[] propertyAssignemnts = protoLink.GetPropertyAssignments(this.Store.DefaultPartition, 
										System.Guid.NewGuid());
								
									// create role assignments
									DslModeling.RoleAssignment[] roleAssignments = new DslModeling.RoleAssignment[2];
		                	        roleAssignments[0] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.DomainRoleReferencesOpposite.SourceDomainRoleDomainRoleId, this);
									roleAssignments[1] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.DomainRoleReferencesOpposite.TargetDomainRoleDomainRoleId, targetElement);
									
									// create new relationship
									new global::Tum.PDE.LanguageDSL.DomainRoleReferencesOpposite(this.Store, roleAssignments, propertyAssignemnts);
								}
							}
						}
						#endregion
					}
				}
				if (linkDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.DomainRoleReferencesRolePlayer.DomainClassId)) 
				{
					// see if this element is taking part in this role
					bool bTakesPart = false;
					
					DslEditorModeling::ModelProtoRolePlayer sourceRolePlayer = protoLink.GetSourceRolePlayer(this.Store.DefaultPartition);
					DslEditorModeling::ModelProtoElement sourceProtoElement = groupMerger.GetElementById(sourceRolePlayer.RolePlayerId);
					System.Guid mappedSourceIdTP = System.Guid.Empty;
					if( sourceProtoElement != null )
					{
						mappedSourceIdTP = groupMerger.GetIdMapping(sourceRolePlayer.RolePlayerId);
						if( mappedSourceIdTP == this.Id )
							bTakesPart = true;
					}
		
					if( bTakesPart )
					{		
						bool bExists = true;
		        	    if( this.Store.ElementDirectory.FindElement(protoLink.ElementId) == null )
		        	        bExists = false;
							
						if( bExists && groupMerger.ProtoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
		        	    {
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkExistsOnMoveId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link exists although the operation = Move."));
						}
						
						#region Target
						// see if target element was copied
						DslEditorModeling::ModelProtoRolePlayer targetRolePlayer = protoLink.GetTargetRolePlayer(this.Store.DefaultPartition);
						DslEditorModeling::ModelProtoElement targetProtoElement = groupMerger.GetElementById(targetRolePlayer.RolePlayerId);
						System.Guid mappedTargetId = System.Guid.Empty;
						if( targetProtoElement != null )
						{
						 	mappedTargetId= groupMerger.GetIdMapping(targetRolePlayer.RolePlayerId);
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element
							mappedTargetId = targetRolePlayer.RolePlayerId;
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element with the same name as the previous element
							// TODO
						}
		
						if( mappedTargetId == System.Guid.Empty )
						{
							// log warning
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotCopiedId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not copied. Relationship: DomainRoleReferencesRolePlayer"));
						}
						else
						{
							DslModeling::ModelElement targetElement = this.Store.ElementDirectory.FindElement(mappedTargetId);
							if( targetElement == null )
							{
								// log error
		        	        	groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotFoundId",
					            	DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not found. Relationship: DomainRoleReferencesRolePlayer"));
							}
							else
							{
								bool bContinue = true;
		
								// check cardinalities, so we don't violate them by additing a new relationship
								if( DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Tum.PDE.LanguageDSL.DomainRoleReferencesRolePlayer.DomainRoleDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: DomainRoleReferencesRolePlayer"));
									
									bContinue = false;
								}
								
								if( bContinue )
								{
									// create property assignments
									DslModeling::PropertyAssignment[] propertyAssignemnts = protoLink.GetPropertyAssignments(this.Store.DefaultPartition, 
										System.Guid.NewGuid());
								
									// create role assignments
									DslModeling.RoleAssignment[] roleAssignments = new DslModeling.RoleAssignment[2];
		                	        roleAssignments[0] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.DomainRoleReferencesRolePlayer.DomainRoleDomainRoleId, this);
									roleAssignments[1] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.DomainRoleReferencesRolePlayer.AttributedDomainElementDomainRoleId, targetElement);
									
									// create new relationship
									new global::Tum.PDE.LanguageDSL.DomainRoleReferencesRolePlayer(this.Store, roleAssignments, propertyAssignemnts);
								}
							}
						}
						#endregion
					}
				}
				if (linkDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.DomainRoleReferencesCustomPropertyGridEditor.DomainClassId)) 
				{
					// see if this element is taking part in this role
					bool bTakesPart = false;
					
					DslEditorModeling::ModelProtoRolePlayer sourceRolePlayer = protoLink.GetSourceRolePlayer(this.Store.DefaultPartition);
					DslEditorModeling::ModelProtoElement sourceProtoElement = groupMerger.GetElementById(sourceRolePlayer.RolePlayerId);
					System.Guid mappedSourceIdTP = System.Guid.Empty;
					if( sourceProtoElement != null )
					{
						mappedSourceIdTP = groupMerger.GetIdMapping(sourceRolePlayer.RolePlayerId);
						if( mappedSourceIdTP == this.Id )
							bTakesPart = true;
					}
		
					if( bTakesPart )
					{		
						bool bExists = true;
		        	    if( this.Store.ElementDirectory.FindElement(protoLink.ElementId) == null )
		        	        bExists = false;
							
						if( bExists && groupMerger.ProtoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
		        	    {
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkExistsOnMoveId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link exists although the operation = Move."));
						}
						
						#region Target
						// see if target element was copied
						DslEditorModeling::ModelProtoRolePlayer targetRolePlayer = protoLink.GetTargetRolePlayer(this.Store.DefaultPartition);
						DslEditorModeling::ModelProtoElement targetProtoElement = groupMerger.GetElementById(targetRolePlayer.RolePlayerId);
						System.Guid mappedTargetId = System.Guid.Empty;
						if( targetProtoElement != null )
						{
						 	mappedTargetId= groupMerger.GetIdMapping(targetRolePlayer.RolePlayerId);
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element
							mappedTargetId = targetRolePlayer.RolePlayerId;
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element with the same name as the previous element
							// TODO
						}
		
						if( mappedTargetId == System.Guid.Empty )
						{
							// log warning
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotCopiedId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not copied. Relationship: DomainRoleReferencesCustomPropertyGridEditor"));
						}
						else
						{
							DslModeling::ModelElement targetElement = this.Store.ElementDirectory.FindElement(mappedTargetId);
							if( targetElement == null )
							{
								// log error
		        	        	groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotFoundId",
					            	DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not found. Relationship: DomainRoleReferencesCustomPropertyGridEditor"));
							}
							else
							{
								bool bContinue = true;
		
								// check cardinalities, so we don't violate them by additing a new relationship
								if( DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Tum.PDE.LanguageDSL.DomainRoleReferencesCustomPropertyGridEditor.DomainRoleDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: DomainRoleReferencesCustomPropertyGridEditor"));
									
									bContinue = false;
								}
								
								if( bContinue )
								{
									// create property assignments
									DslModeling::PropertyAssignment[] propertyAssignemnts = protoLink.GetPropertyAssignments(this.Store.DefaultPartition, 
										System.Guid.NewGuid());
								
									// create role assignments
									DslModeling.RoleAssignment[] roleAssignments = new DslModeling.RoleAssignment[2];
		                	        roleAssignments[0] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.DomainRoleReferencesCustomPropertyGridEditor.DomainRoleDomainRoleId, this);
									roleAssignments[1] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.DomainRoleReferencesCustomPropertyGridEditor.PropertyGridEditorDomainRoleId, targetElement);
									
									// create new relationship
									new global::Tum.PDE.LanguageDSL.DomainRoleReferencesCustomPropertyGridEditor(this.Store, roleAssignments, propertyAssignemnts);
								}
							}
						}
						#endregion
					}
				}
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to DomainRole because move is not allowed."));
				return;
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class EmbeddingRelationship : DomainRelationship
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to EmbeddingRelationship because paste is not allowed."));
				return;
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			DslModeling::DomainRelationshipInfo linkDomainInfo = null;
			if (protoLink != null)
			{
				linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(protoLink.DomainClassId);
			}
			else
			{
				// try getting the linkDomainInfo from name
			}
			
			if( linkDomainInfo == null )
			{
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkDomainTypeMissing",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link can not be created as the corresponding domain type is missing."));
				return;
			}
		
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to EmbeddingRelationship because move is not allowed."));
				return;
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class ReferenceRelationship : DomainRelationship
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to ReferenceRelationship because paste is not allowed."));
				return;
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			DslModeling::DomainRelationshipInfo linkDomainInfo = null;
			if (protoLink != null)
			{
				linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(protoLink.DomainClassId);
			}
			else
			{
				// try getting the linkDomainInfo from name
			}
			
			if( linkDomainInfo == null )
			{
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkDomainTypeMissing",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link can not be created as the corresponding domain type is missing."));
				return;
			}
		
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to ReferenceRelationship because move is not allowed."));
				return;
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class DomainModelTreeViewBase : Tum.PDE.LanguageDSL.CopyPaste.IModelMergeElements
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public virtual bool ModelIsCopyAllowed()
		{
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public virtual bool ModelIsMoveAllowed()
		{
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public virtual bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public virtual DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public virtual DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public virtual void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			// DomainModelTreeViewReferencesRootNodes
			foreach (global::Tum.PDE.LanguageDSL.DomainModelTreeViewReferencesRootNodes link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.DomainModelTreeViewReferencesRootNodes>(this, global::Tum.PDE.LanguageDSL.DomainModelTreeViewReferencesRootNodes.DomainModelTreeViewDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewReferenceLink(protoLink);
			}
			// DomainModelTreeViewHasModelTreeNodes
			foreach (global::Tum.PDE.LanguageDSL.DomainModelTreeViewHasModelTreeNodes link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.DomainModelTreeViewHasModelTreeNodes>(this, global::Tum.PDE.LanguageDSL.DomainModelTreeViewHasModelTreeNodes.DomainModelTreeViewDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewEmbeddingLink(protoLink);
				
				DslEditorModeling::ModelProtoElement protoElementRS = new DslEditorModeling::ModelProtoElement(link.ModelTreeNode);
				protoGroup.AddNewElement(protoElementRS);
				
				// continue with target element
				if( link.ModelTreeNode is DslEditorModeling::IModelMergeElements )
				{
					(link.ModelTreeNode as DslEditorModeling::IModelMergeElements).ModelCreateMergeCopy(protoGroup);
				}
			}
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public virtual bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.ModelTreeNode.DomainClassId)) 
				{
					if( protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
					{
						foreach (global::Tum.PDE.LanguageDSL.DomainModelTreeViewHasModelTreeNodes link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.DomainModelTreeViewHasModelTreeNodes>(this, global::Tum.PDE.LanguageDSL.DomainModelTreeViewHasModelTreeNodes.DomainModelTreeViewDomainRoleId))				
							if( link.ModelTreeNode.Id == protoElement.ElementId )
								return false;
					}
					return true;
				}
			}
			return false;
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public virtual void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to DomainModelTreeView because paste is not allowed."));
				return;
			}
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.ModelTreeNode.DomainClassId)) 
				{
					// get element id
					System.Guid newElementId = System.Guid.NewGuid();
					
					// create property assignments
					DslModeling::PropertyAssignment[] propertyAssignemnts = protoElement.GetPropertyAssignments(this.Store.DefaultPartition, newElementId);
					
		            // create the actual model element
					global::Tum.PDE.LanguageDSL.ModelTreeNode element = null;			
					if( global::Tum.PDE.LanguageDSL.RootNode.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.RootNode(this.Store, propertyAssignemnts);
					if( global::Tum.PDE.LanguageDSL.EmbeddingNode.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.EmbeddingNode(this.Store, propertyAssignemnts);
					if( global::Tum.PDE.LanguageDSL.InheritanceNode.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.InheritanceNode(this.Store, propertyAssignemnts);
					if( global::Tum.PDE.LanguageDSL.ReferenceNode.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.ReferenceNode(this.Store, propertyAssignemnts);
					if( global::Tum.PDE.LanguageDSL.EmbeddingRSNode.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.EmbeddingRSNode(this.Store, propertyAssignemnts);
					if( global::Tum.PDE.LanguageDSL.ReferenceRSNode.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.ReferenceRSNode(this.Store, propertyAssignemnts);
					if( global::Tum.PDE.LanguageDSL.ShapeClassNode.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.ShapeClassNode(this.Store, propertyAssignemnts);
					if( global::Tum.PDE.LanguageDSL.ShapeRelationshipNode.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.ShapeRelationshipNode(this.Store, propertyAssignemnts);
					if( element == null )
						throw new System.ArgumentNullException("Element is null in ModelMerge: " + elementDomainInfo.Name);
					
					if( !element.ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
					{
						// add warning message
						groupMerger.MergeResult.AddMessage(new DslEditorModeling.ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to DomainModelTreeView because paste is not allowed."));
						
						element.Delete();
						return;
		 			}
					
					if( isRoot && groupMerger.ProtoGroup.Operation != DslEditorModeling.ModelProtoGroupOperation.Move)
					{
						//element.Name = "Copy of " + element.Name;
					}
					
					// update id mapping
					groupMerger.SetIdMapping(protoElement.ElementId, newElementId);
					
					// add child element
					GetRoleCollection<DslModeling::LinkedElementCollection<global::Tum.PDE.LanguageDSL.ModelTreeNode>, global::Tum.PDE.LanguageDSL.ModelTreeNode>(global::Tum.PDE.LanguageDSL.DomainModelTreeViewHasModelTreeNodes.DomainModelTreeViewDomainRoleId).Add(element);
		
					// continue with child elements (Embedding Relationship)
					System.Collections.Generic.List<DslEditorModeling::ModelProtoElement> embeddedProtoElements = groupMerger.GetEmbeddedElements(this.Store.DefaultPartition, protoElement);
					if( embeddedProtoElements.Count > 0 )
					{
						foreach (DslEditorModeling::ModelProtoElement p in embeddedProtoElements)
							(element as DslEditorModeling::IModelMergeElements).ModelMerge(p, groupMerger, false);
					}
				}
			}
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			DslModeling::DomainRelationshipInfo linkDomainInfo = null;
			if (protoLink != null)
			{
				linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(protoLink.DomainClassId);
			}
			else
			{
				// try getting the linkDomainInfo from name
				if( protoLink.Name == "DomainModelTreeViewReferencesRootNodes" && linkDomainInfo == null)
				{
					linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(DomainModelTreeViewReferencesRootNodes.DomainClassId);
				}
			}
			
			if( linkDomainInfo == null )
			{
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkDomainTypeMissing",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link can not be created as the corresponding domain type is missing."));
				return;
			}
		
				if (linkDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.DomainModelTreeViewReferencesRootNodes.DomainClassId)) 
				{
					// see if this element is taking part in this role
					bool bTakesPart = false;
					
					DslEditorModeling::ModelProtoRolePlayer sourceRolePlayer = protoLink.GetSourceRolePlayer(this.Store.DefaultPartition);
					DslEditorModeling::ModelProtoElement sourceProtoElement = groupMerger.GetElementById(sourceRolePlayer.RolePlayerId);
					System.Guid mappedSourceIdTP = System.Guid.Empty;
					if( sourceProtoElement != null )
					{
						mappedSourceIdTP = groupMerger.GetIdMapping(sourceRolePlayer.RolePlayerId);
						if( mappedSourceIdTP == this.Id )
							bTakesPart = true;
					}
		
					if( bTakesPart )
					{		
						bool bExists = true;
		        	    if( this.Store.ElementDirectory.FindElement(protoLink.ElementId) == null )
		        	        bExists = false;
							
						if( bExists && groupMerger.ProtoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
		        	    {
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkExistsOnMoveId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link exists although the operation = Move."));
						}
						
						#region Target
						// see if target element was copied
						DslEditorModeling::ModelProtoRolePlayer targetRolePlayer = protoLink.GetTargetRolePlayer(this.Store.DefaultPartition);
						DslEditorModeling::ModelProtoElement targetProtoElement = groupMerger.GetElementById(targetRolePlayer.RolePlayerId);
						System.Guid mappedTargetId = System.Guid.Empty;
						if( targetProtoElement != null )
						{
						 	mappedTargetId= groupMerger.GetIdMapping(targetRolePlayer.RolePlayerId);
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element
							mappedTargetId = targetRolePlayer.RolePlayerId;
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element with the same name as the previous element
							// TODO
						}
		
						if( mappedTargetId == System.Guid.Empty )
						{
							// log warning
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotCopiedId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not copied. Relationship: DomainModelTreeViewReferencesRootNodes"));
						}
						else
						{
							DslModeling::ModelElement targetElement = this.Store.ElementDirectory.FindElement(mappedTargetId);
							if( targetElement == null )
							{
								// log error
		        	        	groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotFoundId",
					            	DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not found. Relationship: DomainModelTreeViewReferencesRootNodes"));
							}
							else
							{
								bool bContinue = true;
		
								// check cardinalities, so we don't violate them by additing a new relationship
								if( DslModeling::DomainRoleInfo.GetLinkedElement(targetElement, global::Tum.PDE.LanguageDSL.DomainModelTreeViewReferencesRootNodes.RootNodeDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: DomainModelTreeViewReferencesRootNodes"));
									
									bContinue = false;
								}
								
								if( bContinue )
								{
									// create property assignments
									DslModeling::PropertyAssignment[] propertyAssignemnts = protoLink.GetPropertyAssignments(this.Store.DefaultPartition, 
										System.Guid.NewGuid());
								
									// create role assignments
									DslModeling.RoleAssignment[] roleAssignments = new DslModeling.RoleAssignment[2];
		                	        roleAssignments[0] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.DomainModelTreeViewReferencesRootNodes.DomainModelTreeViewDomainRoleId, this);
									roleAssignments[1] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.DomainModelTreeViewReferencesRootNodes.RootNodeDomainRoleId, targetElement);
									
									// create new relationship
									new global::Tum.PDE.LanguageDSL.DomainModelTreeViewReferencesRootNodes(this.Store, roleAssignments, propertyAssignemnts);
								}
							}
						}
						#endregion
					}
				}
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to DomainModelTreeView because move is not allowed."));
				return;
			}
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.ModelTreeNode.DomainClassId)) 
				{
		            DslModeling::ModelElement modelElement = this.Store.ElementDirectory.FindElement(protoElement.ElementId);
		            if( modelElement == null )
		            {
		                groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementMissingOnMoveId",
				             DslEditorModeling.ModelValidationViolationType.Error, "Element exists although the operation = Move."));
		                return;
					}
		
					// change parent
					DslModeling::DomainRoleInfo.SetLinkedElement(modelElement, global::Tum.PDE.LanguageDSL.DomainModelTreeViewHasModelTreeNodes.ModelTreeNodeDomainRoleId, this);
					return;
				}
			}
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class RootNode : TreeNode
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to RootNode because paste is not allowed."));
				return;
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			DslModeling::DomainRelationshipInfo linkDomainInfo = null;
			if (protoLink != null)
			{
				linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(protoLink.DomainClassId);
			}
			else
			{
				// try getting the linkDomainInfo from name
			}
			
			if( linkDomainInfo == null )
			{
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkDomainTypeMissing",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link can not be created as the corresponding domain type is missing."));
				return;
			}
		
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to RootNode because move is not allowed."));
				return;
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class TreeNodeBase : ModelTreeNode
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
			// TreeNodeReferencesDomainElement
			foreach (global::Tum.PDE.LanguageDSL.TreeNodeReferencesDomainElement link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.TreeNodeReferencesDomainElement>(this, global::Tum.PDE.LanguageDSL.TreeNodeReferencesDomainElement.TreeNodeDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewReferenceLink(protoLink);
			}
			// TreeNodeReferencesEmbeddingRSNodes
			foreach (global::Tum.PDE.LanguageDSL.TreeNodeReferencesEmbeddingRSNodes link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.TreeNodeReferencesEmbeddingRSNodes>(this, global::Tum.PDE.LanguageDSL.TreeNodeReferencesEmbeddingRSNodes.TreeNodeDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewReferenceLink(protoLink);
			}
			// TreeNodeReferencesInheritanceNodes
			foreach (global::Tum.PDE.LanguageDSL.TreeNodeReferencesInheritanceNodes link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.TreeNodeReferencesInheritanceNodes>(this, global::Tum.PDE.LanguageDSL.TreeNodeReferencesInheritanceNodes.TreeNodeDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewReferenceLink(protoLink);
			}
			// TreeNodeReferencesReferenceRSNodes
			foreach (global::Tum.PDE.LanguageDSL.TreeNodeReferencesReferenceRSNodes link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.TreeNodeReferencesReferenceRSNodes>(this, global::Tum.PDE.LanguageDSL.TreeNodeReferencesReferenceRSNodes.TreeNodeDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewReferenceLink(protoLink);
			}
			// TreeNodeReferencesShapeClassNodes
			foreach (global::Tum.PDE.LanguageDSL.TreeNodeReferencesShapeClassNodes link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.TreeNodeReferencesShapeClassNodes>(this, global::Tum.PDE.LanguageDSL.TreeNodeReferencesShapeClassNodes.TreeNodeDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewReferenceLink(protoLink);
			}
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to TreeNode because paste is not allowed."));
				return;
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			DslModeling::DomainRelationshipInfo linkDomainInfo = null;
			if (protoLink != null)
			{
				linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(protoLink.DomainClassId);
			}
			else
			{
				// try getting the linkDomainInfo from name
				if( protoLink.Name == "TreeNodeReferencesDomainElement" && linkDomainInfo == null)
				{
					linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(TreeNodeReferencesDomainElement.DomainClassId);
				}
				if( protoLink.Name == "TreeNodeReferencesEmbeddingRSNodes" && linkDomainInfo == null)
				{
					linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(TreeNodeReferencesEmbeddingRSNodes.DomainClassId);
				}
				if( protoLink.Name == "TreeNodeReferencesInheritanceNodes" && linkDomainInfo == null)
				{
					linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(TreeNodeReferencesInheritanceNodes.DomainClassId);
				}
				if( protoLink.Name == "TreeNodeReferencesReferenceRSNodes" && linkDomainInfo == null)
				{
					linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(TreeNodeReferencesReferenceRSNodes.DomainClassId);
				}
				if( protoLink.Name == "TreeNodeReferencesShapeClassNodes" && linkDomainInfo == null)
				{
					linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(TreeNodeReferencesShapeClassNodes.DomainClassId);
				}
			}
			
			if( linkDomainInfo == null )
			{
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkDomainTypeMissing",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link can not be created as the corresponding domain type is missing."));
				return;
			}
		
				if (linkDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.TreeNodeReferencesDomainElement.DomainClassId)) 
				{
					// see if this element is taking part in this role
					bool bTakesPart = false;
					
					DslEditorModeling::ModelProtoRolePlayer sourceRolePlayer = protoLink.GetSourceRolePlayer(this.Store.DefaultPartition);
					DslEditorModeling::ModelProtoElement sourceProtoElement = groupMerger.GetElementById(sourceRolePlayer.RolePlayerId);
					System.Guid mappedSourceIdTP = System.Guid.Empty;
					if( sourceProtoElement != null )
					{
						mappedSourceIdTP = groupMerger.GetIdMapping(sourceRolePlayer.RolePlayerId);
						if( mappedSourceIdTP == this.Id )
							bTakesPart = true;
					}
		
					if( bTakesPart )
					{		
						bool bExists = true;
		        	    if( this.Store.ElementDirectory.FindElement(protoLink.ElementId) == null )
		        	        bExists = false;
							
						if( bExists && groupMerger.ProtoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
		        	    {
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkExistsOnMoveId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link exists although the operation = Move."));
						}
						
						#region Target
						// see if target element was copied
						DslEditorModeling::ModelProtoRolePlayer targetRolePlayer = protoLink.GetTargetRolePlayer(this.Store.DefaultPartition);
						DslEditorModeling::ModelProtoElement targetProtoElement = groupMerger.GetElementById(targetRolePlayer.RolePlayerId);
						System.Guid mappedTargetId = System.Guid.Empty;
						if( targetProtoElement != null )
						{
						 	mappedTargetId= groupMerger.GetIdMapping(targetRolePlayer.RolePlayerId);
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element
							mappedTargetId = targetRolePlayer.RolePlayerId;
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element with the same name as the previous element
							// TODO
						}
		
						if( mappedTargetId == System.Guid.Empty )
						{
							// log warning
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotCopiedId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not copied. Relationship: TreeNodeReferencesDomainElement"));
						}
						else
						{
							DslModeling::ModelElement targetElement = this.Store.ElementDirectory.FindElement(mappedTargetId);
							if( targetElement == null )
							{
								// log error
		        	        	groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotFoundId",
					            	DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not found. Relationship: TreeNodeReferencesDomainElement"));
							}
							else
							{
								bool bContinue = true;
		
								// check cardinalities, so we don't violate them by additing a new relationship
								if( DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Tum.PDE.LanguageDSL.TreeNodeReferencesDomainElement.TreeNodeDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: TreeNodeReferencesDomainElement"));
									
									bContinue = false;
								}
								
								if( bContinue )
								{
									// create property assignments
									DslModeling::PropertyAssignment[] propertyAssignemnts = protoLink.GetPropertyAssignments(this.Store.DefaultPartition, 
										System.Guid.NewGuid());
								
									// create role assignments
									DslModeling.RoleAssignment[] roleAssignments = new DslModeling.RoleAssignment[2];
		                	        roleAssignments[0] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.TreeNodeReferencesDomainElement.TreeNodeDomainRoleId, this);
									roleAssignments[1] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.TreeNodeReferencesDomainElement.AttributedDomainElementDomainRoleId, targetElement);
									
									// create new relationship
									new global::Tum.PDE.LanguageDSL.TreeNodeReferencesDomainElement(this.Store, roleAssignments, propertyAssignemnts);
								}
							}
						}
						#endregion
					}
				}
				if (linkDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.TreeNodeReferencesEmbeddingRSNodes.DomainClassId)) 
				{
					// see if this element is taking part in this role
					bool bTakesPart = false;
					
					DslEditorModeling::ModelProtoRolePlayer sourceRolePlayer = protoLink.GetSourceRolePlayer(this.Store.DefaultPartition);
					DslEditorModeling::ModelProtoElement sourceProtoElement = groupMerger.GetElementById(sourceRolePlayer.RolePlayerId);
					System.Guid mappedSourceIdTP = System.Guid.Empty;
					if( sourceProtoElement != null )
					{
						mappedSourceIdTP = groupMerger.GetIdMapping(sourceRolePlayer.RolePlayerId);
						if( mappedSourceIdTP == this.Id )
							bTakesPart = true;
					}
		
					if( bTakesPart )
					{		
						bool bExists = true;
		        	    if( this.Store.ElementDirectory.FindElement(protoLink.ElementId) == null )
		        	        bExists = false;
							
						if( bExists && groupMerger.ProtoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
		        	    {
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkExistsOnMoveId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link exists although the operation = Move."));
						}
						
						#region Target
						// see if target element was copied
						DslEditorModeling::ModelProtoRolePlayer targetRolePlayer = protoLink.GetTargetRolePlayer(this.Store.DefaultPartition);
						DslEditorModeling::ModelProtoElement targetProtoElement = groupMerger.GetElementById(targetRolePlayer.RolePlayerId);
						System.Guid mappedTargetId = System.Guid.Empty;
						if( targetProtoElement != null )
						{
						 	mappedTargetId= groupMerger.GetIdMapping(targetRolePlayer.RolePlayerId);
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element
							mappedTargetId = targetRolePlayer.RolePlayerId;
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element with the same name as the previous element
							// TODO
						}
		
						if( mappedTargetId == System.Guid.Empty )
						{
							// log warning
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotCopiedId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not copied. Relationship: TreeNodeReferencesEmbeddingRSNodes"));
						}
						else
						{
							DslModeling::ModelElement targetElement = this.Store.ElementDirectory.FindElement(mappedTargetId);
							if( targetElement == null )
							{
								// log error
		        	        	groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotFoundId",
					            	DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not found. Relationship: TreeNodeReferencesEmbeddingRSNodes"));
							}
							else
							{
								bool bContinue = true;
		
								// check cardinalities, so we don't violate them by additing a new relationship
								if( DslModeling::DomainRoleInfo.GetLinkedElement(targetElement, global::Tum.PDE.LanguageDSL.TreeNodeReferencesEmbeddingRSNodes.EmbeddingRSNodeDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: TreeNodeReferencesEmbeddingRSNodes"));
									
									bContinue = false;
								}
								
								if( bContinue )
								{
									// create property assignments
									DslModeling::PropertyAssignment[] propertyAssignemnts = protoLink.GetPropertyAssignments(this.Store.DefaultPartition, 
										System.Guid.NewGuid());
								
									// create role assignments
									DslModeling.RoleAssignment[] roleAssignments = new DslModeling.RoleAssignment[2];
		                	        roleAssignments[0] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.TreeNodeReferencesEmbeddingRSNodes.TreeNodeDomainRoleId, this);
									roleAssignments[1] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.TreeNodeReferencesEmbeddingRSNodes.EmbeddingRSNodeDomainRoleId, targetElement);
									
									// create new relationship
									new global::Tum.PDE.LanguageDSL.TreeNodeReferencesEmbeddingRSNodes(this.Store, roleAssignments, propertyAssignemnts);
								}
							}
						}
						#endregion
					}
				}
				if (linkDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.TreeNodeReferencesInheritanceNodes.DomainClassId)) 
				{
					// see if this element is taking part in this role
					bool bTakesPart = false;
					
					DslEditorModeling::ModelProtoRolePlayer sourceRolePlayer = protoLink.GetSourceRolePlayer(this.Store.DefaultPartition);
					DslEditorModeling::ModelProtoElement sourceProtoElement = groupMerger.GetElementById(sourceRolePlayer.RolePlayerId);
					System.Guid mappedSourceIdTP = System.Guid.Empty;
					if( sourceProtoElement != null )
					{
						mappedSourceIdTP = groupMerger.GetIdMapping(sourceRolePlayer.RolePlayerId);
						if( mappedSourceIdTP == this.Id )
							bTakesPart = true;
					}
		
					if( bTakesPart )
					{		
						bool bExists = true;
		        	    if( this.Store.ElementDirectory.FindElement(protoLink.ElementId) == null )
		        	        bExists = false;
							
						if( bExists && groupMerger.ProtoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
		        	    {
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkExistsOnMoveId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link exists although the operation = Move."));
						}
						
						#region Target
						// see if target element was copied
						DslEditorModeling::ModelProtoRolePlayer targetRolePlayer = protoLink.GetTargetRolePlayer(this.Store.DefaultPartition);
						DslEditorModeling::ModelProtoElement targetProtoElement = groupMerger.GetElementById(targetRolePlayer.RolePlayerId);
						System.Guid mappedTargetId = System.Guid.Empty;
						if( targetProtoElement != null )
						{
						 	mappedTargetId= groupMerger.GetIdMapping(targetRolePlayer.RolePlayerId);
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element
							mappedTargetId = targetRolePlayer.RolePlayerId;
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element with the same name as the previous element
							// TODO
						}
		
						if( mappedTargetId == System.Guid.Empty )
						{
							// log warning
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotCopiedId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not copied. Relationship: TreeNodeReferencesInheritanceNodes"));
						}
						else
						{
							DslModeling::ModelElement targetElement = this.Store.ElementDirectory.FindElement(mappedTargetId);
							if( targetElement == null )
							{
								// log error
		        	        	groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotFoundId",
					            	DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not found. Relationship: TreeNodeReferencesInheritanceNodes"));
							}
							else
							{
								bool bContinue = true;
		
								// check cardinalities, so we don't violate them by additing a new relationship
								if( DslModeling::DomainRoleInfo.GetLinkedElement(targetElement, global::Tum.PDE.LanguageDSL.TreeNodeReferencesInheritanceNodes.InheritanceNodeDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: TreeNodeReferencesInheritanceNodes"));
									
									bContinue = false;
								}
								
								if( bContinue )
								{
									// create property assignments
									DslModeling::PropertyAssignment[] propertyAssignemnts = protoLink.GetPropertyAssignments(this.Store.DefaultPartition, 
										System.Guid.NewGuid());
								
									// create role assignments
									DslModeling.RoleAssignment[] roleAssignments = new DslModeling.RoleAssignment[2];
		                	        roleAssignments[0] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.TreeNodeReferencesInheritanceNodes.TreeNodeDomainRoleId, this);
									roleAssignments[1] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.TreeNodeReferencesInheritanceNodes.InheritanceNodeDomainRoleId, targetElement);
									
									// create new relationship
									new global::Tum.PDE.LanguageDSL.TreeNodeReferencesInheritanceNodes(this.Store, roleAssignments, propertyAssignemnts);
								}
							}
						}
						#endregion
					}
				}
				if (linkDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.TreeNodeReferencesReferenceRSNodes.DomainClassId)) 
				{
					// see if this element is taking part in this role
					bool bTakesPart = false;
					
					DslEditorModeling::ModelProtoRolePlayer sourceRolePlayer = protoLink.GetSourceRolePlayer(this.Store.DefaultPartition);
					DslEditorModeling::ModelProtoElement sourceProtoElement = groupMerger.GetElementById(sourceRolePlayer.RolePlayerId);
					System.Guid mappedSourceIdTP = System.Guid.Empty;
					if( sourceProtoElement != null )
					{
						mappedSourceIdTP = groupMerger.GetIdMapping(sourceRolePlayer.RolePlayerId);
						if( mappedSourceIdTP == this.Id )
							bTakesPart = true;
					}
		
					if( bTakesPart )
					{		
						bool bExists = true;
		        	    if( this.Store.ElementDirectory.FindElement(protoLink.ElementId) == null )
		        	        bExists = false;
							
						if( bExists && groupMerger.ProtoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
		        	    {
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkExistsOnMoveId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link exists although the operation = Move."));
						}
						
						#region Target
						// see if target element was copied
						DslEditorModeling::ModelProtoRolePlayer targetRolePlayer = protoLink.GetTargetRolePlayer(this.Store.DefaultPartition);
						DslEditorModeling::ModelProtoElement targetProtoElement = groupMerger.GetElementById(targetRolePlayer.RolePlayerId);
						System.Guid mappedTargetId = System.Guid.Empty;
						if( targetProtoElement != null )
						{
						 	mappedTargetId= groupMerger.GetIdMapping(targetRolePlayer.RolePlayerId);
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element
							mappedTargetId = targetRolePlayer.RolePlayerId;
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element with the same name as the previous element
							// TODO
						}
		
						if( mappedTargetId == System.Guid.Empty )
						{
							// log warning
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotCopiedId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not copied. Relationship: TreeNodeReferencesReferenceRSNodes"));
						}
						else
						{
							DslModeling::ModelElement targetElement = this.Store.ElementDirectory.FindElement(mappedTargetId);
							if( targetElement == null )
							{
								// log error
		        	        	groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotFoundId",
					            	DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not found. Relationship: TreeNodeReferencesReferenceRSNodes"));
							}
							else
							{
								bool bContinue = true;
		
								// check cardinalities, so we don't violate them by additing a new relationship
								if( DslModeling::DomainRoleInfo.GetLinkedElement(targetElement, global::Tum.PDE.LanguageDSL.TreeNodeReferencesReferenceRSNodes.ReferenceRSNodeDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: TreeNodeReferencesReferenceRSNodes"));
									
									bContinue = false;
								}
								
								if( bContinue )
								{
									// create property assignments
									DslModeling::PropertyAssignment[] propertyAssignemnts = protoLink.GetPropertyAssignments(this.Store.DefaultPartition, 
										System.Guid.NewGuid());
								
									// create role assignments
									DslModeling.RoleAssignment[] roleAssignments = new DslModeling.RoleAssignment[2];
		                	        roleAssignments[0] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.TreeNodeReferencesReferenceRSNodes.TreeNodeDomainRoleId, this);
									roleAssignments[1] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.TreeNodeReferencesReferenceRSNodes.ReferenceRSNodeDomainRoleId, targetElement);
									
									// create new relationship
									new global::Tum.PDE.LanguageDSL.TreeNodeReferencesReferenceRSNodes(this.Store, roleAssignments, propertyAssignemnts);
								}
							}
						}
						#endregion
					}
				}
				if (linkDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.TreeNodeReferencesShapeClassNodes.DomainClassId)) 
				{
					// see if this element is taking part in this role
					bool bTakesPart = false;
					
					DslEditorModeling::ModelProtoRolePlayer sourceRolePlayer = protoLink.GetSourceRolePlayer(this.Store.DefaultPartition);
					DslEditorModeling::ModelProtoElement sourceProtoElement = groupMerger.GetElementById(sourceRolePlayer.RolePlayerId);
					System.Guid mappedSourceIdTP = System.Guid.Empty;
					if( sourceProtoElement != null )
					{
						mappedSourceIdTP = groupMerger.GetIdMapping(sourceRolePlayer.RolePlayerId);
						if( mappedSourceIdTP == this.Id )
							bTakesPart = true;
					}
		
					if( bTakesPart )
					{		
						bool bExists = true;
		        	    if( this.Store.ElementDirectory.FindElement(protoLink.ElementId) == null )
		        	        bExists = false;
							
						if( bExists && groupMerger.ProtoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
		        	    {
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkExistsOnMoveId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link exists although the operation = Move."));
						}
						
						#region Target
						// see if target element was copied
						DslEditorModeling::ModelProtoRolePlayer targetRolePlayer = protoLink.GetTargetRolePlayer(this.Store.DefaultPartition);
						DslEditorModeling::ModelProtoElement targetProtoElement = groupMerger.GetElementById(targetRolePlayer.RolePlayerId);
						System.Guid mappedTargetId = System.Guid.Empty;
						if( targetProtoElement != null )
						{
						 	mappedTargetId= groupMerger.GetIdMapping(targetRolePlayer.RolePlayerId);
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element
							mappedTargetId = targetRolePlayer.RolePlayerId;
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element with the same name as the previous element
							// TODO
						}
		
						if( mappedTargetId == System.Guid.Empty )
						{
							// log warning
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotCopiedId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not copied. Relationship: TreeNodeReferencesShapeClassNodes"));
						}
						else
						{
							DslModeling::ModelElement targetElement = this.Store.ElementDirectory.FindElement(mappedTargetId);
							if( targetElement == null )
							{
								// log error
		        	        	groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotFoundId",
					            	DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not found. Relationship: TreeNodeReferencesShapeClassNodes"));
							}
							else
							{
								bool bContinue = true;
		
								// check cardinalities, so we don't violate them by additing a new relationship
								if( DslModeling::DomainRoleInfo.GetLinkedElement(targetElement, global::Tum.PDE.LanguageDSL.TreeNodeReferencesShapeClassNodes.ShapeClassNodeDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: TreeNodeReferencesShapeClassNodes"));
									
									bContinue = false;
								}
								
								if( bContinue )
								{
									// create property assignments
									DslModeling::PropertyAssignment[] propertyAssignemnts = protoLink.GetPropertyAssignments(this.Store.DefaultPartition, 
										System.Guid.NewGuid());
								
									// create role assignments
									DslModeling.RoleAssignment[] roleAssignments = new DslModeling.RoleAssignment[2];
		                	        roleAssignments[0] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.TreeNodeReferencesShapeClassNodes.TreeNodeDomainRoleId, this);
									roleAssignments[1] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.TreeNodeReferencesShapeClassNodes.ShapeClassNodeDomainRoleId, targetElement);
									
									// create new relationship
									new global::Tum.PDE.LanguageDSL.TreeNodeReferencesShapeClassNodes(this.Store, roleAssignments, propertyAssignemnts);
								}
							}
						}
						#endregion
					}
				}
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to TreeNode because move is not allowed."));
				return;
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class EmbeddingRSNodeBase : ModelTreeNode
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
			// EmbeddingRSNodeReferencesRelationship
			foreach (global::Tum.PDE.LanguageDSL.EmbeddingRSNodeReferencesRelationship link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.EmbeddingRSNodeReferencesRelationship>(this, global::Tum.PDE.LanguageDSL.EmbeddingRSNodeReferencesRelationship.EmbeddingRSNodeDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewReferenceLink(protoLink);
			}
			// EmbeddingRSNodeReferencesEmbeddingNode
			foreach (global::Tum.PDE.LanguageDSL.EmbeddingRSNodeReferencesEmbeddingNode link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.EmbeddingRSNodeReferencesEmbeddingNode>(this, global::Tum.PDE.LanguageDSL.EmbeddingRSNodeReferencesEmbeddingNode.EmbeddingRSNodeDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewReferenceLink(protoLink);
			}
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to EmbeddingRSNode because paste is not allowed."));
				return;
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			DslModeling::DomainRelationshipInfo linkDomainInfo = null;
			if (protoLink != null)
			{
				linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(protoLink.DomainClassId);
			}
			else
			{
				// try getting the linkDomainInfo from name
				if( protoLink.Name == "EmbeddingRSNodeReferencesRelationship" && linkDomainInfo == null)
				{
					linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(EmbeddingRSNodeReferencesRelationship.DomainClassId);
				}
				if( protoLink.Name == "EmbeddingRSNodeReferencesEmbeddingNode" && linkDomainInfo == null)
				{
					linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(EmbeddingRSNodeReferencesEmbeddingNode.DomainClassId);
				}
			}
			
			if( linkDomainInfo == null )
			{
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkDomainTypeMissing",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link can not be created as the corresponding domain type is missing."));
				return;
			}
		
				if (linkDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.EmbeddingRSNodeReferencesRelationship.DomainClassId)) 
				{
					// see if this element is taking part in this role
					bool bTakesPart = false;
					
					DslEditorModeling::ModelProtoRolePlayer sourceRolePlayer = protoLink.GetSourceRolePlayer(this.Store.DefaultPartition);
					DslEditorModeling::ModelProtoElement sourceProtoElement = groupMerger.GetElementById(sourceRolePlayer.RolePlayerId);
					System.Guid mappedSourceIdTP = System.Guid.Empty;
					if( sourceProtoElement != null )
					{
						mappedSourceIdTP = groupMerger.GetIdMapping(sourceRolePlayer.RolePlayerId);
						if( mappedSourceIdTP == this.Id )
							bTakesPart = true;
					}
		
					if( bTakesPart )
					{		
						bool bExists = true;
		        	    if( this.Store.ElementDirectory.FindElement(protoLink.ElementId) == null )
		        	        bExists = false;
							
						if( bExists && groupMerger.ProtoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
		        	    {
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkExistsOnMoveId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link exists although the operation = Move."));
						}
						
						#region Target
						// see if target element was copied
						DslEditorModeling::ModelProtoRolePlayer targetRolePlayer = protoLink.GetTargetRolePlayer(this.Store.DefaultPartition);
						DslEditorModeling::ModelProtoElement targetProtoElement = groupMerger.GetElementById(targetRolePlayer.RolePlayerId);
						System.Guid mappedTargetId = System.Guid.Empty;
						if( targetProtoElement != null )
						{
						 	mappedTargetId= groupMerger.GetIdMapping(targetRolePlayer.RolePlayerId);
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element
							mappedTargetId = targetRolePlayer.RolePlayerId;
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element with the same name as the previous element
							// TODO
						}
		
						if( mappedTargetId == System.Guid.Empty )
						{
							// log warning
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotCopiedId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not copied. Relationship: EmbeddingRSNodeReferencesRelationship"));
						}
						else
						{
							DslModeling::ModelElement targetElement = this.Store.ElementDirectory.FindElement(mappedTargetId);
							if( targetElement == null )
							{
								// log error
		        	        	groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotFoundId",
					            	DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not found. Relationship: EmbeddingRSNodeReferencesRelationship"));
							}
							else
							{
								bool bContinue = true;
		
								// check cardinalities, so we don't violate them by additing a new relationship
								if( DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Tum.PDE.LanguageDSL.EmbeddingRSNodeReferencesRelationship.EmbeddingRSNodeDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: EmbeddingRSNodeReferencesRelationship"));
									
									bContinue = false;
								}
								if( DslModeling::DomainRoleInfo.GetLinkedElement(targetElement, global::Tum.PDE.LanguageDSL.EmbeddingRSNodeReferencesRelationship.DomainRelationshipDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: EmbeddingRSNodeReferencesRelationship"));
									
									bContinue = false;
								}
								
								if( bContinue )
								{
									// create property assignments
									DslModeling::PropertyAssignment[] propertyAssignemnts = protoLink.GetPropertyAssignments(this.Store.DefaultPartition, 
										System.Guid.NewGuid());
								
									// create role assignments
									DslModeling.RoleAssignment[] roleAssignments = new DslModeling.RoleAssignment[2];
		                	        roleAssignments[0] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.EmbeddingRSNodeReferencesRelationship.EmbeddingRSNodeDomainRoleId, this);
									roleAssignments[1] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.EmbeddingRSNodeReferencesRelationship.DomainRelationshipDomainRoleId, targetElement);
									
									// create new relationship
									new global::Tum.PDE.LanguageDSL.EmbeddingRSNodeReferencesRelationship(this.Store, roleAssignments, propertyAssignemnts);
								}
							}
						}
						#endregion
					}
				}
				if (linkDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.EmbeddingRSNodeReferencesEmbeddingNode.DomainClassId)) 
				{
					// see if this element is taking part in this role
					bool bTakesPart = false;
					
					DslEditorModeling::ModelProtoRolePlayer sourceRolePlayer = protoLink.GetSourceRolePlayer(this.Store.DefaultPartition);
					DslEditorModeling::ModelProtoElement sourceProtoElement = groupMerger.GetElementById(sourceRolePlayer.RolePlayerId);
					System.Guid mappedSourceIdTP = System.Guid.Empty;
					if( sourceProtoElement != null )
					{
						mappedSourceIdTP = groupMerger.GetIdMapping(sourceRolePlayer.RolePlayerId);
						if( mappedSourceIdTP == this.Id )
							bTakesPart = true;
					}
		
					if( bTakesPart )
					{		
						bool bExists = true;
		        	    if( this.Store.ElementDirectory.FindElement(protoLink.ElementId) == null )
		        	        bExists = false;
							
						if( bExists && groupMerger.ProtoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
		        	    {
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkExistsOnMoveId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link exists although the operation = Move."));
						}
						
						#region Target
						// see if target element was copied
						DslEditorModeling::ModelProtoRolePlayer targetRolePlayer = protoLink.GetTargetRolePlayer(this.Store.DefaultPartition);
						DslEditorModeling::ModelProtoElement targetProtoElement = groupMerger.GetElementById(targetRolePlayer.RolePlayerId);
						System.Guid mappedTargetId = System.Guid.Empty;
						if( targetProtoElement != null )
						{
						 	mappedTargetId= groupMerger.GetIdMapping(targetRolePlayer.RolePlayerId);
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element
							mappedTargetId = targetRolePlayer.RolePlayerId;
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element with the same name as the previous element
							// TODO
						}
		
						if( mappedTargetId == System.Guid.Empty )
						{
							// log warning
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotCopiedId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not copied. Relationship: EmbeddingRSNodeReferencesEmbeddingNode"));
						}
						else
						{
							DslModeling::ModelElement targetElement = this.Store.ElementDirectory.FindElement(mappedTargetId);
							if( targetElement == null )
							{
								// log error
		        	        	groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotFoundId",
					            	DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not found. Relationship: EmbeddingRSNodeReferencesEmbeddingNode"));
							}
							else
							{
								bool bContinue = true;
		
								// check cardinalities, so we don't violate them by additing a new relationship
								if( DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Tum.PDE.LanguageDSL.EmbeddingRSNodeReferencesEmbeddingNode.EmbeddingRSNodeDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: EmbeddingRSNodeReferencesEmbeddingNode"));
									
									bContinue = false;
								}
								if( DslModeling::DomainRoleInfo.GetLinkedElement(targetElement, global::Tum.PDE.LanguageDSL.EmbeddingRSNodeReferencesEmbeddingNode.EmbeddingNodeDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: EmbeddingRSNodeReferencesEmbeddingNode"));
									
									bContinue = false;
								}
								
								if( bContinue )
								{
									// create property assignments
									DslModeling::PropertyAssignment[] propertyAssignemnts = protoLink.GetPropertyAssignments(this.Store.DefaultPartition, 
										System.Guid.NewGuid());
								
									// create role assignments
									DslModeling.RoleAssignment[] roleAssignments = new DslModeling.RoleAssignment[2];
		                	        roleAssignments[0] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.EmbeddingRSNodeReferencesEmbeddingNode.EmbeddingRSNodeDomainRoleId, this);
									roleAssignments[1] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.EmbeddingRSNodeReferencesEmbeddingNode.EmbeddingNodeDomainRoleId, targetElement);
									
									// create new relationship
									new global::Tum.PDE.LanguageDSL.EmbeddingRSNodeReferencesEmbeddingNode(this.Store, roleAssignments, propertyAssignemnts);
								}
							}
						}
						#endregion
					}
				}
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to EmbeddingRSNode because move is not allowed."));
				return;
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class EmbeddingNode : TreeNode
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to EmbeddingNode because paste is not allowed."));
				return;
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			DslModeling::DomainRelationshipInfo linkDomainInfo = null;
			if (protoLink != null)
			{
				linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(protoLink.DomainClassId);
			}
			else
			{
				// try getting the linkDomainInfo from name
			}
			
			if( linkDomainInfo == null )
			{
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkDomainTypeMissing",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link can not be created as the corresponding domain type is missing."));
				return;
			}
		
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to EmbeddingNode because move is not allowed."));
				return;
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class InheritanceNode : TreeNode
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to InheritanceNode because paste is not allowed."));
				return;
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			DslModeling::DomainRelationshipInfo linkDomainInfo = null;
			if (protoLink != null)
			{
				linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(protoLink.DomainClassId);
			}
			else
			{
				// try getting the linkDomainInfo from name
			}
			
			if( linkDomainInfo == null )
			{
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkDomainTypeMissing",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link can not be created as the corresponding domain type is missing."));
				return;
			}
		
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to InheritanceNode because move is not allowed."));
				return;
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class ReferenceRSNodeBase : ModelTreeNode
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
			// ReferenceRSNodeReferencesReferenceRelationship
			foreach (global::Tum.PDE.LanguageDSL.ReferenceRSNodeReferencesReferenceRelationship link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.ReferenceRSNodeReferencesReferenceRelationship>(this, global::Tum.PDE.LanguageDSL.ReferenceRSNodeReferencesReferenceRelationship.ReferenceRSNodeDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewReferenceLink(protoLink);
			}
			// ReferenceRSNodeReferencesReferenceNode
			foreach (global::Tum.PDE.LanguageDSL.ReferenceRSNodeReferencesReferenceNode link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.ReferenceRSNodeReferencesReferenceNode>(this, global::Tum.PDE.LanguageDSL.ReferenceRSNodeReferencesReferenceNode.ReferenceRSNodeDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewReferenceLink(protoLink);
			}
			// ReferenceRSNodeReferencesShapeRelationshipNodes
			foreach (global::Tum.PDE.LanguageDSL.ReferenceRSNodeReferencesShapeRelationshipNodes link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.ReferenceRSNodeReferencesShapeRelationshipNodes>(this, global::Tum.PDE.LanguageDSL.ReferenceRSNodeReferencesShapeRelationshipNodes.ReferenceRSNodeDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewReferenceLink(protoLink);
			}
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to ReferenceRSNode because paste is not allowed."));
				return;
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			DslModeling::DomainRelationshipInfo linkDomainInfo = null;
			if (protoLink != null)
			{
				linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(protoLink.DomainClassId);
			}
			else
			{
				// try getting the linkDomainInfo from name
				if( protoLink.Name == "ReferenceRSNodeReferencesReferenceRelationship" && linkDomainInfo == null)
				{
					linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(ReferenceRSNodeReferencesReferenceRelationship.DomainClassId);
				}
				if( protoLink.Name == "ReferenceRSNodeReferencesReferenceNode" && linkDomainInfo == null)
				{
					linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(ReferenceRSNodeReferencesReferenceNode.DomainClassId);
				}
				if( protoLink.Name == "ReferenceRSNodeReferencesShapeRelationshipNodes" && linkDomainInfo == null)
				{
					linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(ReferenceRSNodeReferencesShapeRelationshipNodes.DomainClassId);
				}
			}
			
			if( linkDomainInfo == null )
			{
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkDomainTypeMissing",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link can not be created as the corresponding domain type is missing."));
				return;
			}
		
				if (linkDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.ReferenceRSNodeReferencesReferenceRelationship.DomainClassId)) 
				{
					// see if this element is taking part in this role
					bool bTakesPart = false;
					
					DslEditorModeling::ModelProtoRolePlayer sourceRolePlayer = protoLink.GetSourceRolePlayer(this.Store.DefaultPartition);
					DslEditorModeling::ModelProtoElement sourceProtoElement = groupMerger.GetElementById(sourceRolePlayer.RolePlayerId);
					System.Guid mappedSourceIdTP = System.Guid.Empty;
					if( sourceProtoElement != null )
					{
						mappedSourceIdTP = groupMerger.GetIdMapping(sourceRolePlayer.RolePlayerId);
						if( mappedSourceIdTP == this.Id )
							bTakesPart = true;
					}
		
					if( bTakesPart )
					{		
						bool bExists = true;
		        	    if( this.Store.ElementDirectory.FindElement(protoLink.ElementId) == null )
		        	        bExists = false;
							
						if( bExists && groupMerger.ProtoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
		        	    {
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkExistsOnMoveId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link exists although the operation = Move."));
						}
						
						#region Target
						// see if target element was copied
						DslEditorModeling::ModelProtoRolePlayer targetRolePlayer = protoLink.GetTargetRolePlayer(this.Store.DefaultPartition);
						DslEditorModeling::ModelProtoElement targetProtoElement = groupMerger.GetElementById(targetRolePlayer.RolePlayerId);
						System.Guid mappedTargetId = System.Guid.Empty;
						if( targetProtoElement != null )
						{
						 	mappedTargetId= groupMerger.GetIdMapping(targetRolePlayer.RolePlayerId);
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element
							mappedTargetId = targetRolePlayer.RolePlayerId;
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element with the same name as the previous element
							// TODO
						}
		
						if( mappedTargetId == System.Guid.Empty )
						{
							// log warning
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotCopiedId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not copied. Relationship: ReferenceRSNodeReferencesReferenceRelationship"));
						}
						else
						{
							DslModeling::ModelElement targetElement = this.Store.ElementDirectory.FindElement(mappedTargetId);
							if( targetElement == null )
							{
								// log error
		        	        	groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotFoundId",
					            	DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not found. Relationship: ReferenceRSNodeReferencesReferenceRelationship"));
							}
							else
							{
								bool bContinue = true;
		
								// check cardinalities, so we don't violate them by additing a new relationship
								if( DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Tum.PDE.LanguageDSL.ReferenceRSNodeReferencesReferenceRelationship.ReferenceRSNodeDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: ReferenceRSNodeReferencesReferenceRelationship"));
									
									bContinue = false;
								}
								if( DslModeling::DomainRoleInfo.GetLinkedElement(targetElement, global::Tum.PDE.LanguageDSL.ReferenceRSNodeReferencesReferenceRelationship.ReferenceRelationshipDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: ReferenceRSNodeReferencesReferenceRelationship"));
									
									bContinue = false;
								}
								
								if( bContinue )
								{
									// create property assignments
									DslModeling::PropertyAssignment[] propertyAssignemnts = protoLink.GetPropertyAssignments(this.Store.DefaultPartition, 
										System.Guid.NewGuid());
								
									// create role assignments
									DslModeling.RoleAssignment[] roleAssignments = new DslModeling.RoleAssignment[2];
		                	        roleAssignments[0] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.ReferenceRSNodeReferencesReferenceRelationship.ReferenceRSNodeDomainRoleId, this);
									roleAssignments[1] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.ReferenceRSNodeReferencesReferenceRelationship.ReferenceRelationshipDomainRoleId, targetElement);
									
									// create new relationship
									new global::Tum.PDE.LanguageDSL.ReferenceRSNodeReferencesReferenceRelationship(this.Store, roleAssignments, propertyAssignemnts);
								}
							}
						}
						#endregion
					}
				}
				if (linkDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.ReferenceRSNodeReferencesReferenceNode.DomainClassId)) 
				{
					// see if this element is taking part in this role
					bool bTakesPart = false;
					
					DslEditorModeling::ModelProtoRolePlayer sourceRolePlayer = protoLink.GetSourceRolePlayer(this.Store.DefaultPartition);
					DslEditorModeling::ModelProtoElement sourceProtoElement = groupMerger.GetElementById(sourceRolePlayer.RolePlayerId);
					System.Guid mappedSourceIdTP = System.Guid.Empty;
					if( sourceProtoElement != null )
					{
						mappedSourceIdTP = groupMerger.GetIdMapping(sourceRolePlayer.RolePlayerId);
						if( mappedSourceIdTP == this.Id )
							bTakesPart = true;
					}
		
					if( bTakesPart )
					{		
						bool bExists = true;
		        	    if( this.Store.ElementDirectory.FindElement(protoLink.ElementId) == null )
		        	        bExists = false;
							
						if( bExists && groupMerger.ProtoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
		        	    {
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkExistsOnMoveId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link exists although the operation = Move."));
						}
						
						#region Target
						// see if target element was copied
						DslEditorModeling::ModelProtoRolePlayer targetRolePlayer = protoLink.GetTargetRolePlayer(this.Store.DefaultPartition);
						DslEditorModeling::ModelProtoElement targetProtoElement = groupMerger.GetElementById(targetRolePlayer.RolePlayerId);
						System.Guid mappedTargetId = System.Guid.Empty;
						if( targetProtoElement != null )
						{
						 	mappedTargetId= groupMerger.GetIdMapping(targetRolePlayer.RolePlayerId);
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element
							mappedTargetId = targetRolePlayer.RolePlayerId;
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element with the same name as the previous element
							// TODO
						}
		
						if( mappedTargetId == System.Guid.Empty )
						{
							// log warning
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotCopiedId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not copied. Relationship: ReferenceRSNodeReferencesReferenceNode"));
						}
						else
						{
							DslModeling::ModelElement targetElement = this.Store.ElementDirectory.FindElement(mappedTargetId);
							if( targetElement == null )
							{
								// log error
		        	        	groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotFoundId",
					            	DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not found. Relationship: ReferenceRSNodeReferencesReferenceNode"));
							}
							else
							{
								bool bContinue = true;
		
								// check cardinalities, so we don't violate them by additing a new relationship
								if( DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Tum.PDE.LanguageDSL.ReferenceRSNodeReferencesReferenceNode.ReferenceRSNodeDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: ReferenceRSNodeReferencesReferenceNode"));
									
									bContinue = false;
								}
								if( DslModeling::DomainRoleInfo.GetLinkedElement(targetElement, global::Tum.PDE.LanguageDSL.ReferenceRSNodeReferencesReferenceNode.ReferenceNodeDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: ReferenceRSNodeReferencesReferenceNode"));
									
									bContinue = false;
								}
								
								if( bContinue )
								{
									// create property assignments
									DslModeling::PropertyAssignment[] propertyAssignemnts = protoLink.GetPropertyAssignments(this.Store.DefaultPartition, 
										System.Guid.NewGuid());
								
									// create role assignments
									DslModeling.RoleAssignment[] roleAssignments = new DslModeling.RoleAssignment[2];
		                	        roleAssignments[0] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.ReferenceRSNodeReferencesReferenceNode.ReferenceRSNodeDomainRoleId, this);
									roleAssignments[1] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.ReferenceRSNodeReferencesReferenceNode.ReferenceNodeDomainRoleId, targetElement);
									
									// create new relationship
									new global::Tum.PDE.LanguageDSL.ReferenceRSNodeReferencesReferenceNode(this.Store, roleAssignments, propertyAssignemnts);
								}
							}
						}
						#endregion
					}
				}
				if (linkDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.ReferenceRSNodeReferencesShapeRelationshipNodes.DomainClassId)) 
				{
					// see if this element is taking part in this role
					bool bTakesPart = false;
					
					DslEditorModeling::ModelProtoRolePlayer sourceRolePlayer = protoLink.GetSourceRolePlayer(this.Store.DefaultPartition);
					DslEditorModeling::ModelProtoElement sourceProtoElement = groupMerger.GetElementById(sourceRolePlayer.RolePlayerId);
					System.Guid mappedSourceIdTP = System.Guid.Empty;
					if( sourceProtoElement != null )
					{
						mappedSourceIdTP = groupMerger.GetIdMapping(sourceRolePlayer.RolePlayerId);
						if( mappedSourceIdTP == this.Id )
							bTakesPart = true;
					}
		
					if( bTakesPart )
					{		
						bool bExists = true;
		        	    if( this.Store.ElementDirectory.FindElement(protoLink.ElementId) == null )
		        	        bExists = false;
							
						if( bExists && groupMerger.ProtoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
		        	    {
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkExistsOnMoveId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link exists although the operation = Move."));
						}
						
						#region Target
						// see if target element was copied
						DslEditorModeling::ModelProtoRolePlayer targetRolePlayer = protoLink.GetTargetRolePlayer(this.Store.DefaultPartition);
						DslEditorModeling::ModelProtoElement targetProtoElement = groupMerger.GetElementById(targetRolePlayer.RolePlayerId);
						System.Guid mappedTargetId = System.Guid.Empty;
						if( targetProtoElement != null )
						{
						 	mappedTargetId= groupMerger.GetIdMapping(targetRolePlayer.RolePlayerId);
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element
							mappedTargetId = targetRolePlayer.RolePlayerId;
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element with the same name as the previous element
							// TODO
						}
		
						if( mappedTargetId == System.Guid.Empty )
						{
							// log warning
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotCopiedId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not copied. Relationship: ReferenceRSNodeReferencesShapeRelationshipNodes"));
						}
						else
						{
							DslModeling::ModelElement targetElement = this.Store.ElementDirectory.FindElement(mappedTargetId);
							if( targetElement == null )
							{
								// log error
		        	        	groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotFoundId",
					            	DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not found. Relationship: ReferenceRSNodeReferencesShapeRelationshipNodes"));
							}
							else
							{
								bool bContinue = true;
		
								// check cardinalities, so we don't violate them by additing a new relationship
								if( DslModeling::DomainRoleInfo.GetLinkedElement(targetElement, global::Tum.PDE.LanguageDSL.ReferenceRSNodeReferencesShapeRelationshipNodes.ShapeRelationshipNodeDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: ReferenceRSNodeReferencesShapeRelationshipNodes"));
									
									bContinue = false;
								}
								
								if( bContinue )
								{
									// create property assignments
									DslModeling::PropertyAssignment[] propertyAssignemnts = protoLink.GetPropertyAssignments(this.Store.DefaultPartition, 
										System.Guid.NewGuid());
								
									// create role assignments
									DslModeling.RoleAssignment[] roleAssignments = new DslModeling.RoleAssignment[2];
		                	        roleAssignments[0] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.ReferenceRSNodeReferencesShapeRelationshipNodes.ReferenceRSNodeDomainRoleId, this);
									roleAssignments[1] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.ReferenceRSNodeReferencesShapeRelationshipNodes.ShapeRelationshipNodeDomainRoleId, targetElement);
									
									// create new relationship
									new global::Tum.PDE.LanguageDSL.ReferenceRSNodeReferencesShapeRelationshipNodes(this.Store, roleAssignments, propertyAssignemnts);
								}
							}
						}
						#endregion
					}
				}
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to ReferenceRSNode because move is not allowed."));
				return;
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class ReferenceNode : TreeNode
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to ReferenceNode because paste is not allowed."));
				return;
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			DslModeling::DomainRelationshipInfo linkDomainInfo = null;
			if (protoLink != null)
			{
				linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(protoLink.DomainClassId);
			}
			else
			{
				// try getting the linkDomainInfo from name
			}
			
			if( linkDomainInfo == null )
			{
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkDomainTypeMissing",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link can not be created as the corresponding domain type is missing."));
				return;
			}
		
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to ReferenceNode because move is not allowed."));
				return;
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class ShapeClassNodeBase : ModelTreeNode
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
			// ShapeClassNodeReferencesShapeClass
			foreach (global::Tum.PDE.LanguageDSL.ShapeClassNodeReferencesShapeClass link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.ShapeClassNodeReferencesShapeClass>(this, global::Tum.PDE.LanguageDSL.ShapeClassNodeReferencesShapeClass.ShapeClassNodeDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewReferenceLink(protoLink);
			}
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to ShapeClassNode because paste is not allowed."));
				return;
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			DslModeling::DomainRelationshipInfo linkDomainInfo = null;
			if (protoLink != null)
			{
				linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(protoLink.DomainClassId);
			}
			else
			{
				// try getting the linkDomainInfo from name
				if( protoLink.Name == "ShapeClassNodeReferencesShapeClass" && linkDomainInfo == null)
				{
					linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(ShapeClassNodeReferencesShapeClass.DomainClassId);
				}
			}
			
			if( linkDomainInfo == null )
			{
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkDomainTypeMissing",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link can not be created as the corresponding domain type is missing."));
				return;
			}
		
				if (linkDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.ShapeClassNodeReferencesShapeClass.DomainClassId)) 
				{
					// see if this element is taking part in this role
					bool bTakesPart = false;
					
					DslEditorModeling::ModelProtoRolePlayer sourceRolePlayer = protoLink.GetSourceRolePlayer(this.Store.DefaultPartition);
					DslEditorModeling::ModelProtoElement sourceProtoElement = groupMerger.GetElementById(sourceRolePlayer.RolePlayerId);
					System.Guid mappedSourceIdTP = System.Guid.Empty;
					if( sourceProtoElement != null )
					{
						mappedSourceIdTP = groupMerger.GetIdMapping(sourceRolePlayer.RolePlayerId);
						if( mappedSourceIdTP == this.Id )
							bTakesPart = true;
					}
		
					if( bTakesPart )
					{		
						bool bExists = true;
		        	    if( this.Store.ElementDirectory.FindElement(protoLink.ElementId) == null )
		        	        bExists = false;
							
						if( bExists && groupMerger.ProtoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
		        	    {
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkExistsOnMoveId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link exists although the operation = Move."));
						}
						
						#region Target
						// see if target element was copied
						DslEditorModeling::ModelProtoRolePlayer targetRolePlayer = protoLink.GetTargetRolePlayer(this.Store.DefaultPartition);
						DslEditorModeling::ModelProtoElement targetProtoElement = groupMerger.GetElementById(targetRolePlayer.RolePlayerId);
						System.Guid mappedTargetId = System.Guid.Empty;
						if( targetProtoElement != null )
						{
						 	mappedTargetId= groupMerger.GetIdMapping(targetRolePlayer.RolePlayerId);
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element
							mappedTargetId = targetRolePlayer.RolePlayerId;
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element with the same name as the previous element
							// TODO
						}
		
						if( mappedTargetId == System.Guid.Empty )
						{
							// log warning
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotCopiedId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not copied. Relationship: ShapeClassNodeReferencesShapeClass"));
						}
						else
						{
							DslModeling::ModelElement targetElement = this.Store.ElementDirectory.FindElement(mappedTargetId);
							if( targetElement == null )
							{
								// log error
		        	        	groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotFoundId",
					            	DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not found. Relationship: ShapeClassNodeReferencesShapeClass"));
							}
							else
							{
								bool bContinue = true;
		
								// check cardinalities, so we don't violate them by additing a new relationship
								if( DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Tum.PDE.LanguageDSL.ShapeClassNodeReferencesShapeClass.ShapeClassNodeDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: ShapeClassNodeReferencesShapeClass"));
									
									bContinue = false;
								}
								if( DslModeling::DomainRoleInfo.GetLinkedElement(targetElement, global::Tum.PDE.LanguageDSL.ShapeClassNodeReferencesShapeClass.ShapeClassDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: ShapeClassNodeReferencesShapeClass"));
									
									bContinue = false;
								}
								
								if( bContinue )
								{
									// create property assignments
									DslModeling::PropertyAssignment[] propertyAssignemnts = protoLink.GetPropertyAssignments(this.Store.DefaultPartition, 
										System.Guid.NewGuid());
								
									// create role assignments
									DslModeling.RoleAssignment[] roleAssignments = new DslModeling.RoleAssignment[2];
		                	        roleAssignments[0] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.ShapeClassNodeReferencesShapeClass.ShapeClassNodeDomainRoleId, this);
									roleAssignments[1] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.ShapeClassNodeReferencesShapeClass.ShapeClassDomainRoleId, targetElement);
									
									// create new relationship
									new global::Tum.PDE.LanguageDSL.ShapeClassNodeReferencesShapeClass(this.Store, roleAssignments, propertyAssignemnts);
								}
							}
						}
						#endregion
					}
				}
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to ShapeClassNode because move is not allowed."));
				return;
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class ShapeRelationshipNode : ModelTreeNode
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
			// ShapeRelationshipNodeReferencesRelationshipShapeClass
			foreach (global::Tum.PDE.LanguageDSL.ShapeRelationshipNodeReferencesRelationshipShapeClass link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.ShapeRelationshipNodeReferencesRelationshipShapeClass>(this, global::Tum.PDE.LanguageDSL.ShapeRelationshipNodeReferencesRelationshipShapeClass.ShapeRelationshipNodeDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewReferenceLink(protoLink);
			}
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to ShapeRelationshipNode because paste is not allowed."));
				return;
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			DslModeling::DomainRelationshipInfo linkDomainInfo = null;
			if (protoLink != null)
			{
				linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(protoLink.DomainClassId);
			}
			else
			{
				// try getting the linkDomainInfo from name
				if( protoLink.Name == "ShapeRelationshipNodeReferencesRelationshipShapeClass" && linkDomainInfo == null)
				{
					linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(ShapeRelationshipNodeReferencesRelationshipShapeClass.DomainClassId);
				}
			}
			
			if( linkDomainInfo == null )
			{
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkDomainTypeMissing",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link can not be created as the corresponding domain type is missing."));
				return;
			}
		
				if (linkDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.ShapeRelationshipNodeReferencesRelationshipShapeClass.DomainClassId)) 
				{
					// see if this element is taking part in this role
					bool bTakesPart = false;
					
					DslEditorModeling::ModelProtoRolePlayer sourceRolePlayer = protoLink.GetSourceRolePlayer(this.Store.DefaultPartition);
					DslEditorModeling::ModelProtoElement sourceProtoElement = groupMerger.GetElementById(sourceRolePlayer.RolePlayerId);
					System.Guid mappedSourceIdTP = System.Guid.Empty;
					if( sourceProtoElement != null )
					{
						mappedSourceIdTP = groupMerger.GetIdMapping(sourceRolePlayer.RolePlayerId);
						if( mappedSourceIdTP == this.Id )
							bTakesPart = true;
					}
		
					if( bTakesPart )
					{		
						bool bExists = true;
		        	    if( this.Store.ElementDirectory.FindElement(protoLink.ElementId) == null )
		        	        bExists = false;
							
						if( bExists && groupMerger.ProtoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
		        	    {
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkExistsOnMoveId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link exists although the operation = Move."));
						}
						
						#region Target
						// see if target element was copied
						DslEditorModeling::ModelProtoRolePlayer targetRolePlayer = protoLink.GetTargetRolePlayer(this.Store.DefaultPartition);
						DslEditorModeling::ModelProtoElement targetProtoElement = groupMerger.GetElementById(targetRolePlayer.RolePlayerId);
						System.Guid mappedTargetId = System.Guid.Empty;
						if( targetProtoElement != null )
						{
						 	mappedTargetId= groupMerger.GetIdMapping(targetRolePlayer.RolePlayerId);
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element
							mappedTargetId = targetRolePlayer.RolePlayerId;
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element with the same name as the previous element
							// TODO
						}
		
						if( mappedTargetId == System.Guid.Empty )
						{
							// log warning
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotCopiedId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not copied. Relationship: ShapeRelationshipNodeReferencesRelationshipShapeClass"));
						}
						else
						{
							DslModeling::ModelElement targetElement = this.Store.ElementDirectory.FindElement(mappedTargetId);
							if( targetElement == null )
							{
								// log error
		        	        	groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotFoundId",
					            	DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not found. Relationship: ShapeRelationshipNodeReferencesRelationshipShapeClass"));
							}
							else
							{
								bool bContinue = true;
		
								// check cardinalities, so we don't violate them by additing a new relationship
								if( DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Tum.PDE.LanguageDSL.ShapeRelationshipNodeReferencesRelationshipShapeClass.ShapeRelationshipNodeDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: ShapeRelationshipNodeReferencesRelationshipShapeClass"));
									
									bContinue = false;
								}
								if( DslModeling::DomainRoleInfo.GetLinkedElement(targetElement, global::Tum.PDE.LanguageDSL.ShapeRelationshipNodeReferencesRelationshipShapeClass.RelationshipShapeClassDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: ShapeRelationshipNodeReferencesRelationshipShapeClass"));
									
									bContinue = false;
								}
								
								if( bContinue )
								{
									// create property assignments
									DslModeling::PropertyAssignment[] propertyAssignemnts = protoLink.GetPropertyAssignments(this.Store.DefaultPartition, 
										System.Guid.NewGuid());
								
									// create role assignments
									DslModeling.RoleAssignment[] roleAssignments = new DslModeling.RoleAssignment[2];
		                	        roleAssignments[0] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.ShapeRelationshipNodeReferencesRelationshipShapeClass.ShapeRelationshipNodeDomainRoleId, this);
									roleAssignments[1] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.ShapeRelationshipNodeReferencesRelationshipShapeClass.RelationshipShapeClassDomainRoleId, targetElement);
									
									// create new relationship
									new global::Tum.PDE.LanguageDSL.ShapeRelationshipNodeReferencesRelationshipShapeClass(this.Store, roleAssignments, propertyAssignemnts);
								}
							}
						}
						#endregion
					}
				}
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to ShapeRelationshipNode because move is not allowed."));
				return;
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class DomainTypeBase : Tum.PDE.LanguageDSL.CopyPaste.IModelMergeElements
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public virtual bool ModelIsCopyAllowed()
		{
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public virtual bool ModelIsMoveAllowed()
		{
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public virtual bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public virtual DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public virtual DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public virtual void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			// DomainTypeReferencesPropertyGridEditor
			foreach (global::Tum.PDE.LanguageDSL.DomainTypeReferencesPropertyGridEditor link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.DomainTypeReferencesPropertyGridEditor>(this, global::Tum.PDE.LanguageDSL.DomainTypeReferencesPropertyGridEditor.DomainTypeDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewReferenceLink(protoLink);
			}
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public virtual bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return false;
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public virtual void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to DomainType because paste is not allowed."));
				return;
			}
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			DslModeling::DomainRelationshipInfo linkDomainInfo = null;
			if (protoLink != null)
			{
				linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(protoLink.DomainClassId);
			}
			else
			{
				// try getting the linkDomainInfo from name
				if( protoLink.Name == "DomainTypeReferencesPropertyGridEditor" && linkDomainInfo == null)
				{
					linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(DomainTypeReferencesPropertyGridEditor.DomainClassId);
				}
			}
			
			if( linkDomainInfo == null )
			{
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkDomainTypeMissing",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link can not be created as the corresponding domain type is missing."));
				return;
			}
		
				if (linkDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.DomainTypeReferencesPropertyGridEditor.DomainClassId)) 
				{
					// see if this element is taking part in this role
					bool bTakesPart = false;
					
					DslEditorModeling::ModelProtoRolePlayer sourceRolePlayer = protoLink.GetSourceRolePlayer(this.Store.DefaultPartition);
					DslEditorModeling::ModelProtoElement sourceProtoElement = groupMerger.GetElementById(sourceRolePlayer.RolePlayerId);
					System.Guid mappedSourceIdTP = System.Guid.Empty;
					if( sourceProtoElement != null )
					{
						mappedSourceIdTP = groupMerger.GetIdMapping(sourceRolePlayer.RolePlayerId);
						if( mappedSourceIdTP == this.Id )
							bTakesPart = true;
					}
		
					if( bTakesPart )
					{		
						bool bExists = true;
		        	    if( this.Store.ElementDirectory.FindElement(protoLink.ElementId) == null )
		        	        bExists = false;
							
						if( bExists && groupMerger.ProtoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
		        	    {
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkExistsOnMoveId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link exists although the operation = Move."));
						}
						
						#region Target
						// see if target element was copied
						DslEditorModeling::ModelProtoRolePlayer targetRolePlayer = protoLink.GetTargetRolePlayer(this.Store.DefaultPartition);
						DslEditorModeling::ModelProtoElement targetProtoElement = groupMerger.GetElementById(targetRolePlayer.RolePlayerId);
						System.Guid mappedTargetId = System.Guid.Empty;
						if( targetProtoElement != null )
						{
						 	mappedTargetId= groupMerger.GetIdMapping(targetRolePlayer.RolePlayerId);
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element
							mappedTargetId = targetRolePlayer.RolePlayerId;
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element with the same name as the previous element
							// TODO
						}
		
						if( mappedTargetId == System.Guid.Empty )
						{
							// log warning
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotCopiedId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not copied. Relationship: DomainTypeReferencesPropertyGridEditor"));
						}
						else
						{
							DslModeling::ModelElement targetElement = this.Store.ElementDirectory.FindElement(mappedTargetId);
							if( targetElement == null )
							{
								// log error
		        	        	groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotFoundId",
					            	DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not found. Relationship: DomainTypeReferencesPropertyGridEditor"));
							}
							else
							{
								bool bContinue = true;
		
								// check cardinalities, so we don't violate them by additing a new relationship
								if( DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Tum.PDE.LanguageDSL.DomainTypeReferencesPropertyGridEditor.DomainTypeDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: DomainTypeReferencesPropertyGridEditor"));
									
									bContinue = false;
								}
								
								if( bContinue )
								{
									// create property assignments
									DslModeling::PropertyAssignment[] propertyAssignemnts = protoLink.GetPropertyAssignments(this.Store.DefaultPartition, 
										System.Guid.NewGuid());
								
									// create role assignments
									DslModeling.RoleAssignment[] roleAssignments = new DslModeling.RoleAssignment[2];
		                	        roleAssignments[0] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.DomainTypeReferencesPropertyGridEditor.DomainTypeDomainRoleId, this);
									roleAssignments[1] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.DomainTypeReferencesPropertyGridEditor.PropertyGridEditorDomainRoleId, targetElement);
									
									// create new relationship
									new global::Tum.PDE.LanguageDSL.DomainTypeReferencesPropertyGridEditor(this.Store, roleAssignments, propertyAssignemnts);
								}
							}
						}
						#endregion
					}
				}
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to DomainType because move is not allowed."));
				return;
			}
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class ExternalTypeBase : DomainType
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to ExternalType because paste is not allowed."));
				return;
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to ExternalType because move is not allowed."));
				return;
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class DomainEnumerationBase : DomainType
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
			// DomainEnumerationHasLiterals
			foreach (global::Tum.PDE.LanguageDSL.DomainEnumerationHasLiterals link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.DomainEnumerationHasLiterals>(this, global::Tum.PDE.LanguageDSL.DomainEnumerationHasLiterals.DomainEnumerationDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewEmbeddingLink(protoLink);
				
				DslEditorModeling::ModelProtoElement protoElementRS = new DslEditorModeling::ModelProtoElement(link.EnumerationLiteral);
				protoGroup.AddNewElement(protoElementRS);
				
				// continue with target element
				if( link.EnumerationLiteral is DslEditorModeling::IModelMergeElements )
				{
					(link.EnumerationLiteral as DslEditorModeling::IModelMergeElements).ModelCreateMergeCopy(protoGroup);
				}
			}
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.EnumerationLiteral.DomainClassId)) 
				{
					if( protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
					{
						foreach (global::Tum.PDE.LanguageDSL.DomainEnumerationHasLiterals link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.DomainEnumerationHasLiterals>(this, global::Tum.PDE.LanguageDSL.DomainEnumerationHasLiterals.DomainEnumerationDomainRoleId))				
							if( link.EnumerationLiteral.Id == protoElement.ElementId )
								return false;
					}
					return true;
				}
			}
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to DomainEnumeration because paste is not allowed."));
				return;
			}
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.EnumerationLiteral.DomainClassId)) 
				{
					// get element id
					System.Guid newElementId = System.Guid.NewGuid();
					
					// create property assignments
					DslModeling::PropertyAssignment[] propertyAssignemnts = protoElement.GetPropertyAssignments(this.Store.DefaultPartition, newElementId);
					
		            // create the actual model element
					global::Tum.PDE.LanguageDSL.EnumerationLiteral element = null;			
					if( global::Tum.PDE.LanguageDSL.EnumerationLiteral.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.EnumerationLiteral(this.Store, propertyAssignemnts);
					if( element == null )
						throw new System.ArgumentNullException("Element is null in ModelMerge: " + elementDomainInfo.Name);
					
					if( !element.ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
					{
						// add warning message
						groupMerger.MergeResult.AddMessage(new DslEditorModeling.ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to DomainEnumeration because paste is not allowed."));
						
						element.Delete();
						return;
		 			}
					
					if( isRoot && groupMerger.ProtoGroup.Operation != DslEditorModeling.ModelProtoGroupOperation.Move)
					{
						//element.Name = "Copy of " + element.Name;
					}
					
					// update id mapping
					groupMerger.SetIdMapping(protoElement.ElementId, newElementId);
					
					// add child element
					GetRoleCollection<DslModeling::LinkedElementCollection<global::Tum.PDE.LanguageDSL.EnumerationLiteral>, global::Tum.PDE.LanguageDSL.EnumerationLiteral>(global::Tum.PDE.LanguageDSL.DomainEnumerationHasLiterals.DomainEnumerationDomainRoleId).Add(element);
		
					// continue with child elements (Embedding Relationship)
					System.Collections.Generic.List<DslEditorModeling::ModelProtoElement> embeddedProtoElements = groupMerger.GetEmbeddedElements(this.Store.DefaultPartition, protoElement);
					if( embeddedProtoElements.Count > 0 )
					{
						foreach (DslEditorModeling::ModelProtoElement p in embeddedProtoElements)
							(element as DslEditorModeling::IModelMergeElements).ModelMerge(p, groupMerger, false);
					}
				}
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to DomainEnumeration because move is not allowed."));
				return;
			}
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.EnumerationLiteral.DomainClassId)) 
				{
		            DslModeling::ModelElement modelElement = this.Store.ElementDirectory.FindElement(protoElement.ElementId);
		            if( modelElement == null )
		            {
		                groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementMissingOnMoveId",
				             DslEditorModeling.ModelValidationViolationType.Error, "Element exists although the operation = Move."));
		                return;
					}
		
					// change parent
					DslModeling::DomainRoleInfo.SetLinkedElement(modelElement, global::Tum.PDE.LanguageDSL.DomainEnumerationHasLiterals.EnumerationLiteralDomainRoleId, this);
					return;
				}
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class EnumerationLiteral : Tum.PDE.LanguageDSL.CopyPaste.IModelMergeElements
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public virtual bool ModelIsCopyAllowed()
		{
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public virtual bool ModelIsMoveAllowed()
		{
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public virtual bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public virtual DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public virtual DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public virtual void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public virtual bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return false;
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public virtual void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to EnumerationLiteral because paste is not allowed."));
				return;
			}
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to EnumerationLiteral because move is not allowed."));
				return;
			}
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class DiagramClassBase : Tum.PDE.LanguageDSL.CopyPaste.IModelMergeElements
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public virtual bool ModelIsCopyAllowed()
		{
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public virtual bool ModelIsMoveAllowed()
		{
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public virtual bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public virtual DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public virtual DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public virtual void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			// DiagramClassHasPresentationElements
			foreach (global::Tum.PDE.LanguageDSL.DiagramClassHasPresentationElements link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.DiagramClassHasPresentationElements>(this, global::Tum.PDE.LanguageDSL.DiagramClassHasPresentationElements.DiagramClassDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewEmbeddingLink(protoLink);
				
				DslEditorModeling::ModelProtoElement protoElementRS = new DslEditorModeling::ModelProtoElement(link.PresentationElementClass);
				protoGroup.AddNewElement(protoElementRS);
				
				// continue with target element
				if( link.PresentationElementClass is DslEditorModeling::IModelMergeElements )
				{
					(link.PresentationElementClass as DslEditorModeling::IModelMergeElements).ModelCreateMergeCopy(protoGroup);
				}
			}
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public virtual bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.PresentationElementClass.DomainClassId)) 
				{
					if( protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
					{
						foreach (global::Tum.PDE.LanguageDSL.DiagramClassHasPresentationElements link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.DiagramClassHasPresentationElements>(this, global::Tum.PDE.LanguageDSL.DiagramClassHasPresentationElements.DiagramClassDomainRoleId))				
							if( link.PresentationElementClass.Id == protoElement.ElementId )
								return false;
					}
					return true;
				}
			}
			return false;
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public virtual void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to DiagramClass because paste is not allowed."));
				return;
			}
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.PresentationElementClass.DomainClassId)) 
				{
					// get element id
					System.Guid newElementId = System.Guid.NewGuid();
					
					// create property assignments
					DslModeling::PropertyAssignment[] propertyAssignemnts = protoElement.GetPropertyAssignments(this.Store.DefaultPartition, newElementId);
					
		            // create the actual model element
					global::Tum.PDE.LanguageDSL.PresentationElementClass element = null;			
					if( global::Tum.PDE.LanguageDSL.RelationshipShapeClass.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.RelationshipShapeClass(this.Store, propertyAssignemnts);
					if( global::Tum.PDE.LanguageDSL.ShapeClass.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.ShapeClass(this.Store, propertyAssignemnts);
					if( global::Tum.PDE.LanguageDSL.MappingRelationshipShapeClass.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.MappingRelationshipShapeClass(this.Store, propertyAssignemnts);
					if( element == null )
						throw new System.ArgumentNullException("Element is null in ModelMerge: " + elementDomainInfo.Name);
					
					if( !element.ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
					{
						// add warning message
						groupMerger.MergeResult.AddMessage(new DslEditorModeling.ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to DiagramClass because paste is not allowed."));
						
						element.Delete();
						return;
		 			}
					
					if( isRoot && groupMerger.ProtoGroup.Operation != DslEditorModeling.ModelProtoGroupOperation.Move)
					{
						//element.Name = "Copy of " + element.Name;
					}
					
					// update id mapping
					groupMerger.SetIdMapping(protoElement.ElementId, newElementId);
					
					// add child element
					GetRoleCollection<DslModeling::LinkedElementCollection<global::Tum.PDE.LanguageDSL.PresentationElementClass>, global::Tum.PDE.LanguageDSL.PresentationElementClass>(global::Tum.PDE.LanguageDSL.DiagramClassHasPresentationElements.DiagramClassDomainRoleId).Add(element);
		
					// continue with child elements (Embedding Relationship)
					System.Collections.Generic.List<DslEditorModeling::ModelProtoElement> embeddedProtoElements = groupMerger.GetEmbeddedElements(this.Store.DefaultPartition, protoElement);
					if( embeddedProtoElements.Count > 0 )
					{
						foreach (DslEditorModeling::ModelProtoElement p in embeddedProtoElements)
							(element as DslEditorModeling::IModelMergeElements).ModelMerge(p, groupMerger, false);
					}
				}
			}
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			DslModeling::DomainRelationshipInfo linkDomainInfo = null;
			if (protoLink != null)
			{
				linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(protoLink.DomainClassId);
			}
			else
			{
				// try getting the linkDomainInfo from name
			}
			
			if( linkDomainInfo == null )
			{
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkDomainTypeMissing",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link can not be created as the corresponding domain type is missing."));
				return;
			}
		
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to DiagramClass because move is not allowed."));
				return;
			}
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.PresentationElementClass.DomainClassId)) 
				{
		            DslModeling::ModelElement modelElement = this.Store.ElementDirectory.FindElement(protoElement.ElementId);
		            if( modelElement == null )
		            {
		                groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementMissingOnMoveId",
				             DslEditorModeling.ModelValidationViolationType.Error, "Element exists although the operation = Move."));
		                return;
					}
		
					// change parent
					DslModeling::DomainRoleInfo.SetLinkedElement(modelElement, global::Tum.PDE.LanguageDSL.DiagramClassHasPresentationElements.PresentationElementClassDomainRoleId, this);
					return;
				}
			}
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class DiagramClassView : Tum.PDE.LanguageDSL.CopyPaste.IModelMergeElements
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public virtual bool ModelIsCopyAllowed()
		{
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public virtual bool ModelIsMoveAllowed()
		{
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public virtual bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public virtual DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public virtual DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public virtual void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			// DiagramClassViewReferencesDiagramClass
			foreach (global::Tum.PDE.LanguageDSL.DiagramClassViewReferencesDiagramClass link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.DiagramClassViewReferencesDiagramClass>(this, global::Tum.PDE.LanguageDSL.DiagramClassViewReferencesDiagramClass.DiagramClassViewDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewReferenceLink(protoLink);
			}
			// DiagramClassViewHasRootDiagramNodes
			foreach (global::Tum.PDE.LanguageDSL.DiagramClassViewHasRootDiagramNodes link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.DiagramClassViewHasRootDiagramNodes>(this, global::Tum.PDE.LanguageDSL.DiagramClassViewHasRootDiagramNodes.DiagramClassViewDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewEmbeddingLink(protoLink);
				
				DslEditorModeling::ModelProtoElement protoElementRS = new DslEditorModeling::ModelProtoElement(link.RootDiagramNode);
				protoGroup.AddNewElement(protoElementRS);
				
				// continue with target element
				if( link.RootDiagramNode is DslEditorModeling::IModelMergeElements )
				{
					(link.RootDiagramNode as DslEditorModeling::IModelMergeElements).ModelCreateMergeCopy(protoGroup);
				}
			}
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public virtual bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.RootDiagramNode.DomainClassId)) 
				{
					if( protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
					{
						foreach (global::Tum.PDE.LanguageDSL.DiagramClassViewHasRootDiagramNodes link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.DiagramClassViewHasRootDiagramNodes>(this, global::Tum.PDE.LanguageDSL.DiagramClassViewHasRootDiagramNodes.DiagramClassViewDomainRoleId))				
							if( link.RootDiagramNode.Id == protoElement.ElementId )
								return false;
					}
					return true;
				}
			}
			return false;
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public virtual void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to DiagramClassView because paste is not allowed."));
				return;
			}
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.RootDiagramNode.DomainClassId)) 
				{
					// get element id
					System.Guid newElementId = System.Guid.NewGuid();
					
					// create property assignments
					DslModeling::PropertyAssignment[] propertyAssignemnts = protoElement.GetPropertyAssignments(this.Store.DefaultPartition, newElementId);
					
		            // create the actual model element
					global::Tum.PDE.LanguageDSL.RootDiagramNode element = null;			
					if( global::Tum.PDE.LanguageDSL.RootDiagramNode.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.RootDiagramNode(this.Store, propertyAssignemnts);
					if( element == null )
						throw new System.ArgumentNullException("Element is null in ModelMerge: " + elementDomainInfo.Name);
					
					if( !element.ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
					{
						// add warning message
						groupMerger.MergeResult.AddMessage(new DslEditorModeling.ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to DiagramClassView because paste is not allowed."));
						
						element.Delete();
						return;
		 			}
					
					if( isRoot && groupMerger.ProtoGroup.Operation != DslEditorModeling.ModelProtoGroupOperation.Move)
					{
						//element.Name = "Copy of " + element.Name;
					}
					
					// update id mapping
					groupMerger.SetIdMapping(protoElement.ElementId, newElementId);
					
					// add child element
					GetRoleCollection<DslModeling::LinkedElementCollection<global::Tum.PDE.LanguageDSL.RootDiagramNode>, global::Tum.PDE.LanguageDSL.RootDiagramNode>(global::Tum.PDE.LanguageDSL.DiagramClassViewHasRootDiagramNodes.DiagramClassViewDomainRoleId).Add(element);
		
					// continue with child elements (Embedding Relationship)
					System.Collections.Generic.List<DslEditorModeling::ModelProtoElement> embeddedProtoElements = groupMerger.GetEmbeddedElements(this.Store.DefaultPartition, protoElement);
					if( embeddedProtoElements.Count > 0 )
					{
						foreach (DslEditorModeling::ModelProtoElement p in embeddedProtoElements)
							(element as DslEditorModeling::IModelMergeElements).ModelMerge(p, groupMerger, false);
					}
				}
			}
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			DslModeling::DomainRelationshipInfo linkDomainInfo = null;
			if (protoLink != null)
			{
				linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(protoLink.DomainClassId);
			}
			else
			{
				// try getting the linkDomainInfo from name
				if( protoLink.Name == "DiagramClassViewReferencesDiagramClass" && linkDomainInfo == null)
				{
					linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(DiagramClassViewReferencesDiagramClass.DomainClassId);
				}
			}
			
			if( linkDomainInfo == null )
			{
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkDomainTypeMissing",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link can not be created as the corresponding domain type is missing."));
				return;
			}
		
				if (linkDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.DiagramClassViewReferencesDiagramClass.DomainClassId)) 
				{
					// see if this element is taking part in this role
					bool bTakesPart = false;
					
					DslEditorModeling::ModelProtoRolePlayer sourceRolePlayer = protoLink.GetSourceRolePlayer(this.Store.DefaultPartition);
					DslEditorModeling::ModelProtoElement sourceProtoElement = groupMerger.GetElementById(sourceRolePlayer.RolePlayerId);
					System.Guid mappedSourceIdTP = System.Guid.Empty;
					if( sourceProtoElement != null )
					{
						mappedSourceIdTP = groupMerger.GetIdMapping(sourceRolePlayer.RolePlayerId);
						if( mappedSourceIdTP == this.Id )
							bTakesPart = true;
					}
		
					if( bTakesPart )
					{		
						bool bExists = true;
		        	    if( this.Store.ElementDirectory.FindElement(protoLink.ElementId) == null )
		        	        bExists = false;
							
						if( bExists && groupMerger.ProtoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
		        	    {
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkExistsOnMoveId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link exists although the operation = Move."));
						}
						
						#region Target
						// see if target element was copied
						DslEditorModeling::ModelProtoRolePlayer targetRolePlayer = protoLink.GetTargetRolePlayer(this.Store.DefaultPartition);
						DslEditorModeling::ModelProtoElement targetProtoElement = groupMerger.GetElementById(targetRolePlayer.RolePlayerId);
						System.Guid mappedTargetId = System.Guid.Empty;
						if( targetProtoElement != null )
						{
						 	mappedTargetId= groupMerger.GetIdMapping(targetRolePlayer.RolePlayerId);
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element
							mappedTargetId = targetRolePlayer.RolePlayerId;
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element with the same name as the previous element
							// TODO
						}
		
						if( mappedTargetId == System.Guid.Empty )
						{
							// log warning
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotCopiedId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not copied. Relationship: DiagramClassViewReferencesDiagramClass"));
						}
						else
						{
							DslModeling::ModelElement targetElement = this.Store.ElementDirectory.FindElement(mappedTargetId);
							if( targetElement == null )
							{
								// log error
		        	        	groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotFoundId",
					            	DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not found. Relationship: DiagramClassViewReferencesDiagramClass"));
							}
							else
							{
								bool bContinue = true;
		
								// check cardinalities, so we don't violate them by additing a new relationship
								if( DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Tum.PDE.LanguageDSL.DiagramClassViewReferencesDiagramClass.DiagramClassViewDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: DiagramClassViewReferencesDiagramClass"));
									
									bContinue = false;
								}
								if( DslModeling::DomainRoleInfo.GetLinkedElement(targetElement, global::Tum.PDE.LanguageDSL.DiagramClassViewReferencesDiagramClass.DiagramClassDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: DiagramClassViewReferencesDiagramClass"));
									
									bContinue = false;
								}
								
								if( bContinue )
								{
									// create property assignments
									DslModeling::PropertyAssignment[] propertyAssignemnts = protoLink.GetPropertyAssignments(this.Store.DefaultPartition, 
										System.Guid.NewGuid());
								
									// create role assignments
									DslModeling.RoleAssignment[] roleAssignments = new DslModeling.RoleAssignment[2];
		                	        roleAssignments[0] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.DiagramClassViewReferencesDiagramClass.DiagramClassViewDomainRoleId, this);
									roleAssignments[1] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.DiagramClassViewReferencesDiagramClass.DiagramClassDomainRoleId, targetElement);
									
									// create new relationship
									new global::Tum.PDE.LanguageDSL.DiagramClassViewReferencesDiagramClass(this.Store, roleAssignments, propertyAssignemnts);
								}
							}
						}
						#endregion
					}
				}
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to DiagramClassView because move is not allowed."));
				return;
			}
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.RootDiagramNode.DomainClassId)) 
				{
		            DslModeling::ModelElement modelElement = this.Store.ElementDirectory.FindElement(protoElement.ElementId);
		            if( modelElement == null )
		            {
		                groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementMissingOnMoveId",
				             DslEditorModeling.ModelValidationViolationType.Error, "Element exists although the operation = Move."));
		                return;
					}
		
					// change parent
					DslModeling::DomainRoleInfo.SetLinkedElement(modelElement, global::Tum.PDE.LanguageDSL.DiagramClassViewHasRootDiagramNodes.RootDiagramNodeDomainRoleId, this);
					return;
				}
			}
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class PresentationElementClass : AttributedDomainElement
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to PresentationElementClass because paste is not allowed."));
				return;
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			DslModeling::DomainRelationshipInfo linkDomainInfo = null;
			if (protoLink != null)
			{
				linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(protoLink.DomainClassId);
			}
			else
			{
				// try getting the linkDomainInfo from name
			}
			
			if( linkDomainInfo == null )
			{
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkDomainTypeMissing",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link can not be created as the corresponding domain type is missing."));
				return;
			}
		
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to PresentationElementClass because move is not allowed."));
				return;
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class ShapeClassBase : PresentationDomainClassElement
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
			// ShapeClassReferencesBaseShape
			foreach (global::Tum.PDE.LanguageDSL.ShapeClassReferencesBaseShape link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.ShapeClassReferencesBaseShape>(this, global::Tum.PDE.LanguageDSL.ShapeClassReferencesBaseShape.DerivedShapeDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewReferenceLink(protoLink);
			}
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to ShapeClass because paste is not allowed."));
				return;
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			DslModeling::DomainRelationshipInfo linkDomainInfo = null;
			if (protoLink != null)
			{
				linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(protoLink.DomainClassId);
			}
			else
			{
				// try getting the linkDomainInfo from name
				if( protoLink.Name == "ShapeClassReferencesChildren" && linkDomainInfo == null)
				{
					linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(ShapeClassReferencesChildren.DomainClassId);
				}
				if( protoLink.Name == "ShapeClassReferencesBaseShape" && linkDomainInfo == null)
				{
					linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(ShapeClassReferencesBaseShape.DomainClassId);
				}
			}
			
			if( linkDomainInfo == null )
			{
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkDomainTypeMissing",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link can not be created as the corresponding domain type is missing."));
				return;
			}
		
				if (linkDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.ShapeClassReferencesChildren.DomainClassId)) 
				{
					// see if this element is taking part in this role
					bool bTakesPart = false;
					
					DslEditorModeling::ModelProtoRolePlayer sourceRolePlayer = protoLink.GetSourceRolePlayer(this.Store.DefaultPartition);
					DslEditorModeling::ModelProtoElement sourceProtoElement = groupMerger.GetElementById(sourceRolePlayer.RolePlayerId);
					System.Guid mappedSourceIdTP = System.Guid.Empty;
					if( sourceProtoElement != null )
					{
						mappedSourceIdTP = groupMerger.GetIdMapping(sourceRolePlayer.RolePlayerId);
						if( mappedSourceIdTP == this.Id )
							bTakesPart = true;
					}
		
					if( bTakesPart )
					{		
						bool bExists = true;
		        	    if( this.Store.ElementDirectory.FindElement(protoLink.ElementId) == null )
		        	        bExists = false;
							
						if( bExists && groupMerger.ProtoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
		        	    {
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkExistsOnMoveId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link exists although the operation = Move."));
						}
						
						#region Target
						// see if target element was copied
						DslEditorModeling::ModelProtoRolePlayer targetRolePlayer = protoLink.GetTargetRolePlayer(this.Store.DefaultPartition);
						DslEditorModeling::ModelProtoElement targetProtoElement = groupMerger.GetElementById(targetRolePlayer.RolePlayerId);
						System.Guid mappedTargetId = System.Guid.Empty;
						if( targetProtoElement != null )
						{
						 	mappedTargetId= groupMerger.GetIdMapping(targetRolePlayer.RolePlayerId);
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element
							mappedTargetId = targetRolePlayer.RolePlayerId;
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element with the same name as the previous element
							// TODO
						}
		
						if( mappedTargetId == System.Guid.Empty )
						{
							// log warning
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotCopiedId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not copied. Relationship: ShapeClassReferencesChildren"));
						}
						else
						{
							DslModeling::ModelElement targetElement = this.Store.ElementDirectory.FindElement(mappedTargetId);
							if( targetElement == null )
							{
								// log error
		        	        	groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotFoundId",
					            	DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not found. Relationship: ShapeClassReferencesChildren"));
							}
							else
							{
								bool bContinue = true;
		
								// check cardinalities, so we don't violate them by additing a new relationship
								if( DslModeling::DomainRoleInfo.GetLinkedElement(targetElement, global::Tum.PDE.LanguageDSL.ShapeClassReferencesChildren.ChildDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: ShapeClassReferencesChildren"));
									
									bContinue = false;
								}
								
								if( bContinue )
								{
									// create property assignments
									DslModeling::PropertyAssignment[] propertyAssignemnts = protoLink.GetPropertyAssignments(this.Store.DefaultPartition, 
										System.Guid.NewGuid());
								
									// create role assignments
									DslModeling.RoleAssignment[] roleAssignments = new DslModeling.RoleAssignment[2];
		                	        roleAssignments[0] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.ShapeClassReferencesChildren.ParentDomainRoleId, this);
									roleAssignments[1] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.ShapeClassReferencesChildren.ChildDomainRoleId, targetElement);
									
									// create new relationship
									new global::Tum.PDE.LanguageDSL.ShapeClassReferencesChildren(this.Store, roleAssignments, propertyAssignemnts);
								}
							}
						}
						#endregion
					}
				}
				if (linkDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.ShapeClassReferencesBaseShape.DomainClassId)) 
				{
					// see if this element is taking part in this role
					bool bTakesPart = false;
					
					DslEditorModeling::ModelProtoRolePlayer sourceRolePlayer = protoLink.GetSourceRolePlayer(this.Store.DefaultPartition);
					DslEditorModeling::ModelProtoElement sourceProtoElement = groupMerger.GetElementById(sourceRolePlayer.RolePlayerId);
					System.Guid mappedSourceIdTP = System.Guid.Empty;
					if( sourceProtoElement != null )
					{
						mappedSourceIdTP = groupMerger.GetIdMapping(sourceRolePlayer.RolePlayerId);
						if( mappedSourceIdTP == this.Id )
							bTakesPart = true;
					}
		
					if( bTakesPart )
					{		
						bool bExists = true;
		        	    if( this.Store.ElementDirectory.FindElement(protoLink.ElementId) == null )
		        	        bExists = false;
							
						if( bExists && groupMerger.ProtoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
		        	    {
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkExistsOnMoveId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link exists although the operation = Move."));
						}
						
						#region Target
						// see if target element was copied
						DslEditorModeling::ModelProtoRolePlayer targetRolePlayer = protoLink.GetTargetRolePlayer(this.Store.DefaultPartition);
						DslEditorModeling::ModelProtoElement targetProtoElement = groupMerger.GetElementById(targetRolePlayer.RolePlayerId);
						System.Guid mappedTargetId = System.Guid.Empty;
						if( targetProtoElement != null )
						{
						 	mappedTargetId= groupMerger.GetIdMapping(targetRolePlayer.RolePlayerId);
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element
							mappedTargetId = targetRolePlayer.RolePlayerId;
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element with the same name as the previous element
							// TODO
						}
		
						if( mappedTargetId == System.Guid.Empty )
						{
							// log warning
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotCopiedId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not copied. Relationship: ShapeClassReferencesBaseShape"));
						}
						else
						{
							DslModeling::ModelElement targetElement = this.Store.ElementDirectory.FindElement(mappedTargetId);
							if( targetElement == null )
							{
								// log error
		        	        	groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotFoundId",
					            	DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not found. Relationship: ShapeClassReferencesBaseShape"));
							}
							else
							{
								bool bContinue = true;
		
								// check cardinalities, so we don't violate them by additing a new relationship
								if( DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Tum.PDE.LanguageDSL.ShapeClassReferencesBaseShape.DerivedShapeDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: ShapeClassReferencesBaseShape"));
									
									bContinue = false;
								}
								
								if( bContinue )
								{
									// create property assignments
									DslModeling::PropertyAssignment[] propertyAssignemnts = protoLink.GetPropertyAssignments(this.Store.DefaultPartition, 
										System.Guid.NewGuid());
								
									// create role assignments
									DslModeling.RoleAssignment[] roleAssignments = new DslModeling.RoleAssignment[2];
		                	        roleAssignments[0] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.ShapeClassReferencesBaseShape.DerivedShapeDomainRoleId, this);
									roleAssignments[1] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.ShapeClassReferencesBaseShape.BaseShapeDomainRoleId, targetElement);
									
									// create new relationship
									new global::Tum.PDE.LanguageDSL.ShapeClassReferencesBaseShape(this.Store, roleAssignments, propertyAssignemnts);
								}
							}
						}
						#endregion
					}
				}
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to ShapeClass because move is not allowed."));
				return;
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class RelationshipShapeClassBase : PresentationElementClass
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
			// RelationshipShapeClassReferencesReferenceRelationship
			foreach (global::Tum.PDE.LanguageDSL.RelationshipShapeClassReferencesReferenceRelationship link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.RelationshipShapeClassReferencesReferenceRelationship>(this, global::Tum.PDE.LanguageDSL.RelationshipShapeClassReferencesReferenceRelationship.RelationshipShapeClassDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewReferenceLink(protoLink);
			}
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to RelationshipShapeClass because paste is not allowed."));
				return;
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			DslModeling::DomainRelationshipInfo linkDomainInfo = null;
			if (protoLink != null)
			{
				linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(protoLink.DomainClassId);
			}
			else
			{
				// try getting the linkDomainInfo from name
				if( protoLink.Name == "RelationshipShapeClassReferencesReferenceRelationship" && linkDomainInfo == null)
				{
					linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(RelationshipShapeClassReferencesReferenceRelationship.DomainClassId);
				}
			}
			
			if( linkDomainInfo == null )
			{
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkDomainTypeMissing",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link can not be created as the corresponding domain type is missing."));
				return;
			}
		
				if (linkDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.RelationshipShapeClassReferencesReferenceRelationship.DomainClassId)) 
				{
					// see if this element is taking part in this role
					bool bTakesPart = false;
					
					DslEditorModeling::ModelProtoRolePlayer sourceRolePlayer = protoLink.GetSourceRolePlayer(this.Store.DefaultPartition);
					DslEditorModeling::ModelProtoElement sourceProtoElement = groupMerger.GetElementById(sourceRolePlayer.RolePlayerId);
					System.Guid mappedSourceIdTP = System.Guid.Empty;
					if( sourceProtoElement != null )
					{
						mappedSourceIdTP = groupMerger.GetIdMapping(sourceRolePlayer.RolePlayerId);
						if( mappedSourceIdTP == this.Id )
							bTakesPart = true;
					}
		
					if( bTakesPart )
					{		
						bool bExists = true;
		        	    if( this.Store.ElementDirectory.FindElement(protoLink.ElementId) == null )
		        	        bExists = false;
							
						if( bExists && groupMerger.ProtoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
		        	    {
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkExistsOnMoveId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link exists although the operation = Move."));
						}
						
						#region Target
						// see if target element was copied
						DslEditorModeling::ModelProtoRolePlayer targetRolePlayer = protoLink.GetTargetRolePlayer(this.Store.DefaultPartition);
						DslEditorModeling::ModelProtoElement targetProtoElement = groupMerger.GetElementById(targetRolePlayer.RolePlayerId);
						System.Guid mappedTargetId = System.Guid.Empty;
						if( targetProtoElement != null )
						{
						 	mappedTargetId= groupMerger.GetIdMapping(targetRolePlayer.RolePlayerId);
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element
							mappedTargetId = targetRolePlayer.RolePlayerId;
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element with the same name as the previous element
							// TODO
						}
		
						if( mappedTargetId == System.Guid.Empty )
						{
							// log warning
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotCopiedId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not copied. Relationship: RelationshipShapeClassReferencesReferenceRelationship"));
						}
						else
						{
							DslModeling::ModelElement targetElement = this.Store.ElementDirectory.FindElement(mappedTargetId);
							if( targetElement == null )
							{
								// log error
		        	        	groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotFoundId",
					            	DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not found. Relationship: RelationshipShapeClassReferencesReferenceRelationship"));
							}
							else
							{
								bool bContinue = true;
		
								// check cardinalities, so we don't violate them by additing a new relationship
								if( DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Tum.PDE.LanguageDSL.RelationshipShapeClassReferencesReferenceRelationship.RelationshipShapeClassDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: RelationshipShapeClassReferencesReferenceRelationship"));
									
									bContinue = false;
								}
								
								if( bContinue )
								{
									// create property assignments
									DslModeling::PropertyAssignment[] propertyAssignemnts = protoLink.GetPropertyAssignments(this.Store.DefaultPartition, 
										System.Guid.NewGuid());
								
									// create role assignments
									DslModeling.RoleAssignment[] roleAssignments = new DslModeling.RoleAssignment[2];
		                	        roleAssignments[0] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.RelationshipShapeClassReferencesReferenceRelationship.RelationshipShapeClassDomainRoleId, this);
									roleAssignments[1] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.RelationshipShapeClassReferencesReferenceRelationship.DomainRelationshipDomainRoleId, targetElement);
									
									// create new relationship
									new global::Tum.PDE.LanguageDSL.RelationshipShapeClassReferencesReferenceRelationship(this.Store, roleAssignments, propertyAssignemnts);
								}
							}
						}
						#endregion
					}
				}
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to RelationshipShapeClass because move is not allowed."));
				return;
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class GeneratedDomainElement : NamedDomainElement
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to GeneratedDomainElement because paste is not allowed."));
				return;
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to GeneratedDomainElement because move is not allowed."));
				return;
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class RootDiagramNode : EmbeddingDiagramNode
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to RootDiagramNode because paste is not allowed."));
				return;
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to RootDiagramNode because move is not allowed."));
				return;
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class EmbeddingDiagramNodeBase : DiagramTreeNode
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
			// EmbeddingDiagramNodeHasEmbeddingDiagramNodes
			foreach (global::Tum.PDE.LanguageDSL.EmbeddingDiagramNodeHasEmbeddingDiagramNodes link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.EmbeddingDiagramNodeHasEmbeddingDiagramNodes>(this, global::Tum.PDE.LanguageDSL.EmbeddingDiagramNodeHasEmbeddingDiagramNodes.SourceEmbeddingDiagramNodeDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewEmbeddingLink(protoLink);
				
				DslEditorModeling::ModelProtoElement protoElementRS = new DslEditorModeling::ModelProtoElement(link.TargetEmbeddingDiagramNode);
				protoGroup.AddNewElement(protoElementRS);
				
				// continue with target element
				if( link.TargetEmbeddingDiagramNode is DslEditorModeling::IModelMergeElements )
				{
					(link.TargetEmbeddingDiagramNode as DslEditorModeling::IModelMergeElements).ModelCreateMergeCopy(protoGroup);
				}
			}
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.EmbeddingDiagramNode.DomainClassId)) 
				{
					if( protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
					{
						foreach (global::Tum.PDE.LanguageDSL.EmbeddingDiagramNodeHasEmbeddingDiagramNodes link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.EmbeddingDiagramNodeHasEmbeddingDiagramNodes>(this, global::Tum.PDE.LanguageDSL.EmbeddingDiagramNodeHasEmbeddingDiagramNodes.SourceEmbeddingDiagramNodeDomainRoleId))				
							if( link.TargetEmbeddingDiagramNode.Id == protoElement.ElementId )
								return false;
					}
					return true;
				}
			}
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to EmbeddingDiagramNode because paste is not allowed."));
				return;
			}
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.EmbeddingDiagramNode.DomainClassId)) 
				{
					// get element id
					System.Guid newElementId = System.Guid.NewGuid();
					
					// create property assignments
					DslModeling::PropertyAssignment[] propertyAssignemnts = protoElement.GetPropertyAssignments(this.Store.DefaultPartition, newElementId);
					
		            // create the actual model element
					global::Tum.PDE.LanguageDSL.EmbeddingDiagramNode element = null;			
					if( global::Tum.PDE.LanguageDSL.EmbeddingDiagramNode.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.EmbeddingDiagramNode(this.Store, propertyAssignemnts);
					if( global::Tum.PDE.LanguageDSL.RootDiagramNode.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.RootDiagramNode(this.Store, propertyAssignemnts);
					if( element == null )
						throw new System.ArgumentNullException("Element is null in ModelMerge: " + elementDomainInfo.Name);
					
					if( !element.ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
					{
						// add warning message
						groupMerger.MergeResult.AddMessage(new DslEditorModeling.ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to EmbeddingDiagramNode because paste is not allowed."));
						
						element.Delete();
						return;
		 			}
					
					if( isRoot && groupMerger.ProtoGroup.Operation != DslEditorModeling.ModelProtoGroupOperation.Move)
					{
						//element.Name = "Copy of " + element.Name;
					}
					
					// update id mapping
					groupMerger.SetIdMapping(protoElement.ElementId, newElementId);
					
					// add child element
					GetRoleCollection<DslModeling::LinkedElementCollection<global::Tum.PDE.LanguageDSL.EmbeddingDiagramNode>, global::Tum.PDE.LanguageDSL.EmbeddingDiagramNode>(global::Tum.PDE.LanguageDSL.EmbeddingDiagramNodeHasEmbeddingDiagramNodes.SourceEmbeddingDiagramNodeDomainRoleId).Add(element);
		
					// continue with child elements (Embedding Relationship)
					System.Collections.Generic.List<DslEditorModeling::ModelProtoElement> embeddedProtoElements = groupMerger.GetEmbeddedElements(this.Store.DefaultPartition, protoElement);
					if( embeddedProtoElements.Count > 0 )
					{
						foreach (DslEditorModeling::ModelProtoElement p in embeddedProtoElements)
							(element as DslEditorModeling::IModelMergeElements).ModelMerge(p, groupMerger, false);
					}
				}
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to EmbeddingDiagramNode because move is not allowed."));
				return;
			}
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.EmbeddingDiagramNode.DomainClassId)) 
				{
		            DslModeling::ModelElement modelElement = this.Store.ElementDirectory.FindElement(protoElement.ElementId);
		            if( modelElement == null )
		            {
		                groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementMissingOnMoveId",
				             DslEditorModeling.ModelValidationViolationType.Error, "Element exists although the operation = Move."));
		                return;
					}
		
					// change parent
					DslModeling::DomainRoleInfo.SetLinkedElement(modelElement, global::Tum.PDE.LanguageDSL.EmbeddingDiagramNodeHasEmbeddingDiagramNodes.TargetEmbeddingDiagramNodeDomainRoleId, this);
					return;
				}
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class DiagramTreeNode : Tum.PDE.LanguageDSL.CopyPaste.IModelMergeElements
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public virtual bool ModelIsCopyAllowed()
		{
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public virtual bool ModelIsMoveAllowed()
		{
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public virtual bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public virtual DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public virtual DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public virtual void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			// DiagramTreeNodeReferencesPresentationElementClass
			foreach (global::Tum.PDE.LanguageDSL.DiagramTreeNodeReferencesPresentationElementClass link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.DiagramTreeNodeReferencesPresentationElementClass>(this, global::Tum.PDE.LanguageDSL.DiagramTreeNodeReferencesPresentationElementClass.DiagramTreeNodeDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewReferenceLink(protoLink);
			}
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public virtual bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return false;
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public virtual void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to DiagramTreeNode because paste is not allowed."));
				return;
			}
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			DslModeling::DomainRelationshipInfo linkDomainInfo = null;
			if (protoLink != null)
			{
				linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(protoLink.DomainClassId);
			}
			else
			{
				// try getting the linkDomainInfo from name
				if( protoLink.Name == "DiagramTreeNodeReferencesPresentationElementClass" && linkDomainInfo == null)
				{
					linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(DiagramTreeNodeReferencesPresentationElementClass.DomainClassId);
				}
			}
			
			if( linkDomainInfo == null )
			{
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkDomainTypeMissing",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link can not be created as the corresponding domain type is missing."));
				return;
			}
		
				if (linkDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.DiagramTreeNodeReferencesPresentationElementClass.DomainClassId)) 
				{
					// see if this element is taking part in this role
					bool bTakesPart = false;
					
					DslEditorModeling::ModelProtoRolePlayer sourceRolePlayer = protoLink.GetSourceRolePlayer(this.Store.DefaultPartition);
					DslEditorModeling::ModelProtoElement sourceProtoElement = groupMerger.GetElementById(sourceRolePlayer.RolePlayerId);
					System.Guid mappedSourceIdTP = System.Guid.Empty;
					if( sourceProtoElement != null )
					{
						mappedSourceIdTP = groupMerger.GetIdMapping(sourceRolePlayer.RolePlayerId);
						if( mappedSourceIdTP == this.Id )
							bTakesPart = true;
					}
		
					if( bTakesPart )
					{		
						bool bExists = true;
		        	    if( this.Store.ElementDirectory.FindElement(protoLink.ElementId) == null )
		        	        bExists = false;
							
						if( bExists && groupMerger.ProtoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
		        	    {
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkExistsOnMoveId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link exists although the operation = Move."));
						}
						
						#region Target
						// see if target element was copied
						DslEditorModeling::ModelProtoRolePlayer targetRolePlayer = protoLink.GetTargetRolePlayer(this.Store.DefaultPartition);
						DslEditorModeling::ModelProtoElement targetProtoElement = groupMerger.GetElementById(targetRolePlayer.RolePlayerId);
						System.Guid mappedTargetId = System.Guid.Empty;
						if( targetProtoElement != null )
						{
						 	mappedTargetId= groupMerger.GetIdMapping(targetRolePlayer.RolePlayerId);
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element
							mappedTargetId = targetRolePlayer.RolePlayerId;
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element with the same name as the previous element
							// TODO
						}
		
						if( mappedTargetId == System.Guid.Empty )
						{
							// log warning
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotCopiedId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not copied. Relationship: DiagramTreeNodeReferencesPresentationElementClass"));
						}
						else
						{
							DslModeling::ModelElement targetElement = this.Store.ElementDirectory.FindElement(mappedTargetId);
							if( targetElement == null )
							{
								// log error
		        	        	groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotFoundId",
					            	DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not found. Relationship: DiagramTreeNodeReferencesPresentationElementClass"));
							}
							else
							{
								bool bContinue = true;
		
								// check cardinalities, so we don't violate them by additing a new relationship
								if( DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Tum.PDE.LanguageDSL.DiagramTreeNodeReferencesPresentationElementClass.DiagramTreeNodeDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: DiagramTreeNodeReferencesPresentationElementClass"));
									
									bContinue = false;
								}
								if( DslModeling::DomainRoleInfo.GetLinkedElement(targetElement, global::Tum.PDE.LanguageDSL.DiagramTreeNodeReferencesPresentationElementClass.PresentationElementClassDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: DiagramTreeNodeReferencesPresentationElementClass"));
									
									bContinue = false;
								}
								
								if( bContinue )
								{
									// create property assignments
									DslModeling::PropertyAssignment[] propertyAssignemnts = protoLink.GetPropertyAssignments(this.Store.DefaultPartition, 
										System.Guid.NewGuid());
								
									// create role assignments
									DslModeling.RoleAssignment[] roleAssignments = new DslModeling.RoleAssignment[2];
		                	        roleAssignments[0] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.DiagramTreeNodeReferencesPresentationElementClass.DiagramTreeNodeDomainRoleId, this);
									roleAssignments[1] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.DiagramTreeNodeReferencesPresentationElementClass.PresentationElementClassDomainRoleId, targetElement);
									
									// create new relationship
									new global::Tum.PDE.LanguageDSL.DiagramTreeNodeReferencesPresentationElementClass(this.Store, roleAssignments, propertyAssignemnts);
								}
							}
						}
						#endregion
					}
				}
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to DiagramTreeNode because move is not allowed."));
				return;
			}
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class SerializationModelBase : Tum.PDE.LanguageDSL.CopyPaste.IModelMergeElements
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public virtual bool ModelIsCopyAllowed()
		{
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public virtual bool ModelIsMoveAllowed()
		{
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public virtual bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public virtual DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public virtual DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public virtual void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			// SerializationModelHasSerializedDomainModel
			foreach (global::Tum.PDE.LanguageDSL.SerializationModelHasSerializedDomainModel link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.SerializationModelHasSerializedDomainModel>(this, global::Tum.PDE.LanguageDSL.SerializationModelHasSerializedDomainModel.SerializationModelDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewEmbeddingLink(protoLink);
				
				DslEditorModeling::ModelProtoElement protoElementRS = new DslEditorModeling::ModelProtoElement(link.SerializedDomainModel);
				protoGroup.AddNewElement(protoElementRS);
				
				// continue with target element
				if( link.SerializedDomainModel is DslEditorModeling::IModelMergeElements )
				{
					(link.SerializedDomainModel as DslEditorModeling::IModelMergeElements).ModelCreateMergeCopy(protoGroup);
				}
			}
			// SerializationModelHasChildren
			foreach (global::Tum.PDE.LanguageDSL.SerializationModelHasChildren link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.SerializationModelHasChildren>(this, global::Tum.PDE.LanguageDSL.SerializationModelHasChildren.SerializationModelDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewEmbeddingLink(protoLink);
				
				DslEditorModeling::ModelProtoElement protoElementRS = new DslEditorModeling::ModelProtoElement(link.SerializationClass);
				protoGroup.AddNewElement(protoElementRS);
				
				// continue with target element
				if( link.SerializationClass is DslEditorModeling::IModelMergeElements )
				{
					(link.SerializationClass as DslEditorModeling::IModelMergeElements).ModelCreateMergeCopy(protoGroup);
				}
			}
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public virtual bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.SerializedDomainModel.DomainClassId)) 
				{
					// Check that creating a link with this path doesn't cause multiplicity overflow: SerializationModelHasSerializedDomainModel.SerializedDomainModel
					if( DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Tum.PDE.LanguageDSL.SerializationModelHasSerializedDomainModel.SerializationModelDomainRoleId) != null )
						return false;
					return true;
				}
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.SerializationClass.DomainClassId)) 
				{
					if( protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
					{
						foreach (global::Tum.PDE.LanguageDSL.SerializationModelHasChildren link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.SerializationModelHasChildren>(this, global::Tum.PDE.LanguageDSL.SerializationModelHasChildren.SerializationModelDomainRoleId))				
							if( link.SerializationClass.Id == protoElement.ElementId )
								return false;
					}
					return true;
				}
			}
			return false;
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public virtual void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to SerializationModel because paste is not allowed."));
				return;
			}
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.SerializedDomainModel.DomainClassId)) 
				{
					// get element id
					System.Guid newElementId = System.Guid.NewGuid();
					
					// create property assignments
					DslModeling::PropertyAssignment[] propertyAssignemnts = protoElement.GetPropertyAssignments(this.Store.DefaultPartition, newElementId);
					
		            // create the actual model element
					global::Tum.PDE.LanguageDSL.SerializedDomainModel element = null;			
					if( global::Tum.PDE.LanguageDSL.SerializedDomainModel.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.SerializedDomainModel(this.Store, propertyAssignemnts);
					if( element == null )
						throw new System.ArgumentNullException("Element is null in ModelMerge: " + elementDomainInfo.Name);
					
					if( !element.ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
					{
						// add warning message
						groupMerger.MergeResult.AddMessage(new DslEditorModeling.ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to SerializationModel because paste is not allowed."));
						
						element.Delete();
						return;
		 			}
					
					if( isRoot && groupMerger.ProtoGroup.Operation != DslEditorModeling.ModelProtoGroupOperation.Move)
					{
						//element.Name = "Copy of " + element.Name;
					}
					
					// update id mapping
					groupMerger.SetIdMapping(protoElement.ElementId, newElementId);
					
					// add child element
					DslModeling::DomainRoleInfo.SetLinkedElement(this, global::Tum.PDE.LanguageDSL.SerializationModelHasSerializedDomainModel.SerializationModelDomainRoleId, element);
		
					// continue with child elements (Embedding Relationship)
					System.Collections.Generic.List<DslEditorModeling::ModelProtoElement> embeddedProtoElements = groupMerger.GetEmbeddedElements(this.Store.DefaultPartition, protoElement);
					if( embeddedProtoElements.Count > 0 )
					{
						foreach (DslEditorModeling::ModelProtoElement p in embeddedProtoElements)
							(element as DslEditorModeling::IModelMergeElements).ModelMerge(p, groupMerger, false);
					}
				}
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.SerializationClass.DomainClassId)) 
				{
					// get element id
					System.Guid newElementId = System.Guid.NewGuid();
					
					// create property assignments
					DslModeling::PropertyAssignment[] propertyAssignemnts = protoElement.GetPropertyAssignments(this.Store.DefaultPartition, newElementId);
					
		            // create the actual model element
					global::Tum.PDE.LanguageDSL.SerializationClass element = null;			
					if( global::Tum.PDE.LanguageDSL.SerializedDomainClass.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.SerializedDomainClass(this.Store, propertyAssignemnts);
					if( global::Tum.PDE.LanguageDSL.SerializedDomainModel.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.SerializedDomainModel(this.Store, propertyAssignemnts);
					if( global::Tum.PDE.LanguageDSL.SerializedEmbeddingRelationship.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.SerializedEmbeddingRelationship(this.Store, propertyAssignemnts);
					if( global::Tum.PDE.LanguageDSL.SerializedReferenceRelationship.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.SerializedReferenceRelationship(this.Store, propertyAssignemnts);
					if( element == null )
						throw new System.ArgumentNullException("Element is null in ModelMerge: " + elementDomainInfo.Name);
					
					if( !element.ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
					{
						// add warning message
						groupMerger.MergeResult.AddMessage(new DslEditorModeling.ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to SerializationModel because paste is not allowed."));
						
						element.Delete();
						return;
		 			}
					
					if( isRoot && groupMerger.ProtoGroup.Operation != DslEditorModeling.ModelProtoGroupOperation.Move)
					{
						//element.Name = "Copy of " + element.Name;
					}
					
					// update id mapping
					groupMerger.SetIdMapping(protoElement.ElementId, newElementId);
					
					// add child element
					GetRoleCollection<DslModeling::LinkedElementCollection<global::Tum.PDE.LanguageDSL.SerializationClass>, global::Tum.PDE.LanguageDSL.SerializationClass>(global::Tum.PDE.LanguageDSL.SerializationModelHasChildren.SerializationModelDomainRoleId).Add(element);
		
					// continue with child elements (Embedding Relationship)
					System.Collections.Generic.List<DslEditorModeling::ModelProtoElement> embeddedProtoElements = groupMerger.GetEmbeddedElements(this.Store.DefaultPartition, protoElement);
					if( embeddedProtoElements.Count > 0 )
					{
						foreach (DslEditorModeling::ModelProtoElement p in embeddedProtoElements)
							(element as DslEditorModeling::IModelMergeElements).ModelMerge(p, groupMerger, false);
					}
				}
			}
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to SerializationModel because move is not allowed."));
				return;
			}
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.SerializedDomainModel.DomainClassId)) 
				{
		            DslModeling::ModelElement modelElement = this.Store.ElementDirectory.FindElement(protoElement.ElementId);
		            if( modelElement == null )
		            {
		                groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementMissingOnMoveId",
				             DslEditorModeling.ModelValidationViolationType.Error, "Element exists although the operation = Move."));
		                return;
					}
		
					// change parent
					DslModeling::DomainRoleInfo.SetLinkedElement(modelElement, global::Tum.PDE.LanguageDSL.SerializationModelHasSerializedDomainModel.SerializedDomainModelDomainRoleId, this);
					return;
				}
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.SerializationClass.DomainClassId)) 
				{
		            DslModeling::ModelElement modelElement = this.Store.ElementDirectory.FindElement(protoElement.ElementId);
		            if( modelElement == null )
		            {
		                groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementMissingOnMoveId",
				             DslEditorModeling.ModelValidationViolationType.Error, "Element exists although the operation = Move."));
		                return;
					}
		
					// change parent
					DslModeling::DomainRoleInfo.SetLinkedElement(modelElement, global::Tum.PDE.LanguageDSL.SerializationModelHasChildren.SerializationClassDomainRoleId, this);
					return;
				}
			}
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class SerializedDomainModel : SerializedDomainClass
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to SerializedDomainModel because paste is not allowed."));
				return;
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to SerializedDomainModel because move is not allowed."));
				return;
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class SerializationElement : Tum.PDE.LanguageDSL.CopyPaste.IModelMergeElements
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public virtual bool ModelIsCopyAllowed()
		{
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public virtual bool ModelIsMoveAllowed()
		{
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public virtual bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public virtual DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public virtual DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public virtual void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public virtual bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return false;
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public virtual void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to SerializationElement because paste is not allowed."));
				return;
			}
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			DslModeling::DomainRelationshipInfo linkDomainInfo = null;
			if (protoLink != null)
			{
				linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(protoLink.DomainClassId);
			}
			else
			{
				// try getting the linkDomainInfo from name
			}
			
			if( linkDomainInfo == null )
			{
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkDomainTypeMissing",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link can not be created as the corresponding domain type is missing."));
				return;
			}
		
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to SerializationElement because move is not allowed."));
				return;
			}
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class SerializedDomainClass : SerializationClass
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to SerializedDomainClass because paste is not allowed."));
				return;
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			DslModeling::DomainRelationshipInfo linkDomainInfo = null;
			if (protoLink != null)
			{
				linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(protoLink.DomainClassId);
			}
			else
			{
				// try getting the linkDomainInfo from name
				if( protoLink.Name == "SerializedDomainClassReferencesDomainClass" && linkDomainInfo == null)
				{
					linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(SerializedDomainClassReferencesDomainClass.DomainClassId);
				}
			}
			
			if( linkDomainInfo == null )
			{
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkDomainTypeMissing",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link can not be created as the corresponding domain type is missing."));
				return;
			}
		
				if (linkDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.SerializedDomainClassReferencesDomainClass.DomainClassId)) 
				{
					// see if this element is taking part in this role
					bool bTakesPart = false;
					
					DslEditorModeling::ModelProtoRolePlayer sourceRolePlayer = protoLink.GetSourceRolePlayer(this.Store.DefaultPartition);
					DslEditorModeling::ModelProtoElement sourceProtoElement = groupMerger.GetElementById(sourceRolePlayer.RolePlayerId);
					System.Guid mappedSourceIdTP = System.Guid.Empty;
					if( sourceProtoElement != null )
					{
						mappedSourceIdTP = groupMerger.GetIdMapping(sourceRolePlayer.RolePlayerId);
						if( mappedSourceIdTP == this.Id )
							bTakesPart = true;
					}
		
					if( bTakesPart )
					{		
						bool bExists = true;
		        	    if( this.Store.ElementDirectory.FindElement(protoLink.ElementId) == null )
		        	        bExists = false;
							
						if( bExists && groupMerger.ProtoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
		        	    {
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkExistsOnMoveId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link exists although the operation = Move."));
						}
						
						#region Target
						// see if target element was copied
						DslEditorModeling::ModelProtoRolePlayer targetRolePlayer = protoLink.GetTargetRolePlayer(this.Store.DefaultPartition);
						DslEditorModeling::ModelProtoElement targetProtoElement = groupMerger.GetElementById(targetRolePlayer.RolePlayerId);
						System.Guid mappedTargetId = System.Guid.Empty;
						if( targetProtoElement != null )
						{
						 	mappedTargetId= groupMerger.GetIdMapping(targetRolePlayer.RolePlayerId);
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element
							mappedTargetId = targetRolePlayer.RolePlayerId;
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element with the same name as the previous element
							// TODO
						}
		
						if( mappedTargetId == System.Guid.Empty )
						{
							// log warning
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotCopiedId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not copied. Relationship: SerializedDomainClassReferencesDomainClass"));
						}
						else
						{
							DslModeling::ModelElement targetElement = this.Store.ElementDirectory.FindElement(mappedTargetId);
							if( targetElement == null )
							{
								// log error
		        	        	groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotFoundId",
					            	DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not found. Relationship: SerializedDomainClassReferencesDomainClass"));
							}
							else
							{
								bool bContinue = true;
		
								// check cardinalities, so we don't violate them by additing a new relationship
								if( DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Tum.PDE.LanguageDSL.SerializedDomainClassReferencesDomainClass.SerializedDomainClassDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: SerializedDomainClassReferencesDomainClass"));
									
									bContinue = false;
								}
								if( DslModeling::DomainRoleInfo.GetLinkedElement(targetElement, global::Tum.PDE.LanguageDSL.SerializedDomainClassReferencesDomainClass.DomainClassDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: SerializedDomainClassReferencesDomainClass"));
									
									bContinue = false;
								}
								
								if( bContinue )
								{
									// create property assignments
									DslModeling::PropertyAssignment[] propertyAssignemnts = protoLink.GetPropertyAssignments(this.Store.DefaultPartition, 
										System.Guid.NewGuid());
								
									// create role assignments
									DslModeling.RoleAssignment[] roleAssignments = new DslModeling.RoleAssignment[2];
		                	        roleAssignments[0] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.SerializedDomainClassReferencesDomainClass.SerializedDomainClassDomainRoleId, this);
									roleAssignments[1] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.SerializedDomainClassReferencesDomainClass.DomainClassDomainRoleId, targetElement);
									
									// create new relationship
									new global::Tum.PDE.LanguageDSL.SerializedDomainClassReferencesDomainClass(this.Store, roleAssignments, propertyAssignemnts);
								}
							}
						}
						#endregion
					}
				}
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to SerializedDomainClass because move is not allowed."));
				return;
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class SerializedEmbeddingRelationship : SerializedRelationship
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to SerializedEmbeddingRelationship because paste is not allowed."));
				return;
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			DslModeling::DomainRelationshipInfo linkDomainInfo = null;
			if (protoLink != null)
			{
				linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(protoLink.DomainClassId);
			}
			else
			{
				// try getting the linkDomainInfo from name
				if( protoLink.Name == "SerializedEmbeddingRelationshipReferencesEmbeddingRelationship" && linkDomainInfo == null)
				{
					linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(SerializedEmbeddingRelationshipReferencesEmbeddingRelationship.DomainClassId);
				}
			}
			
			if( linkDomainInfo == null )
			{
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkDomainTypeMissing",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link can not be created as the corresponding domain type is missing."));
				return;
			}
		
				if (linkDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.SerializedEmbeddingRelationshipReferencesEmbeddingRelationship.DomainClassId)) 
				{
					// see if this element is taking part in this role
					bool bTakesPart = false;
					
					DslEditorModeling::ModelProtoRolePlayer sourceRolePlayer = protoLink.GetSourceRolePlayer(this.Store.DefaultPartition);
					DslEditorModeling::ModelProtoElement sourceProtoElement = groupMerger.GetElementById(sourceRolePlayer.RolePlayerId);
					System.Guid mappedSourceIdTP = System.Guid.Empty;
					if( sourceProtoElement != null )
					{
						mappedSourceIdTP = groupMerger.GetIdMapping(sourceRolePlayer.RolePlayerId);
						if( mappedSourceIdTP == this.Id )
							bTakesPart = true;
					}
		
					if( bTakesPart )
					{		
						bool bExists = true;
		        	    if( this.Store.ElementDirectory.FindElement(protoLink.ElementId) == null )
		        	        bExists = false;
							
						if( bExists && groupMerger.ProtoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
		        	    {
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkExistsOnMoveId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link exists although the operation = Move."));
						}
						
						#region Target
						// see if target element was copied
						DslEditorModeling::ModelProtoRolePlayer targetRolePlayer = protoLink.GetTargetRolePlayer(this.Store.DefaultPartition);
						DslEditorModeling::ModelProtoElement targetProtoElement = groupMerger.GetElementById(targetRolePlayer.RolePlayerId);
						System.Guid mappedTargetId = System.Guid.Empty;
						if( targetProtoElement != null )
						{
						 	mappedTargetId= groupMerger.GetIdMapping(targetRolePlayer.RolePlayerId);
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element
							mappedTargetId = targetRolePlayer.RolePlayerId;
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element with the same name as the previous element
							// TODO
						}
		
						if( mappedTargetId == System.Guid.Empty )
						{
							// log warning
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotCopiedId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not copied. Relationship: SerializedEmbeddingRelationshipReferencesEmbeddingRelationship"));
						}
						else
						{
							DslModeling::ModelElement targetElement = this.Store.ElementDirectory.FindElement(mappedTargetId);
							if( targetElement == null )
							{
								// log error
		        	        	groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotFoundId",
					            	DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not found. Relationship: SerializedEmbeddingRelationshipReferencesEmbeddingRelationship"));
							}
							else
							{
								bool bContinue = true;
		
								// check cardinalities, so we don't violate them by additing a new relationship
								if( DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Tum.PDE.LanguageDSL.SerializedEmbeddingRelationshipReferencesEmbeddingRelationship.SerializedEmbeddingRelationshipDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: SerializedEmbeddingRelationshipReferencesEmbeddingRelationship"));
									
									bContinue = false;
								}
								if( DslModeling::DomainRoleInfo.GetLinkedElement(targetElement, global::Tum.PDE.LanguageDSL.SerializedEmbeddingRelationshipReferencesEmbeddingRelationship.EmbeddingRelationshipDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: SerializedEmbeddingRelationshipReferencesEmbeddingRelationship"));
									
									bContinue = false;
								}
								
								if( bContinue )
								{
									// create property assignments
									DslModeling::PropertyAssignment[] propertyAssignemnts = protoLink.GetPropertyAssignments(this.Store.DefaultPartition, 
										System.Guid.NewGuid());
								
									// create role assignments
									DslModeling.RoleAssignment[] roleAssignments = new DslModeling.RoleAssignment[2];
		                	        roleAssignments[0] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.SerializedEmbeddingRelationshipReferencesEmbeddingRelationship.SerializedEmbeddingRelationshipDomainRoleId, this);
									roleAssignments[1] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.SerializedEmbeddingRelationshipReferencesEmbeddingRelationship.EmbeddingRelationshipDomainRoleId, targetElement);
									
									// create new relationship
									new global::Tum.PDE.LanguageDSL.SerializedEmbeddingRelationshipReferencesEmbeddingRelationship(this.Store, roleAssignments, propertyAssignemnts);
								}
							}
						}
						#endregion
					}
				}
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to SerializedEmbeddingRelationship because move is not allowed."));
				return;
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class SerializedReferenceRelationship : SerializedRelationship
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to SerializedReferenceRelationship because paste is not allowed."));
				return;
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			DslModeling::DomainRelationshipInfo linkDomainInfo = null;
			if (protoLink != null)
			{
				linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(protoLink.DomainClassId);
			}
			else
			{
				// try getting the linkDomainInfo from name
				if( protoLink.Name == "SerializedReferenceRelationshipReferencesReferenceRelationship" && linkDomainInfo == null)
				{
					linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(SerializedReferenceRelationshipReferencesReferenceRelationship.DomainClassId);
				}
			}
			
			if( linkDomainInfo == null )
			{
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkDomainTypeMissing",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link can not be created as the corresponding domain type is missing."));
				return;
			}
		
				if (linkDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.SerializedReferenceRelationshipReferencesReferenceRelationship.DomainClassId)) 
				{
					// see if this element is taking part in this role
					bool bTakesPart = false;
					
					DslEditorModeling::ModelProtoRolePlayer sourceRolePlayer = protoLink.GetSourceRolePlayer(this.Store.DefaultPartition);
					DslEditorModeling::ModelProtoElement sourceProtoElement = groupMerger.GetElementById(sourceRolePlayer.RolePlayerId);
					System.Guid mappedSourceIdTP = System.Guid.Empty;
					if( sourceProtoElement != null )
					{
						mappedSourceIdTP = groupMerger.GetIdMapping(sourceRolePlayer.RolePlayerId);
						if( mappedSourceIdTP == this.Id )
							bTakesPart = true;
					}
		
					if( bTakesPart )
					{		
						bool bExists = true;
		        	    if( this.Store.ElementDirectory.FindElement(protoLink.ElementId) == null )
		        	        bExists = false;
							
						if( bExists && groupMerger.ProtoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
		        	    {
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkExistsOnMoveId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link exists although the operation = Move."));
						}
						
						#region Target
						// see if target element was copied
						DslEditorModeling::ModelProtoRolePlayer targetRolePlayer = protoLink.GetTargetRolePlayer(this.Store.DefaultPartition);
						DslEditorModeling::ModelProtoElement targetProtoElement = groupMerger.GetElementById(targetRolePlayer.RolePlayerId);
						System.Guid mappedTargetId = System.Guid.Empty;
						if( targetProtoElement != null )
						{
						 	mappedTargetId= groupMerger.GetIdMapping(targetRolePlayer.RolePlayerId);
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element
							mappedTargetId = targetRolePlayer.RolePlayerId;
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element with the same name as the previous element
							// TODO
						}
		
						if( mappedTargetId == System.Guid.Empty )
						{
							// log warning
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotCopiedId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not copied. Relationship: SerializedReferenceRelationshipReferencesReferenceRelationship"));
						}
						else
						{
							DslModeling::ModelElement targetElement = this.Store.ElementDirectory.FindElement(mappedTargetId);
							if( targetElement == null )
							{
								// log error
		        	        	groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotFoundId",
					            	DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not found. Relationship: SerializedReferenceRelationshipReferencesReferenceRelationship"));
							}
							else
							{
								bool bContinue = true;
		
								// check cardinalities, so we don't violate them by additing a new relationship
								if( DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Tum.PDE.LanguageDSL.SerializedReferenceRelationshipReferencesReferenceRelationship.SerializedReferenceRelationshipDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: SerializedReferenceRelationshipReferencesReferenceRelationship"));
									
									bContinue = false;
								}
								if( DslModeling::DomainRoleInfo.GetLinkedElement(targetElement, global::Tum.PDE.LanguageDSL.SerializedReferenceRelationshipReferencesReferenceRelationship.ReferenceRelationshipDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: SerializedReferenceRelationshipReferencesReferenceRelationship"));
									
									bContinue = false;
								}
								
								if( bContinue )
								{
									// create property assignments
									DslModeling::PropertyAssignment[] propertyAssignemnts = protoLink.GetPropertyAssignments(this.Store.DefaultPartition, 
										System.Guid.NewGuid());
								
									// create role assignments
									DslModeling.RoleAssignment[] roleAssignments = new DslModeling.RoleAssignment[2];
		                	        roleAssignments[0] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.SerializedReferenceRelationshipReferencesReferenceRelationship.SerializedReferenceRelationshipDomainRoleId, this);
									roleAssignments[1] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.SerializedReferenceRelationshipReferencesReferenceRelationship.ReferenceRelationshipDomainRoleId, targetElement);
									
									// create new relationship
									new global::Tum.PDE.LanguageDSL.SerializedReferenceRelationshipReferencesReferenceRelationship(this.Store, roleAssignments, propertyAssignemnts);
								}
							}
						}
						#endregion
					}
				}
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to SerializedReferenceRelationship because move is not allowed."));
				return;
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class SerializedDomainProperty : SerializationAttributeElement
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to SerializedDomainProperty because paste is not allowed."));
				return;
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			DslModeling::DomainRelationshipInfo linkDomainInfo = null;
			if (protoLink != null)
			{
				linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(protoLink.DomainClassId);
			}
			else
			{
				// try getting the linkDomainInfo from name
				if( protoLink.Name == "SerializedDomainPropertyReferencesDomainProperty" && linkDomainInfo == null)
				{
					linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(SerializedDomainPropertyReferencesDomainProperty.DomainClassId);
				}
			}
			
			if( linkDomainInfo == null )
			{
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkDomainTypeMissing",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link can not be created as the corresponding domain type is missing."));
				return;
			}
		
				if (linkDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.SerializedDomainPropertyReferencesDomainProperty.DomainClassId)) 
				{
					// see if this element is taking part in this role
					bool bTakesPart = false;
					
					DslEditorModeling::ModelProtoRolePlayer sourceRolePlayer = protoLink.GetSourceRolePlayer(this.Store.DefaultPartition);
					DslEditorModeling::ModelProtoElement sourceProtoElement = groupMerger.GetElementById(sourceRolePlayer.RolePlayerId);
					System.Guid mappedSourceIdTP = System.Guid.Empty;
					if( sourceProtoElement != null )
					{
						mappedSourceIdTP = groupMerger.GetIdMapping(sourceRolePlayer.RolePlayerId);
						if( mappedSourceIdTP == this.Id )
							bTakesPart = true;
					}
		
					if( bTakesPart )
					{		
						bool bExists = true;
		        	    if( this.Store.ElementDirectory.FindElement(protoLink.ElementId) == null )
		        	        bExists = false;
							
						if( bExists && groupMerger.ProtoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
		        	    {
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkExistsOnMoveId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link exists although the operation = Move."));
						}
						
						#region Target
						// see if target element was copied
						DslEditorModeling::ModelProtoRolePlayer targetRolePlayer = protoLink.GetTargetRolePlayer(this.Store.DefaultPartition);
						DslEditorModeling::ModelProtoElement targetProtoElement = groupMerger.GetElementById(targetRolePlayer.RolePlayerId);
						System.Guid mappedTargetId = System.Guid.Empty;
						if( targetProtoElement != null )
						{
						 	mappedTargetId= groupMerger.GetIdMapping(targetRolePlayer.RolePlayerId);
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element
							mappedTargetId = targetRolePlayer.RolePlayerId;
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element with the same name as the previous element
							// TODO
						}
		
						if( mappedTargetId == System.Guid.Empty )
						{
							// log warning
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotCopiedId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not copied. Relationship: SerializedDomainPropertyReferencesDomainProperty"));
						}
						else
						{
							DslModeling::ModelElement targetElement = this.Store.ElementDirectory.FindElement(mappedTargetId);
							if( targetElement == null )
							{
								// log error
		        	        	groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotFoundId",
					            	DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not found. Relationship: SerializedDomainPropertyReferencesDomainProperty"));
							}
							else
							{
								bool bContinue = true;
		
								// check cardinalities, so we don't violate them by additing a new relationship
								if( DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Tum.PDE.LanguageDSL.SerializedDomainPropertyReferencesDomainProperty.SerializedDomainPropertyDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: SerializedDomainPropertyReferencesDomainProperty"));
									
									bContinue = false;
								}
								if( DslModeling::DomainRoleInfo.GetLinkedElement(targetElement, global::Tum.PDE.LanguageDSL.SerializedDomainPropertyReferencesDomainProperty.DomainPropertyDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: SerializedDomainPropertyReferencesDomainProperty"));
									
									bContinue = false;
								}
								
								if( bContinue )
								{
									// create property assignments
									DslModeling::PropertyAssignment[] propertyAssignemnts = protoLink.GetPropertyAssignments(this.Store.DefaultPartition, 
										System.Guid.NewGuid());
								
									// create role assignments
									DslModeling.RoleAssignment[] roleAssignments = new DslModeling.RoleAssignment[2];
		                	        roleAssignments[0] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.SerializedDomainPropertyReferencesDomainProperty.SerializedDomainPropertyDomainRoleId, this);
									roleAssignments[1] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.SerializedDomainPropertyReferencesDomainProperty.DomainPropertyDomainRoleId, targetElement);
									
									// create new relationship
									new global::Tum.PDE.LanguageDSL.SerializedDomainPropertyReferencesDomainProperty(this.Store, roleAssignments, propertyAssignemnts);
								}
							}
						}
						#endregion
					}
				}
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to SerializedDomainProperty because move is not allowed."));
				return;
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class SerializationClass : SerializationElement
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
			// SerializationClassReferencesChildren
			foreach (global::Tum.PDE.LanguageDSL.SerializationClassReferencesChildren link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.SerializationClassReferencesChildren>(this, global::Tum.PDE.LanguageDSL.SerializationClassReferencesChildren.ParentDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewReferenceLink(protoLink);
			}
			// SerializationClassReferencesAttributes
			foreach (global::Tum.PDE.LanguageDSL.SerializationClassReferencesAttributes link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.SerializationClassReferencesAttributes>(this, global::Tum.PDE.LanguageDSL.SerializationClassReferencesAttributes.ElementDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewReferenceLink(protoLink);
			}
			// SerializationClassHasIdProperty
			foreach (global::Tum.PDE.LanguageDSL.SerializationClassHasIdProperty link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.SerializationClassHasIdProperty>(this, global::Tum.PDE.LanguageDSL.SerializationClassHasIdProperty.SerializationClassDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewEmbeddingLink(protoLink);
				
				DslEditorModeling::ModelProtoElement protoElementRS = new DslEditorModeling::ModelProtoElement(link.SerializedIdProperty);
				protoGroup.AddNewElement(protoElementRS);
				
				// continue with target element
				if( link.SerializedIdProperty is DslEditorModeling::IModelMergeElements )
				{
					(link.SerializedIdProperty as DslEditorModeling::IModelMergeElements).ModelCreateMergeCopy(protoGroup);
				}
			}
			// SerializationClassHasProperties
			foreach (global::Tum.PDE.LanguageDSL.SerializationClassHasProperties link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.SerializationClassHasProperties>(this, global::Tum.PDE.LanguageDSL.SerializationClassHasProperties.SerializationClassDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewEmbeddingLink(protoLink);
				
				DslEditorModeling::ModelProtoElement protoElementRS = new DslEditorModeling::ModelProtoElement(link.SerializedDomainProperty);
				protoGroup.AddNewElement(protoElementRS);
				
				// continue with target element
				if( link.SerializedDomainProperty is DslEditorModeling::IModelMergeElements )
				{
					(link.SerializedDomainProperty as DslEditorModeling::IModelMergeElements).ModelCreateMergeCopy(protoGroup);
				}
			}
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.SerializedIdProperty.DomainClassId)) 
				{
					// Check that creating a link with this path doesn't cause multiplicity overflow: SerializationClassHasIdProperty.SerializedIdProperty
					if( DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Tum.PDE.LanguageDSL.SerializationClassHasIdProperty.SerializationClassDomainRoleId) != null )
						return false;
					return true;
				}
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.SerializedDomainProperty.DomainClassId)) 
				{
					if( protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
					{
						foreach (global::Tum.PDE.LanguageDSL.SerializationClassHasProperties link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.SerializationClassHasProperties>(this, global::Tum.PDE.LanguageDSL.SerializationClassHasProperties.SerializationClassDomainRoleId))				
							if( link.SerializedDomainProperty.Id == protoElement.ElementId )
								return false;
					}
					return true;
				}
			}
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to SerializationClass because paste is not allowed."));
				return;
			}
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.SerializedIdProperty.DomainClassId)) 
				{
					// get element id
					System.Guid newElementId = System.Guid.NewGuid();
					
					// create property assignments
					DslModeling::PropertyAssignment[] propertyAssignemnts = protoElement.GetPropertyAssignments(this.Store.DefaultPartition, newElementId);
					
		            // create the actual model element
					global::Tum.PDE.LanguageDSL.SerializedIdProperty element = null;			
					if( global::Tum.PDE.LanguageDSL.SerializedIdProperty.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.SerializedIdProperty(this.Store, propertyAssignemnts);
					if( element == null )
						throw new System.ArgumentNullException("Element is null in ModelMerge: " + elementDomainInfo.Name);
					
					if( !element.ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
					{
						// add warning message
						groupMerger.MergeResult.AddMessage(new DslEditorModeling.ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to SerializationClass because paste is not allowed."));
						
						element.Delete();
						return;
		 			}
					
					if( isRoot && groupMerger.ProtoGroup.Operation != DslEditorModeling.ModelProtoGroupOperation.Move)
					{
						//element.Name = "Copy of " + element.Name;
					}
					
					// update id mapping
					groupMerger.SetIdMapping(protoElement.ElementId, newElementId);
					
					// add child element
					DslModeling::DomainRoleInfo.SetLinkedElement(this, global::Tum.PDE.LanguageDSL.SerializationClassHasIdProperty.SerializationClassDomainRoleId, element);
		
					// continue with child elements (Embedding Relationship)
					System.Collections.Generic.List<DslEditorModeling::ModelProtoElement> embeddedProtoElements = groupMerger.GetEmbeddedElements(this.Store.DefaultPartition, protoElement);
					if( embeddedProtoElements.Count > 0 )
					{
						foreach (DslEditorModeling::ModelProtoElement p in embeddedProtoElements)
							(element as DslEditorModeling::IModelMergeElements).ModelMerge(p, groupMerger, false);
					}
				}
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.SerializedDomainProperty.DomainClassId)) 
				{
					// get element id
					System.Guid newElementId = System.Guid.NewGuid();
					
					// create property assignments
					DslModeling::PropertyAssignment[] propertyAssignemnts = protoElement.GetPropertyAssignments(this.Store.DefaultPartition, newElementId);
					
		            // create the actual model element
					global::Tum.PDE.LanguageDSL.SerializedDomainProperty element = null;			
					if( global::Tum.PDE.LanguageDSL.SerializedDomainProperty.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.SerializedDomainProperty(this.Store, propertyAssignemnts);
					if( element == null )
						throw new System.ArgumentNullException("Element is null in ModelMerge: " + elementDomainInfo.Name);
					
					if( !element.ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
					{
						// add warning message
						groupMerger.MergeResult.AddMessage(new DslEditorModeling.ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to SerializationClass because paste is not allowed."));
						
						element.Delete();
						return;
		 			}
					
					if( isRoot && groupMerger.ProtoGroup.Operation != DslEditorModeling.ModelProtoGroupOperation.Move)
					{
						//element.Name = "Copy of " + element.Name;
					}
					
					// update id mapping
					groupMerger.SetIdMapping(protoElement.ElementId, newElementId);
					
					// add child element
					GetRoleCollection<DslModeling::LinkedElementCollection<global::Tum.PDE.LanguageDSL.SerializedDomainProperty>, global::Tum.PDE.LanguageDSL.SerializedDomainProperty>(global::Tum.PDE.LanguageDSL.SerializationClassHasProperties.SerializationClassDomainRoleId).Add(element);
		
					// continue with child elements (Embedding Relationship)
					System.Collections.Generic.List<DslEditorModeling::ModelProtoElement> embeddedProtoElements = groupMerger.GetEmbeddedElements(this.Store.DefaultPartition, protoElement);
					if( embeddedProtoElements.Count > 0 )
					{
						foreach (DslEditorModeling::ModelProtoElement p in embeddedProtoElements)
							(element as DslEditorModeling::IModelMergeElements).ModelMerge(p, groupMerger, false);
					}
				}
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			DslModeling::DomainRelationshipInfo linkDomainInfo = null;
			if (protoLink != null)
			{
				linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(protoLink.DomainClassId);
			}
			else
			{
				// try getting the linkDomainInfo from name
				if( protoLink.Name == "SerializationClassReferencesChildren" && linkDomainInfo == null)
				{
					linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(SerializationClassReferencesChildren.DomainClassId);
				}
				if( protoLink.Name == "SerializationClassReferencesAttributes" && linkDomainInfo == null)
				{
					linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(SerializationClassReferencesAttributes.DomainClassId);
				}
			}
			
			if( linkDomainInfo == null )
			{
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkDomainTypeMissing",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link can not be created as the corresponding domain type is missing."));
				return;
			}
		
				if (linkDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.SerializationClassReferencesChildren.DomainClassId)) 
				{
					// see if this element is taking part in this role
					bool bTakesPart = false;
					
					DslEditorModeling::ModelProtoRolePlayer sourceRolePlayer = protoLink.GetSourceRolePlayer(this.Store.DefaultPartition);
					DslEditorModeling::ModelProtoElement sourceProtoElement = groupMerger.GetElementById(sourceRolePlayer.RolePlayerId);
					System.Guid mappedSourceIdTP = System.Guid.Empty;
					if( sourceProtoElement != null )
					{
						mappedSourceIdTP = groupMerger.GetIdMapping(sourceRolePlayer.RolePlayerId);
						if( mappedSourceIdTP == this.Id )
							bTakesPart = true;
					}
		
					if( bTakesPart )
					{		
						bool bExists = true;
		        	    if( this.Store.ElementDirectory.FindElement(protoLink.ElementId) == null )
		        	        bExists = false;
							
						if( bExists && groupMerger.ProtoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
		        	    {
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkExistsOnMoveId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link exists although the operation = Move."));
						}
						
						#region Target
						// see if target element was copied
						DslEditorModeling::ModelProtoRolePlayer targetRolePlayer = protoLink.GetTargetRolePlayer(this.Store.DefaultPartition);
						DslEditorModeling::ModelProtoElement targetProtoElement = groupMerger.GetElementById(targetRolePlayer.RolePlayerId);
						System.Guid mappedTargetId = System.Guid.Empty;
						if( targetProtoElement != null )
						{
						 	mappedTargetId= groupMerger.GetIdMapping(targetRolePlayer.RolePlayerId);
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element
							mappedTargetId = targetRolePlayer.RolePlayerId;
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element with the same name as the previous element
							// TODO
						}
		
						if( mappedTargetId == System.Guid.Empty )
						{
							// log warning
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotCopiedId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not copied. Relationship: SerializationClassReferencesChildren"));
						}
						else
						{
							DslModeling::ModelElement targetElement = this.Store.ElementDirectory.FindElement(mappedTargetId);
							if( targetElement == null )
							{
								// log error
		        	        	groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotFoundId",
					            	DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not found. Relationship: SerializationClassReferencesChildren"));
							}
							else
							{
								bool bContinue = true;
		
								// check cardinalities, so we don't violate them by additing a new relationship
								
								if( bContinue )
								{
									// create property assignments
									DslModeling::PropertyAssignment[] propertyAssignemnts = protoLink.GetPropertyAssignments(this.Store.DefaultPartition, 
										System.Guid.NewGuid());
								
									// create role assignments
									DslModeling.RoleAssignment[] roleAssignments = new DslModeling.RoleAssignment[2];
		                	        roleAssignments[0] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.SerializationClassReferencesChildren.ParentDomainRoleId, this);
									roleAssignments[1] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.SerializationClassReferencesChildren.ChildDomainRoleId, targetElement);
									
									// create new relationship
									new global::Tum.PDE.LanguageDSL.SerializationClassReferencesChildren(this.Store, roleAssignments, propertyAssignemnts);
								}
							}
						}
						#endregion
					}
				}
				if (linkDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.SerializationClassReferencesAttributes.DomainClassId)) 
				{
					// see if this element is taking part in this role
					bool bTakesPart = false;
					
					DslEditorModeling::ModelProtoRolePlayer sourceRolePlayer = protoLink.GetSourceRolePlayer(this.Store.DefaultPartition);
					DslEditorModeling::ModelProtoElement sourceProtoElement = groupMerger.GetElementById(sourceRolePlayer.RolePlayerId);
					System.Guid mappedSourceIdTP = System.Guid.Empty;
					if( sourceProtoElement != null )
					{
						mappedSourceIdTP = groupMerger.GetIdMapping(sourceRolePlayer.RolePlayerId);
						if( mappedSourceIdTP == this.Id )
							bTakesPart = true;
					}
		
					if( bTakesPart )
					{		
						bool bExists = true;
		        	    if( this.Store.ElementDirectory.FindElement(protoLink.ElementId) == null )
		        	        bExists = false;
							
						if( bExists && groupMerger.ProtoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
		        	    {
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkExistsOnMoveId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link exists although the operation = Move."));
						}
						
						#region Target
						// see if target element was copied
						DslEditorModeling::ModelProtoRolePlayer targetRolePlayer = protoLink.GetTargetRolePlayer(this.Store.DefaultPartition);
						DslEditorModeling::ModelProtoElement targetProtoElement = groupMerger.GetElementById(targetRolePlayer.RolePlayerId);
						System.Guid mappedTargetId = System.Guid.Empty;
						if( targetProtoElement != null )
						{
						 	mappedTargetId= groupMerger.GetIdMapping(targetRolePlayer.RolePlayerId);
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element
							mappedTargetId = targetRolePlayer.RolePlayerId;
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element with the same name as the previous element
							// TODO
						}
		
						if( mappedTargetId == System.Guid.Empty )
						{
							// log warning
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotCopiedId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not copied. Relationship: SerializationClassReferencesAttributes"));
						}
						else
						{
							DslModeling::ModelElement targetElement = this.Store.ElementDirectory.FindElement(mappedTargetId);
							if( targetElement == null )
							{
								// log error
		        	        	groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotFoundId",
					            	DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not found. Relationship: SerializationClassReferencesAttributes"));
							}
							else
							{
								bool bContinue = true;
		
								// check cardinalities, so we don't violate them by additing a new relationship
								
								if( bContinue )
								{
									// create property assignments
									DslModeling::PropertyAssignment[] propertyAssignemnts = protoLink.GetPropertyAssignments(this.Store.DefaultPartition, 
										System.Guid.NewGuid());
								
									// create role assignments
									DslModeling.RoleAssignment[] roleAssignments = new DslModeling.RoleAssignment[2];
		                	        roleAssignments[0] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.SerializationClassReferencesAttributes.ElementDomainRoleId, this);
									roleAssignments[1] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.SerializationClassReferencesAttributes.ChildDomainRoleId, targetElement);
									
									// create new relationship
									new global::Tum.PDE.LanguageDSL.SerializationClassReferencesAttributes(this.Store, roleAssignments, propertyAssignemnts);
								}
							}
						}
						#endregion
					}
				}
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to SerializationClass because move is not allowed."));
				return;
			}
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.SerializedIdProperty.DomainClassId)) 
				{
		            DslModeling::ModelElement modelElement = this.Store.ElementDirectory.FindElement(protoElement.ElementId);
		            if( modelElement == null )
		            {
		                groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementMissingOnMoveId",
				             DslEditorModeling.ModelValidationViolationType.Error, "Element exists although the operation = Move."));
		                return;
					}
		
					// change parent
					DslModeling::DomainRoleInfo.SetLinkedElement(modelElement, global::Tum.PDE.LanguageDSL.SerializationClassHasIdProperty.SerializedIdPropertyDomainRoleId, this);
					return;
				}
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.SerializedDomainProperty.DomainClassId)) 
				{
		            DslModeling::ModelElement modelElement = this.Store.ElementDirectory.FindElement(protoElement.ElementId);
		            if( modelElement == null )
		            {
		                groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementMissingOnMoveId",
				             DslEditorModeling.ModelValidationViolationType.Error, "Element exists although the operation = Move."));
		                return;
					}
		
					// change parent
					DslModeling::DomainRoleInfo.SetLinkedElement(modelElement, global::Tum.PDE.LanguageDSL.SerializationClassHasProperties.SerializedDomainPropertyDomainRoleId, this);
					return;
				}
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class SerializedIdProperty : SerializationAttributeElement
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to SerializedIdProperty because paste is not allowed."));
				return;
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to SerializedIdProperty because move is not allowed."));
				return;
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class SerializedDomainRole : SerializationElement
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to SerializedDomainRole because paste is not allowed."));
				return;
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			DslModeling::DomainRelationshipInfo linkDomainInfo = null;
			if (protoLink != null)
			{
				linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(protoLink.DomainClassId);
			}
			else
			{
				// try getting the linkDomainInfo from name
				if( protoLink.Name == "SerializedDomainRoleReferencesDomainRole" && linkDomainInfo == null)
				{
					linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(SerializedDomainRoleReferencesDomainRole.DomainClassId);
				}
				if( protoLink.Name == "SerializedDomainRoleReferencesSerializationClass" && linkDomainInfo == null)
				{
					linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(SerializedDomainRoleReferencesSerializationClass.DomainClassId);
				}
			}
			
			if( linkDomainInfo == null )
			{
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkDomainTypeMissing",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link can not be created as the corresponding domain type is missing."));
				return;
			}
		
				if (linkDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.SerializedDomainRoleReferencesDomainRole.DomainClassId)) 
				{
					// see if this element is taking part in this role
					bool bTakesPart = false;
					
					DslEditorModeling::ModelProtoRolePlayer sourceRolePlayer = protoLink.GetSourceRolePlayer(this.Store.DefaultPartition);
					DslEditorModeling::ModelProtoElement sourceProtoElement = groupMerger.GetElementById(sourceRolePlayer.RolePlayerId);
					System.Guid mappedSourceIdTP = System.Guid.Empty;
					if( sourceProtoElement != null )
					{
						mappedSourceIdTP = groupMerger.GetIdMapping(sourceRolePlayer.RolePlayerId);
						if( mappedSourceIdTP == this.Id )
							bTakesPart = true;
					}
		
					if( bTakesPart )
					{		
						bool bExists = true;
		        	    if( this.Store.ElementDirectory.FindElement(protoLink.ElementId) == null )
		        	        bExists = false;
							
						if( bExists && groupMerger.ProtoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
		        	    {
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkExistsOnMoveId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link exists although the operation = Move."));
						}
						
						#region Target
						// see if target element was copied
						DslEditorModeling::ModelProtoRolePlayer targetRolePlayer = protoLink.GetTargetRolePlayer(this.Store.DefaultPartition);
						DslEditorModeling::ModelProtoElement targetProtoElement = groupMerger.GetElementById(targetRolePlayer.RolePlayerId);
						System.Guid mappedTargetId = System.Guid.Empty;
						if( targetProtoElement != null )
						{
						 	mappedTargetId= groupMerger.GetIdMapping(targetRolePlayer.RolePlayerId);
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element
							mappedTargetId = targetRolePlayer.RolePlayerId;
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element with the same name as the previous element
							// TODO
						}
		
						if( mappedTargetId == System.Guid.Empty )
						{
							// log warning
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotCopiedId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not copied. Relationship: SerializedDomainRoleReferencesDomainRole"));
						}
						else
						{
							DslModeling::ModelElement targetElement = this.Store.ElementDirectory.FindElement(mappedTargetId);
							if( targetElement == null )
							{
								// log error
		        	        	groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotFoundId",
					            	DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not found. Relationship: SerializedDomainRoleReferencesDomainRole"));
							}
							else
							{
								bool bContinue = true;
		
								// check cardinalities, so we don't violate them by additing a new relationship
								if( DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Tum.PDE.LanguageDSL.SerializedDomainRoleReferencesDomainRole.SerializedDomainRoleDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: SerializedDomainRoleReferencesDomainRole"));
									
									bContinue = false;
								}
								
								if( bContinue )
								{
									// create property assignments
									DslModeling::PropertyAssignment[] propertyAssignemnts = protoLink.GetPropertyAssignments(this.Store.DefaultPartition, 
										System.Guid.NewGuid());
								
									// create role assignments
									DslModeling.RoleAssignment[] roleAssignments = new DslModeling.RoleAssignment[2];
		                	        roleAssignments[0] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.SerializedDomainRoleReferencesDomainRole.SerializedDomainRoleDomainRoleId, this);
									roleAssignments[1] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.SerializedDomainRoleReferencesDomainRole.DomainRoleDomainRoleId, targetElement);
									
									// create new relationship
									new global::Tum.PDE.LanguageDSL.SerializedDomainRoleReferencesDomainRole(this.Store, roleAssignments, propertyAssignemnts);
								}
							}
						}
						#endregion
					}
				}
				if (linkDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.SerializedDomainRoleReferencesSerializationClass.DomainClassId)) 
				{
					// see if this element is taking part in this role
					bool bTakesPart = false;
					
					DslEditorModeling::ModelProtoRolePlayer sourceRolePlayer = protoLink.GetSourceRolePlayer(this.Store.DefaultPartition);
					DslEditorModeling::ModelProtoElement sourceProtoElement = groupMerger.GetElementById(sourceRolePlayer.RolePlayerId);
					System.Guid mappedSourceIdTP = System.Guid.Empty;
					if( sourceProtoElement != null )
					{
						mappedSourceIdTP = groupMerger.GetIdMapping(sourceRolePlayer.RolePlayerId);
						if( mappedSourceIdTP == this.Id )
							bTakesPart = true;
					}
		
					if( bTakesPart )
					{		
						bool bExists = true;
		        	    if( this.Store.ElementDirectory.FindElement(protoLink.ElementId) == null )
		        	        bExists = false;
							
						if( bExists && groupMerger.ProtoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
		        	    {
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkExistsOnMoveId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link exists although the operation = Move."));
						}
						
						#region Target
						// see if target element was copied
						DslEditorModeling::ModelProtoRolePlayer targetRolePlayer = protoLink.GetTargetRolePlayer(this.Store.DefaultPartition);
						DslEditorModeling::ModelProtoElement targetProtoElement = groupMerger.GetElementById(targetRolePlayer.RolePlayerId);
						System.Guid mappedTargetId = System.Guid.Empty;
						if( targetProtoElement != null )
						{
						 	mappedTargetId= groupMerger.GetIdMapping(targetRolePlayer.RolePlayerId);
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element
							mappedTargetId = targetRolePlayer.RolePlayerId;
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element with the same name as the previous element
							// TODO
						}
		
						if( mappedTargetId == System.Guid.Empty )
						{
							// log warning
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotCopiedId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not copied. Relationship: SerializedDomainRoleReferencesSerializationClass"));
						}
						else
						{
							DslModeling::ModelElement targetElement = this.Store.ElementDirectory.FindElement(mappedTargetId);
							if( targetElement == null )
							{
								// log error
		        	        	groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotFoundId",
					            	DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not found. Relationship: SerializedDomainRoleReferencesSerializationClass"));
							}
							else
							{
								bool bContinue = true;
		
								// check cardinalities, so we don't violate them by additing a new relationship
								if( DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Tum.PDE.LanguageDSL.SerializedDomainRoleReferencesSerializationClass.SerializedDomainRoleDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: SerializedDomainRoleReferencesSerializationClass"));
									
									bContinue = false;
								}
								if( DslModeling::DomainRoleInfo.GetLinkedElement(targetElement, global::Tum.PDE.LanguageDSL.SerializedDomainRoleReferencesSerializationClass.SerializationClassDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: SerializedDomainRoleReferencesSerializationClass"));
									
									bContinue = false;
								}
								
								if( bContinue )
								{
									// create property assignments
									DslModeling::PropertyAssignment[] propertyAssignemnts = protoLink.GetPropertyAssignments(this.Store.DefaultPartition, 
										System.Guid.NewGuid());
								
									// create role assignments
									DslModeling.RoleAssignment[] roleAssignments = new DslModeling.RoleAssignment[2];
		                	        roleAssignments[0] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.SerializedDomainRoleReferencesSerializationClass.SerializedDomainRoleDomainRoleId, this);
									roleAssignments[1] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.SerializedDomainRoleReferencesSerializationClass.SerializationClassDomainRoleId, targetElement);
									
									// create new relationship
									new global::Tum.PDE.LanguageDSL.SerializedDomainRoleReferencesSerializationClass(this.Store, roleAssignments, propertyAssignemnts);
								}
							}
						}
						#endregion
					}
				}
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to SerializedDomainRole because move is not allowed."));
				return;
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class SerializationAttributeElement : SerializationElement
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to SerializationAttributeElement because paste is not allowed."));
				return;
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			DslModeling::DomainRelationshipInfo linkDomainInfo = null;
			if (protoLink != null)
			{
				linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(protoLink.DomainClassId);
			}
			else
			{
				// try getting the linkDomainInfo from name
			}
			
			if( linkDomainInfo == null )
			{
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkDomainTypeMissing",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link can not be created as the corresponding domain type is missing."));
				return;
			}
		
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to SerializationAttributeElement because move is not allowed."));
				return;
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class Validation : Tum.PDE.LanguageDSL.CopyPaste.IModelMergeElements
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public virtual bool ModelIsCopyAllowed()
		{
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public virtual bool ModelIsMoveAllowed()
		{
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public virtual bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public virtual DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public virtual DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public virtual void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public virtual bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return false;
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public virtual void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to Validation because paste is not allowed."));
				return;
			}
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to Validation because move is not allowed."));
				return;
			}
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class MappingRelationshipShapeClassBase : PresentationDomainClassElement
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
			// MappingRelationshipShapeClassReferencesSource
			foreach (global::Tum.PDE.LanguageDSL.MappingRelationshipShapeClassReferencesSource link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.MappingRelationshipShapeClassReferencesSource>(this, global::Tum.PDE.LanguageDSL.MappingRelationshipShapeClassReferencesSource.MappingRelationshipShapeClassDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewReferenceLink(protoLink);
			}
			// MappingRelationshipShapeClassReferencesTarget
			foreach (global::Tum.PDE.LanguageDSL.MappingRelationshipShapeClassReferencesTarget link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.MappingRelationshipShapeClassReferencesTarget>(this, global::Tum.PDE.LanguageDSL.MappingRelationshipShapeClassReferencesTarget.MappingRelationshipShapeClassDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewReferenceLink(protoLink);
			}
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to MappingRelationshipShapeClass because paste is not allowed."));
				return;
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			DslModeling::DomainRelationshipInfo linkDomainInfo = null;
			if (protoLink != null)
			{
				linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(protoLink.DomainClassId);
			}
			else
			{
				// try getting the linkDomainInfo from name
				if( protoLink.Name == "MappingRelationshipShapeClassReferencesSource" && linkDomainInfo == null)
				{
					linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(MappingRelationshipShapeClassReferencesSource.DomainClassId);
				}
				if( protoLink.Name == "MappingRelationshipShapeClassReferencesTarget" && linkDomainInfo == null)
				{
					linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(MappingRelationshipShapeClassReferencesTarget.DomainClassId);
				}
			}
			
			if( linkDomainInfo == null )
			{
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkDomainTypeMissing",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link can not be created as the corresponding domain type is missing."));
				return;
			}
		
				if (linkDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.MappingRelationshipShapeClassReferencesSource.DomainClassId)) 
				{
					// see if this element is taking part in this role
					bool bTakesPart = false;
					
					DslEditorModeling::ModelProtoRolePlayer sourceRolePlayer = protoLink.GetSourceRolePlayer(this.Store.DefaultPartition);
					DslEditorModeling::ModelProtoElement sourceProtoElement = groupMerger.GetElementById(sourceRolePlayer.RolePlayerId);
					System.Guid mappedSourceIdTP = System.Guid.Empty;
					if( sourceProtoElement != null )
					{
						mappedSourceIdTP = groupMerger.GetIdMapping(sourceRolePlayer.RolePlayerId);
						if( mappedSourceIdTP == this.Id )
							bTakesPart = true;
					}
		
					if( bTakesPart )
					{		
						bool bExists = true;
		        	    if( this.Store.ElementDirectory.FindElement(protoLink.ElementId) == null )
		        	        bExists = false;
							
						if( bExists && groupMerger.ProtoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
		        	    {
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkExistsOnMoveId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link exists although the operation = Move."));
						}
						
						#region Target
						// see if target element was copied
						DslEditorModeling::ModelProtoRolePlayer targetRolePlayer = protoLink.GetTargetRolePlayer(this.Store.DefaultPartition);
						DslEditorModeling::ModelProtoElement targetProtoElement = groupMerger.GetElementById(targetRolePlayer.RolePlayerId);
						System.Guid mappedTargetId = System.Guid.Empty;
						if( targetProtoElement != null )
						{
						 	mappedTargetId= groupMerger.GetIdMapping(targetRolePlayer.RolePlayerId);
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element
							mappedTargetId = targetRolePlayer.RolePlayerId;
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element with the same name as the previous element
							// TODO
						}
		
						if( mappedTargetId == System.Guid.Empty )
						{
							// log warning
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotCopiedId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not copied. Relationship: MappingRelationshipShapeClassReferencesSource"));
						}
						else
						{
							DslModeling::ModelElement targetElement = this.Store.ElementDirectory.FindElement(mappedTargetId);
							if( targetElement == null )
							{
								// log error
		        	        	groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotFoundId",
					            	DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not found. Relationship: MappingRelationshipShapeClassReferencesSource"));
							}
							else
							{
								bool bContinue = true;
		
								// check cardinalities, so we don't violate them by additing a new relationship
								if( DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Tum.PDE.LanguageDSL.MappingRelationshipShapeClassReferencesSource.MappingRelationshipShapeClassDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: MappingRelationshipShapeClassReferencesSource"));
									
									bContinue = false;
								}
								
								if( bContinue )
								{
									// create property assignments
									DslModeling::PropertyAssignment[] propertyAssignemnts = protoLink.GetPropertyAssignments(this.Store.DefaultPartition, 
										System.Guid.NewGuid());
								
									// create role assignments
									DslModeling.RoleAssignment[] roleAssignments = new DslModeling.RoleAssignment[2];
		                	        roleAssignments[0] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.MappingRelationshipShapeClassReferencesSource.MappingRelationshipShapeClassDomainRoleId, this);
									roleAssignments[1] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.MappingRelationshipShapeClassReferencesSource.ReferenceRelationshipDomainRoleId, targetElement);
									
									// create new relationship
									new global::Tum.PDE.LanguageDSL.MappingRelationshipShapeClassReferencesSource(this.Store, roleAssignments, propertyAssignemnts);
								}
							}
						}
						#endregion
					}
				}
				if (linkDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.MappingRelationshipShapeClassReferencesTarget.DomainClassId)) 
				{
					// see if this element is taking part in this role
					bool bTakesPart = false;
					
					DslEditorModeling::ModelProtoRolePlayer sourceRolePlayer = protoLink.GetSourceRolePlayer(this.Store.DefaultPartition);
					DslEditorModeling::ModelProtoElement sourceProtoElement = groupMerger.GetElementById(sourceRolePlayer.RolePlayerId);
					System.Guid mappedSourceIdTP = System.Guid.Empty;
					if( sourceProtoElement != null )
					{
						mappedSourceIdTP = groupMerger.GetIdMapping(sourceRolePlayer.RolePlayerId);
						if( mappedSourceIdTP == this.Id )
							bTakesPart = true;
					}
		
					if( bTakesPart )
					{		
						bool bExists = true;
		        	    if( this.Store.ElementDirectory.FindElement(protoLink.ElementId) == null )
		        	        bExists = false;
							
						if( bExists && groupMerger.ProtoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
		        	    {
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkExistsOnMoveId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link exists although the operation = Move."));
						}
						
						#region Target
						// see if target element was copied
						DslEditorModeling::ModelProtoRolePlayer targetRolePlayer = protoLink.GetTargetRolePlayer(this.Store.DefaultPartition);
						DslEditorModeling::ModelProtoElement targetProtoElement = groupMerger.GetElementById(targetRolePlayer.RolePlayerId);
						System.Guid mappedTargetId = System.Guid.Empty;
						if( targetProtoElement != null )
						{
						 	mappedTargetId= groupMerger.GetIdMapping(targetRolePlayer.RolePlayerId);
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element
							mappedTargetId = targetRolePlayer.RolePlayerId;
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element with the same name as the previous element
							// TODO
						}
		
						if( mappedTargetId == System.Guid.Empty )
						{
							// log warning
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotCopiedId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not copied. Relationship: MappingRelationshipShapeClassReferencesTarget"));
						}
						else
						{
							DslModeling::ModelElement targetElement = this.Store.ElementDirectory.FindElement(mappedTargetId);
							if( targetElement == null )
							{
								// log error
		        	        	groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotFoundId",
					            	DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not found. Relationship: MappingRelationshipShapeClassReferencesTarget"));
							}
							else
							{
								bool bContinue = true;
		
								// check cardinalities, so we don't violate them by additing a new relationship
								if( DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Tum.PDE.LanguageDSL.MappingRelationshipShapeClassReferencesTarget.MappingRelationshipShapeClassDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: MappingRelationshipShapeClassReferencesTarget"));
									
									bContinue = false;
								}
								
								if( bContinue )
								{
									// create property assignments
									DslModeling::PropertyAssignment[] propertyAssignemnts = protoLink.GetPropertyAssignments(this.Store.DefaultPartition, 
										System.Guid.NewGuid());
								
									// create role assignments
									DslModeling.RoleAssignment[] roleAssignments = new DslModeling.RoleAssignment[2];
		                	        roleAssignments[0] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.MappingRelationshipShapeClassReferencesTarget.MappingRelationshipShapeClassDomainRoleId, this);
									roleAssignments[1] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.MappingRelationshipShapeClassReferencesTarget.ReferenceRelationshipDomainRoleId, targetElement);
									
									// create new relationship
									new global::Tum.PDE.LanguageDSL.MappingRelationshipShapeClassReferencesTarget(this.Store, roleAssignments, propertyAssignemnts);
								}
							}
						}
						#endregion
					}
				}
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to MappingRelationshipShapeClass because move is not allowed."));
				return;
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class DiagramViewBase : Tum.PDE.LanguageDSL.CopyPaste.IModelMergeElements
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public virtual bool ModelIsCopyAllowed()
		{
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public virtual bool ModelIsMoveAllowed()
		{
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public virtual bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public virtual DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public virtual DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public virtual void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			// DiagramViewHasDiagramClassViews
			foreach (global::Tum.PDE.LanguageDSL.DiagramViewHasDiagramClassViews link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.DiagramViewHasDiagramClassViews>(this, global::Tum.PDE.LanguageDSL.DiagramViewHasDiagramClassViews.DiagramViewDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewEmbeddingLink(protoLink);
				
				DslEditorModeling::ModelProtoElement protoElementRS = new DslEditorModeling::ModelProtoElement(link.DiagramClassView);
				protoGroup.AddNewElement(protoElementRS);
				
				// continue with target element
				if( link.DiagramClassView is DslEditorModeling::IModelMergeElements )
				{
					(link.DiagramClassView as DslEditorModeling::IModelMergeElements).ModelCreateMergeCopy(protoGroup);
				}
			}
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public virtual bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.DiagramClassView.DomainClassId)) 
				{
					if( protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
					{
						foreach (global::Tum.PDE.LanguageDSL.DiagramViewHasDiagramClassViews link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.DiagramViewHasDiagramClassViews>(this, global::Tum.PDE.LanguageDSL.DiagramViewHasDiagramClassViews.DiagramViewDomainRoleId))				
							if( link.DiagramClassView.Id == protoElement.ElementId )
								return false;
					}
					return true;
				}
			}
			return false;
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public virtual void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to DiagramView because paste is not allowed."));
				return;
			}
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.DiagramClassView.DomainClassId)) 
				{
					// get element id
					System.Guid newElementId = System.Guid.NewGuid();
					
					// create property assignments
					DslModeling::PropertyAssignment[] propertyAssignemnts = protoElement.GetPropertyAssignments(this.Store.DefaultPartition, newElementId);
					
		            // create the actual model element
					global::Tum.PDE.LanguageDSL.DiagramClassView element = null;			
					if( global::Tum.PDE.LanguageDSL.DiagramClassView.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.DiagramClassView(this.Store, propertyAssignemnts);
					if( element == null )
						throw new System.ArgumentNullException("Element is null in ModelMerge: " + elementDomainInfo.Name);
					
					if( !element.ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
					{
						// add warning message
						groupMerger.MergeResult.AddMessage(new DslEditorModeling.ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to DiagramView because paste is not allowed."));
						
						element.Delete();
						return;
		 			}
					
					if( isRoot && groupMerger.ProtoGroup.Operation != DslEditorModeling.ModelProtoGroupOperation.Move)
					{
						//element.Name = "Copy of " + element.Name;
					}
					
					// update id mapping
					groupMerger.SetIdMapping(protoElement.ElementId, newElementId);
					
					// add child element
					GetRoleCollection<DslModeling::LinkedElementCollection<global::Tum.PDE.LanguageDSL.DiagramClassView>, global::Tum.PDE.LanguageDSL.DiagramClassView>(global::Tum.PDE.LanguageDSL.DiagramViewHasDiagramClassViews.DiagramViewDomainRoleId).Add(element);
		
					// continue with child elements (Embedding Relationship)
					System.Collections.Generic.List<DslEditorModeling::ModelProtoElement> embeddedProtoElements = groupMerger.GetEmbeddedElements(this.Store.DefaultPartition, protoElement);
					if( embeddedProtoElements.Count > 0 )
					{
						foreach (DslEditorModeling::ModelProtoElement p in embeddedProtoElements)
							(element as DslEditorModeling::IModelMergeElements).ModelMerge(p, groupMerger, false);
					}
				}
			}
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to DiagramView because move is not allowed."));
				return;
			}
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.DiagramClassView.DomainClassId)) 
				{
		            DslModeling::ModelElement modelElement = this.Store.ElementDirectory.FindElement(protoElement.ElementId);
		            if( modelElement == null )
		            {
		                groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementMissingOnMoveId",
				             DslEditorModeling.ModelValidationViolationType.Error, "Element exists although the operation = Move."));
		                return;
					}
		
					// change parent
					DslModeling::DomainRoleInfo.SetLinkedElement(modelElement, global::Tum.PDE.LanguageDSL.DiagramViewHasDiagramClassViews.DiagramClassViewDomainRoleId, this);
					return;
				}
			}
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class DesignerDiagramClass : DiagramClass
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to DesignerDiagramClass because paste is not allowed."));
				return;
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			DslModeling::DomainRelationshipInfo linkDomainInfo = null;
			if (protoLink != null)
			{
				linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(protoLink.DomainClassId);
			}
			else
			{
				// try getting the linkDomainInfo from name
				if( protoLink.Name == "DesignerDiagramClassReferencesImportedDiagramClasses" && linkDomainInfo == null)
				{
					linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(DesignerDiagramClassReferencesImportedDiagramClasses.DomainClassId);
				}
				if( protoLink.Name == "DesignerDiagramClassReferencesIncludedDiagramClasses" && linkDomainInfo == null)
				{
					linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(DesignerDiagramClassReferencesIncludedDiagramClasses.DomainClassId);
				}
			}
			
			if( linkDomainInfo == null )
			{
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkDomainTypeMissing",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link can not be created as the corresponding domain type is missing."));
				return;
			}
		
				if (linkDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.DesignerDiagramClassReferencesImportedDiagramClasses.DomainClassId)) 
				{
					// see if this element is taking part in this role
					bool bTakesPart = false;
					
					DslEditorModeling::ModelProtoRolePlayer sourceRolePlayer = protoLink.GetSourceRolePlayer(this.Store.DefaultPartition);
					DslEditorModeling::ModelProtoElement sourceProtoElement = groupMerger.GetElementById(sourceRolePlayer.RolePlayerId);
					System.Guid mappedSourceIdTP = System.Guid.Empty;
					if( sourceProtoElement != null )
					{
						mappedSourceIdTP = groupMerger.GetIdMapping(sourceRolePlayer.RolePlayerId);
						if( mappedSourceIdTP == this.Id )
							bTakesPart = true;
					}
		
					if( bTakesPart )
					{		
						bool bExists = true;
		        	    if( this.Store.ElementDirectory.FindElement(protoLink.ElementId) == null )
		        	        bExists = false;
							
						if( bExists && groupMerger.ProtoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
		        	    {
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkExistsOnMoveId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link exists although the operation = Move."));
						}
						
						#region Target
						// see if target element was copied
						DslEditorModeling::ModelProtoRolePlayer targetRolePlayer = protoLink.GetTargetRolePlayer(this.Store.DefaultPartition);
						DslEditorModeling::ModelProtoElement targetProtoElement = groupMerger.GetElementById(targetRolePlayer.RolePlayerId);
						System.Guid mappedTargetId = System.Guid.Empty;
						if( targetProtoElement != null )
						{
						 	mappedTargetId= groupMerger.GetIdMapping(targetRolePlayer.RolePlayerId);
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element
							mappedTargetId = targetRolePlayer.RolePlayerId;
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element with the same name as the previous element
							// TODO
						}
		
						if( mappedTargetId == System.Guid.Empty )
						{
							// log warning
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotCopiedId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not copied. Relationship: DesignerDiagramClassReferencesImportedDiagramClasses"));
						}
						else
						{
							DslModeling::ModelElement targetElement = this.Store.ElementDirectory.FindElement(mappedTargetId);
							if( targetElement == null )
							{
								// log error
		        	        	groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotFoundId",
					            	DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not found. Relationship: DesignerDiagramClassReferencesImportedDiagramClasses"));
							}
							else
							{
								bool bContinue = true;
		
								// check cardinalities, so we don't violate them by additing a new relationship
								
								if( bContinue )
								{
									// create property assignments
									DslModeling::PropertyAssignment[] propertyAssignemnts = protoLink.GetPropertyAssignments(this.Store.DefaultPartition, 
										System.Guid.NewGuid());
								
									// create role assignments
									DslModeling.RoleAssignment[] roleAssignments = new DslModeling.RoleAssignment[2];
		                	        roleAssignments[0] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.DesignerDiagramClassReferencesImportedDiagramClasses.DesignerDiagramClassDomainRoleId, this);
									roleAssignments[1] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.DesignerDiagramClassReferencesImportedDiagramClasses.DiagramClassDomainRoleId, targetElement);
									
									// create new relationship
									new global::Tum.PDE.LanguageDSL.DesignerDiagramClassReferencesImportedDiagramClasses(this.Store, roleAssignments, propertyAssignemnts);
								}
							}
						}
						#endregion
					}
				}
				if (linkDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.DesignerDiagramClassReferencesIncludedDiagramClasses.DomainClassId)) 
				{
					// see if this element is taking part in this role
					bool bTakesPart = false;
					
					DslEditorModeling::ModelProtoRolePlayer sourceRolePlayer = protoLink.GetSourceRolePlayer(this.Store.DefaultPartition);
					DslEditorModeling::ModelProtoElement sourceProtoElement = groupMerger.GetElementById(sourceRolePlayer.RolePlayerId);
					System.Guid mappedSourceIdTP = System.Guid.Empty;
					if( sourceProtoElement != null )
					{
						mappedSourceIdTP = groupMerger.GetIdMapping(sourceRolePlayer.RolePlayerId);
						if( mappedSourceIdTP == this.Id )
							bTakesPart = true;
					}
		
					if( bTakesPart )
					{		
						bool bExists = true;
		        	    if( this.Store.ElementDirectory.FindElement(protoLink.ElementId) == null )
		        	        bExists = false;
							
						if( bExists && groupMerger.ProtoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
		        	    {
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkExistsOnMoveId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link exists although the operation = Move."));
						}
						
						#region Target
						// see if target element was copied
						DslEditorModeling::ModelProtoRolePlayer targetRolePlayer = protoLink.GetTargetRolePlayer(this.Store.DefaultPartition);
						DslEditorModeling::ModelProtoElement targetProtoElement = groupMerger.GetElementById(targetRolePlayer.RolePlayerId);
						System.Guid mappedTargetId = System.Guid.Empty;
						if( targetProtoElement != null )
						{
						 	mappedTargetId= groupMerger.GetIdMapping(targetRolePlayer.RolePlayerId);
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element
							mappedTargetId = targetRolePlayer.RolePlayerId;
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element with the same name as the previous element
							// TODO
						}
		
						if( mappedTargetId == System.Guid.Empty )
						{
							// log warning
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotCopiedId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not copied. Relationship: DesignerDiagramClassReferencesIncludedDiagramClasses"));
						}
						else
						{
							DslModeling::ModelElement targetElement = this.Store.ElementDirectory.FindElement(mappedTargetId);
							if( targetElement == null )
							{
								// log error
		        	        	groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotFoundId",
					            	DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not found. Relationship: DesignerDiagramClassReferencesIncludedDiagramClasses"));
							}
							else
							{
								bool bContinue = true;
		
								// check cardinalities, so we don't violate them by additing a new relationship
								
								if( bContinue )
								{
									// create property assignments
									DslModeling::PropertyAssignment[] propertyAssignemnts = protoLink.GetPropertyAssignments(this.Store.DefaultPartition, 
										System.Guid.NewGuid());
								
									// create role assignments
									DslModeling.RoleAssignment[] roleAssignments = new DslModeling.RoleAssignment[2];
		                	        roleAssignments[0] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.DesignerDiagramClassReferencesIncludedDiagramClasses.DesignerDiagramClassDomainRoleId, this);
									roleAssignments[1] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.DesignerDiagramClassReferencesIncludedDiagramClasses.DiagramClassDomainRoleId, targetElement);
									
									// create new relationship
									new global::Tum.PDE.LanguageDSL.DesignerDiagramClassReferencesIncludedDiagramClasses(this.Store, roleAssignments, propertyAssignemnts);
								}
							}
						}
						#endregion
					}
				}
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to DesignerDiagramClass because move is not allowed."));
				return;
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class PresentationDomainClassElement : PresentationElementClass
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
			// ShapeClassReferencesDomainClass
			foreach (global::Tum.PDE.LanguageDSL.ShapeClassReferencesDomainClass link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.ShapeClassReferencesDomainClass>(this, global::Tum.PDE.LanguageDSL.ShapeClassReferencesDomainClass.ShapeClassDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewReferenceLink(protoLink);
			}
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to PresentationDomainClassElement because paste is not allowed."));
				return;
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			DslModeling::DomainRelationshipInfo linkDomainInfo = null;
			if (protoLink != null)
			{
				linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(protoLink.DomainClassId);
			}
			else
			{
				// try getting the linkDomainInfo from name
				if( protoLink.Name == "ShapeClassReferencesDomainClass" && linkDomainInfo == null)
				{
					linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(ShapeClassReferencesDomainClass.DomainClassId);
				}
			}
			
			if( linkDomainInfo == null )
			{
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkDomainTypeMissing",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link can not be created as the corresponding domain type is missing."));
				return;
			}
		
				if (linkDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.ShapeClassReferencesDomainClass.DomainClassId)) 
				{
					// see if this element is taking part in this role
					bool bTakesPart = false;
					
					DslEditorModeling::ModelProtoRolePlayer sourceRolePlayer = protoLink.GetSourceRolePlayer(this.Store.DefaultPartition);
					DslEditorModeling::ModelProtoElement sourceProtoElement = groupMerger.GetElementById(sourceRolePlayer.RolePlayerId);
					System.Guid mappedSourceIdTP = System.Guid.Empty;
					if( sourceProtoElement != null )
					{
						mappedSourceIdTP = groupMerger.GetIdMapping(sourceRolePlayer.RolePlayerId);
						if( mappedSourceIdTP == this.Id )
							bTakesPart = true;
					}
		
					if( bTakesPart )
					{		
						bool bExists = true;
		        	    if( this.Store.ElementDirectory.FindElement(protoLink.ElementId) == null )
		        	        bExists = false;
							
						if( bExists && groupMerger.ProtoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
		        	    {
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkExistsOnMoveId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link exists although the operation = Move."));
						}
						
						#region Target
						// see if target element was copied
						DslEditorModeling::ModelProtoRolePlayer targetRolePlayer = protoLink.GetTargetRolePlayer(this.Store.DefaultPartition);
						DslEditorModeling::ModelProtoElement targetProtoElement = groupMerger.GetElementById(targetRolePlayer.RolePlayerId);
						System.Guid mappedTargetId = System.Guid.Empty;
						if( targetProtoElement != null )
						{
						 	mappedTargetId= groupMerger.GetIdMapping(targetRolePlayer.RolePlayerId);
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element
							mappedTargetId = targetRolePlayer.RolePlayerId;
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element with the same name as the previous element
							// TODO
						}
		
						if( mappedTargetId == System.Guid.Empty )
						{
							// log warning
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotCopiedId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not copied. Relationship: ShapeClassReferencesDomainClass"));
						}
						else
						{
							DslModeling::ModelElement targetElement = this.Store.ElementDirectory.FindElement(mappedTargetId);
							if( targetElement == null )
							{
								// log error
		        	        	groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotFoundId",
					            	DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not found. Relationship: ShapeClassReferencesDomainClass"));
							}
							else
							{
								bool bContinue = true;
		
								// check cardinalities, so we don't violate them by additing a new relationship
								if( DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Tum.PDE.LanguageDSL.ShapeClassReferencesDomainClass.ShapeClassDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: ShapeClassReferencesDomainClass"));
									
									bContinue = false;
								}
								
								if( bContinue )
								{
									// create property assignments
									DslModeling::PropertyAssignment[] propertyAssignemnts = protoLink.GetPropertyAssignments(this.Store.DefaultPartition, 
										System.Guid.NewGuid());
								
									// create role assignments
									DslModeling.RoleAssignment[] roleAssignments = new DslModeling.RoleAssignment[2];
		                	        roleAssignments[0] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.ShapeClassReferencesDomainClass.ShapeClassDomainRoleId, this);
									roleAssignments[1] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.ShapeClassReferencesDomainClass.DomainClassDomainRoleId, targetElement);
									
									// create new relationship
									new global::Tum.PDE.LanguageDSL.ShapeClassReferencesDomainClass(this.Store, roleAssignments, propertyAssignemnts);
								}
							}
						}
						#endregion
					}
				}
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to PresentationDomainClassElement because move is not allowed."));
				return;
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class ModelTreeNode : Tum.PDE.LanguageDSL.CopyPaste.IModelMergeElements
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public virtual bool ModelIsCopyAllowed()
		{
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public virtual bool ModelIsMoveAllowed()
		{
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public virtual bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public virtual DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public virtual DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public virtual void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public virtual bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return false;
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public virtual void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to ModelTreeNode because paste is not allowed."));
				return;
			}
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to ModelTreeNode because move is not allowed."));
				return;
			}
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class SerializedRelationship : SerializationClass
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
			// SerializedRelationshipHasSerializedDomainRoles
			foreach (global::Tum.PDE.LanguageDSL.SerializedRelationshipHasSerializedDomainRoles link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.SerializedRelationshipHasSerializedDomainRoles>(this, global::Tum.PDE.LanguageDSL.SerializedRelationshipHasSerializedDomainRoles.SerializedRelationshipDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewEmbeddingLink(protoLink);
				
				DslEditorModeling::ModelProtoElement protoElementRS = new DslEditorModeling::ModelProtoElement(link.SerializedDomainRole);
				protoGroup.AddNewElement(protoElementRS);
				
				// continue with target element
				if( link.SerializedDomainRole is DslEditorModeling::IModelMergeElements )
				{
					(link.SerializedDomainRole as DslEditorModeling::IModelMergeElements).ModelCreateMergeCopy(protoGroup);
				}
			}
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.SerializedDomainRole.DomainClassId)) 
				{
					if( protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
					{
						foreach (global::Tum.PDE.LanguageDSL.SerializedRelationshipHasSerializedDomainRoles link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.SerializedRelationshipHasSerializedDomainRoles>(this, global::Tum.PDE.LanguageDSL.SerializedRelationshipHasSerializedDomainRoles.SerializedRelationshipDomainRoleId))				
							if( link.SerializedDomainRole.Id == protoElement.ElementId )
								return false;
					}
					return true;
				}
			}
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to SerializedRelationship because paste is not allowed."));
				return;
			}
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.SerializedDomainRole.DomainClassId)) 
				{
					// get element id
					System.Guid newElementId = System.Guid.NewGuid();
					
					// create property assignments
					DslModeling::PropertyAssignment[] propertyAssignemnts = protoElement.GetPropertyAssignments(this.Store.DefaultPartition, newElementId);
					
		            // create the actual model element
					global::Tum.PDE.LanguageDSL.SerializedDomainRole element = null;			
					if( global::Tum.PDE.LanguageDSL.SerializedDomainRole.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.SerializedDomainRole(this.Store, propertyAssignemnts);
					if( element == null )
						throw new System.ArgumentNullException("Element is null in ModelMerge: " + elementDomainInfo.Name);
					
					if( !element.ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
					{
						// add warning message
						groupMerger.MergeResult.AddMessage(new DslEditorModeling.ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to SerializedRelationship because paste is not allowed."));
						
						element.Delete();
						return;
		 			}
					
					if( isRoot && groupMerger.ProtoGroup.Operation != DslEditorModeling.ModelProtoGroupOperation.Move)
					{
						//element.Name = "Copy of " + element.Name;
					}
					
					// update id mapping
					groupMerger.SetIdMapping(protoElement.ElementId, newElementId);
					
					// add child element
					GetRoleCollection<DslModeling::LinkedElementCollection<global::Tum.PDE.LanguageDSL.SerializedDomainRole>, global::Tum.PDE.LanguageDSL.SerializedDomainRole>(global::Tum.PDE.LanguageDSL.SerializedRelationshipHasSerializedDomainRoles.SerializedRelationshipDomainRoleId).Add(element);
		
					// continue with child elements (Embedding Relationship)
					System.Collections.Generic.List<DslEditorModeling::ModelProtoElement> embeddedProtoElements = groupMerger.GetEmbeddedElements(this.Store.DefaultPartition, protoElement);
					if( embeddedProtoElements.Count > 0 )
					{
						foreach (DslEditorModeling::ModelProtoElement p in embeddedProtoElements)
							(element as DslEditorModeling::IModelMergeElements).ModelMerge(p, groupMerger, false);
					}
				}
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to SerializedRelationship because move is not allowed."));
				return;
			}
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.SerializedDomainRole.DomainClassId)) 
				{
		            DslModeling::ModelElement modelElement = this.Store.ElementDirectory.FindElement(protoElement.ElementId);
		            if( modelElement == null )
		            {
		                groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementMissingOnMoveId",
				             DslEditorModeling.ModelValidationViolationType.Error, "Element exists although the operation = Move."));
		                return;
					}
		
					// change parent
					DslModeling::DomainRoleInfo.SetLinkedElement(modelElement, global::Tum.PDE.LanguageDSL.SerializedRelationshipHasSerializedDomainRoles.SerializedDomainRoleDomainRoleId, this);
					return;
				}
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class Credits : Tum.PDE.LanguageDSL.CopyPaste.IModelMergeElements
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public virtual bool ModelIsCopyAllowed()
		{
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public virtual bool ModelIsMoveAllowed()
		{
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public virtual bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public virtual DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public virtual DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public virtual void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			// CreditsHasCreditItems
			foreach (global::Tum.PDE.LanguageDSL.CreditsHasCreditItems link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.CreditsHasCreditItems>(this, global::Tum.PDE.LanguageDSL.CreditsHasCreditItems.CreditsDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewEmbeddingLink(protoLink);
				
				DslEditorModeling::ModelProtoElement protoElementRS = new DslEditorModeling::ModelProtoElement(link.CreditItem);
				protoGroup.AddNewElement(protoElementRS);
				
				// continue with target element
				if( link.CreditItem is DslEditorModeling::IModelMergeElements )
				{
					(link.CreditItem as DslEditorModeling::IModelMergeElements).ModelCreateMergeCopy(protoGroup);
				}
			}
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public virtual bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.CreditItem.DomainClassId)) 
				{
					if( protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
					{
						foreach (global::Tum.PDE.LanguageDSL.CreditsHasCreditItems link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.CreditsHasCreditItems>(this, global::Tum.PDE.LanguageDSL.CreditsHasCreditItems.CreditsDomainRoleId))				
							if( link.CreditItem.Id == protoElement.ElementId )
								return false;
					}
					return true;
				}
			}
			return false;
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public virtual void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to Credits because paste is not allowed."));
				return;
			}
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.CreditItem.DomainClassId)) 
				{
					// get element id
					System.Guid newElementId = System.Guid.NewGuid();
					
					// create property assignments
					DslModeling::PropertyAssignment[] propertyAssignemnts = protoElement.GetPropertyAssignments(this.Store.DefaultPartition, newElementId);
					
		            // create the actual model element
					global::Tum.PDE.LanguageDSL.CreditItem element = null;			
					if( global::Tum.PDE.LanguageDSL.CreditItem.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.CreditItem(this.Store, propertyAssignemnts);
					if( element == null )
						throw new System.ArgumentNullException("Element is null in ModelMerge: " + elementDomainInfo.Name);
					
					if( !element.ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
					{
						// add warning message
						groupMerger.MergeResult.AddMessage(new DslEditorModeling.ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to Credits because paste is not allowed."));
						
						element.Delete();
						return;
		 			}
					
					if( isRoot && groupMerger.ProtoGroup.Operation != DslEditorModeling.ModelProtoGroupOperation.Move)
					{
						//element.Name = "Copy of " + element.Name;
					}
					
					// update id mapping
					groupMerger.SetIdMapping(protoElement.ElementId, newElementId);
					
					// add child element
					GetRoleCollection<DslModeling::LinkedElementCollection<global::Tum.PDE.LanguageDSL.CreditItem>, global::Tum.PDE.LanguageDSL.CreditItem>(global::Tum.PDE.LanguageDSL.CreditsHasCreditItems.CreditsDomainRoleId).Add(element);
		
					// continue with child elements (Embedding Relationship)
					System.Collections.Generic.List<DslEditorModeling::ModelProtoElement> embeddedProtoElements = groupMerger.GetEmbeddedElements(this.Store.DefaultPartition, protoElement);
					if( embeddedProtoElements.Count > 0 )
					{
						foreach (DslEditorModeling::ModelProtoElement p in embeddedProtoElements)
							(element as DslEditorModeling::IModelMergeElements).ModelMerge(p, groupMerger, false);
					}
				}
			}
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to Credits because move is not allowed."));
				return;
			}
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.CreditItem.DomainClassId)) 
				{
		            DslModeling::ModelElement modelElement = this.Store.ElementDirectory.FindElement(protoElement.ElementId);
		            if( modelElement == null )
		            {
		                groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementMissingOnMoveId",
				             DslEditorModeling.ModelValidationViolationType.Error, "Element exists although the operation = Move."));
		                return;
					}
		
					// change parent
					DslModeling::DomainRoleInfo.SetLinkedElement(modelElement, global::Tum.PDE.LanguageDSL.CreditsHasCreditItems.CreditItemDomainRoleId, this);
					return;
				}
			}
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class CreditItem : LinkItem
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to CreditItem because paste is not allowed."));
				return;
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to CreditItem because move is not allowed."));
				return;
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class AdditionalInformation : Tum.PDE.LanguageDSL.CopyPaste.IModelMergeElements
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public virtual bool ModelIsCopyAllowed()
		{
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public virtual bool ModelIsMoveAllowed()
		{
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public virtual bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public virtual DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public virtual DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public virtual void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			// AdditionalInformationHasCredits
			foreach (global::Tum.PDE.LanguageDSL.AdditionalInformationHasCredits link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.AdditionalInformationHasCredits>(this, global::Tum.PDE.LanguageDSL.AdditionalInformationHasCredits.AdditionalInformationDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewEmbeddingLink(protoLink);
				
				DslEditorModeling::ModelProtoElement protoElementRS = new DslEditorModeling::ModelProtoElement(link.Credits);
				protoGroup.AddNewElement(protoElementRS);
				
				// continue with target element
				if( link.Credits is DslEditorModeling::IModelMergeElements )
				{
					(link.Credits as DslEditorModeling::IModelMergeElements).ModelCreateMergeCopy(protoGroup);
				}
			}
			// AdditionalInformationHasFurtherInformation
			foreach (global::Tum.PDE.LanguageDSL.AdditionalInformationHasFurtherInformation link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.AdditionalInformationHasFurtherInformation>(this, global::Tum.PDE.LanguageDSL.AdditionalInformationHasFurtherInformation.AdditionalInformationDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewEmbeddingLink(protoLink);
				
				DslEditorModeling::ModelProtoElement protoElementRS = new DslEditorModeling::ModelProtoElement(link.FurtherInformation);
				protoGroup.AddNewElement(protoElementRS);
				
				// continue with target element
				if( link.FurtherInformation is DslEditorModeling::IModelMergeElements )
				{
					(link.FurtherInformation as DslEditorModeling::IModelMergeElements).ModelCreateMergeCopy(protoGroup);
				}
			}
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public virtual bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.Credits.DomainClassId)) 
				{
					// Check that creating a link with this path doesn't cause multiplicity overflow: AdditionalInformationHasCredits.Credits
					if( DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Tum.PDE.LanguageDSL.AdditionalInformationHasCredits.AdditionalInformationDomainRoleId) != null )
						return false;
					return true;
				}
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.FurtherInformation.DomainClassId)) 
				{
					// Check that creating a link with this path doesn't cause multiplicity overflow: AdditionalInformationHasFurtherInformation.FurtherInformation
					if( DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Tum.PDE.LanguageDSL.AdditionalInformationHasFurtherInformation.AdditionalInformationDomainRoleId) != null )
						return false;
					return true;
				}
			}
			return false;
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public virtual void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to AdditionalInformation because paste is not allowed."));
				return;
			}
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.Credits.DomainClassId)) 
				{
					// get element id
					System.Guid newElementId = System.Guid.NewGuid();
					
					// create property assignments
					DslModeling::PropertyAssignment[] propertyAssignemnts = protoElement.GetPropertyAssignments(this.Store.DefaultPartition, newElementId);
					
		            // create the actual model element
					global::Tum.PDE.LanguageDSL.Credits element = null;			
					if( global::Tum.PDE.LanguageDSL.Credits.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.Credits(this.Store, propertyAssignemnts);
					if( element == null )
						throw new System.ArgumentNullException("Element is null in ModelMerge: " + elementDomainInfo.Name);
					
					if( !element.ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
					{
						// add warning message
						groupMerger.MergeResult.AddMessage(new DslEditorModeling.ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to AdditionalInformation because paste is not allowed."));
						
						element.Delete();
						return;
		 			}
					
					if( isRoot && groupMerger.ProtoGroup.Operation != DslEditorModeling.ModelProtoGroupOperation.Move)
					{
						//element.Name = "Copy of " + element.Name;
					}
					
					// update id mapping
					groupMerger.SetIdMapping(protoElement.ElementId, newElementId);
					
					// add child element
					DslModeling::DomainRoleInfo.SetLinkedElement(this, global::Tum.PDE.LanguageDSL.AdditionalInformationHasCredits.AdditionalInformationDomainRoleId, element);
		
					// continue with child elements (Embedding Relationship)
					System.Collections.Generic.List<DslEditorModeling::ModelProtoElement> embeddedProtoElements = groupMerger.GetEmbeddedElements(this.Store.DefaultPartition, protoElement);
					if( embeddedProtoElements.Count > 0 )
					{
						foreach (DslEditorModeling::ModelProtoElement p in embeddedProtoElements)
							(element as DslEditorModeling::IModelMergeElements).ModelMerge(p, groupMerger, false);
					}
				}
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.FurtherInformation.DomainClassId)) 
				{
					// get element id
					System.Guid newElementId = System.Guid.NewGuid();
					
					// create property assignments
					DslModeling::PropertyAssignment[] propertyAssignemnts = protoElement.GetPropertyAssignments(this.Store.DefaultPartition, newElementId);
					
		            // create the actual model element
					global::Tum.PDE.LanguageDSL.FurtherInformation element = null;			
					if( global::Tum.PDE.LanguageDSL.FurtherInformation.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.FurtherInformation(this.Store, propertyAssignemnts);
					if( element == null )
						throw new System.ArgumentNullException("Element is null in ModelMerge: " + elementDomainInfo.Name);
					
					if( !element.ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
					{
						// add warning message
						groupMerger.MergeResult.AddMessage(new DslEditorModeling.ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to AdditionalInformation because paste is not allowed."));
						
						element.Delete();
						return;
		 			}
					
					if( isRoot && groupMerger.ProtoGroup.Operation != DslEditorModeling.ModelProtoGroupOperation.Move)
					{
						//element.Name = "Copy of " + element.Name;
					}
					
					// update id mapping
					groupMerger.SetIdMapping(protoElement.ElementId, newElementId);
					
					// add child element
					DslModeling::DomainRoleInfo.SetLinkedElement(this, global::Tum.PDE.LanguageDSL.AdditionalInformationHasFurtherInformation.AdditionalInformationDomainRoleId, element);
		
					// continue with child elements (Embedding Relationship)
					System.Collections.Generic.List<DslEditorModeling::ModelProtoElement> embeddedProtoElements = groupMerger.GetEmbeddedElements(this.Store.DefaultPartition, protoElement);
					if( embeddedProtoElements.Count > 0 )
					{
						foreach (DslEditorModeling::ModelProtoElement p in embeddedProtoElements)
							(element as DslEditorModeling::IModelMergeElements).ModelMerge(p, groupMerger, false);
					}
				}
			}
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to AdditionalInformation because move is not allowed."));
				return;
			}
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.Credits.DomainClassId)) 
				{
		            DslModeling::ModelElement modelElement = this.Store.ElementDirectory.FindElement(protoElement.ElementId);
		            if( modelElement == null )
		            {
		                groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementMissingOnMoveId",
				             DslEditorModeling.ModelValidationViolationType.Error, "Element exists although the operation = Move."));
		                return;
					}
		
					// change parent
					DslModeling::DomainRoleInfo.SetLinkedElement(modelElement, global::Tum.PDE.LanguageDSL.AdditionalInformationHasCredits.CreditsDomainRoleId, this);
					return;
				}
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.FurtherInformation.DomainClassId)) 
				{
		            DslModeling::ModelElement modelElement = this.Store.ElementDirectory.FindElement(protoElement.ElementId);
		            if( modelElement == null )
		            {
		                groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementMissingOnMoveId",
				             DslEditorModeling.ModelValidationViolationType.Error, "Element exists although the operation = Move."));
		                return;
					}
		
					// change parent
					DslModeling::DomainRoleInfo.SetLinkedElement(modelElement, global::Tum.PDE.LanguageDSL.AdditionalInformationHasFurtherInformation.FurtherInformationDomainRoleId, this);
					return;
				}
			}
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class FurtherInformation : Tum.PDE.LanguageDSL.CopyPaste.IModelMergeElements
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public virtual bool ModelIsCopyAllowed()
		{
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public virtual bool ModelIsMoveAllowed()
		{
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public virtual bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public virtual DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public virtual DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public virtual void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			// FurtherInformationHasInformationItems
			foreach (global::Tum.PDE.LanguageDSL.FurtherInformationHasInformationItems link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.FurtherInformationHasInformationItems>(this, global::Tum.PDE.LanguageDSL.FurtherInformationHasInformationItems.FurtherInformationDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewEmbeddingLink(protoLink);
				
				DslEditorModeling::ModelProtoElement protoElementRS = new DslEditorModeling::ModelProtoElement(link.InformationItem);
				protoGroup.AddNewElement(protoElementRS);
				
				// continue with target element
				if( link.InformationItem is DslEditorModeling::IModelMergeElements )
				{
					(link.InformationItem as DslEditorModeling::IModelMergeElements).ModelCreateMergeCopy(protoGroup);
				}
			}
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public virtual bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.InformationItem.DomainClassId)) 
				{
					if( protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
					{
						foreach (global::Tum.PDE.LanguageDSL.FurtherInformationHasInformationItems link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.FurtherInformationHasInformationItems>(this, global::Tum.PDE.LanguageDSL.FurtherInformationHasInformationItems.FurtherInformationDomainRoleId))				
							if( link.InformationItem.Id == protoElement.ElementId )
								return false;
					}
					return true;
				}
			}
			return false;
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public virtual void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to FurtherInformation because paste is not allowed."));
				return;
			}
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.InformationItem.DomainClassId)) 
				{
					// get element id
					System.Guid newElementId = System.Guid.NewGuid();
					
					// create property assignments
					DslModeling::PropertyAssignment[] propertyAssignemnts = protoElement.GetPropertyAssignments(this.Store.DefaultPartition, newElementId);
					
		            // create the actual model element
					global::Tum.PDE.LanguageDSL.InformationItem element = null;			
					if( global::Tum.PDE.LanguageDSL.InformationItem.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.InformationItem(this.Store, propertyAssignemnts);
					if( element == null )
						throw new System.ArgumentNullException("Element is null in ModelMerge: " + elementDomainInfo.Name);
					
					if( !element.ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
					{
						// add warning message
						groupMerger.MergeResult.AddMessage(new DslEditorModeling.ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to FurtherInformation because paste is not allowed."));
						
						element.Delete();
						return;
		 			}
					
					if( isRoot && groupMerger.ProtoGroup.Operation != DslEditorModeling.ModelProtoGroupOperation.Move)
					{
						//element.Name = "Copy of " + element.Name;
					}
					
					// update id mapping
					groupMerger.SetIdMapping(protoElement.ElementId, newElementId);
					
					// add child element
					GetRoleCollection<DslModeling::LinkedElementCollection<global::Tum.PDE.LanguageDSL.InformationItem>, global::Tum.PDE.LanguageDSL.InformationItem>(global::Tum.PDE.LanguageDSL.FurtherInformationHasInformationItems.FurtherInformationDomainRoleId).Add(element);
		
					// continue with child elements (Embedding Relationship)
					System.Collections.Generic.List<DslEditorModeling::ModelProtoElement> embeddedProtoElements = groupMerger.GetEmbeddedElements(this.Store.DefaultPartition, protoElement);
					if( embeddedProtoElements.Count > 0 )
					{
						foreach (DslEditorModeling::ModelProtoElement p in embeddedProtoElements)
							(element as DslEditorModeling::IModelMergeElements).ModelMerge(p, groupMerger, false);
					}
				}
			}
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to FurtherInformation because move is not allowed."));
				return;
			}
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.InformationItem.DomainClassId)) 
				{
		            DslModeling::ModelElement modelElement = this.Store.ElementDirectory.FindElement(protoElement.ElementId);
		            if( modelElement == null )
		            {
		                groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementMissingOnMoveId",
				             DslEditorModeling.ModelValidationViolationType.Error, "Element exists although the operation = Move."));
		                return;
					}
		
					// change parent
					DslModeling::DomainRoleInfo.SetLinkedElement(modelElement, global::Tum.PDE.LanguageDSL.FurtherInformationHasInformationItems.InformationItemDomainRoleId, this);
					return;
				}
			}
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class InformationItem : LinkItem
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to InformationItem because paste is not allowed."));
				return;
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to InformationItem because move is not allowed."));
				return;
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class LinkItem : Tum.PDE.LanguageDSL.CopyPaste.IModelMergeElements
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public virtual bool ModelIsCopyAllowed()
		{
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public virtual bool ModelIsMoveAllowed()
		{
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public virtual bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public virtual DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public virtual DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public virtual void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public virtual bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return false;
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public virtual void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to LinkItem because paste is not allowed."));
				return;
			}
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to LinkItem because move is not allowed."));
				return;
			}
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class MetaModelLibraryBase : Tum.PDE.LanguageDSL.CopyPaste.IModelMergeElements
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public virtual bool ModelIsCopyAllowed()
		{
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public virtual bool ModelIsMoveAllowed()
		{
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public virtual bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public virtual DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public virtual DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public virtual void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			// MetaModelLibraryHasImportedLibrary
			foreach (global::Tum.PDE.LanguageDSL.MetaModelLibraryHasImportedLibrary link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.MetaModelLibraryHasImportedLibrary>(this, global::Tum.PDE.LanguageDSL.MetaModelLibraryHasImportedLibrary.MetaModelLibraryDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewEmbeddingLink(protoLink);
				
				DslEditorModeling::ModelProtoElement protoElementRS = new DslEditorModeling::ModelProtoElement(link.BaseMetaModel);
				protoGroup.AddNewElement(protoElementRS);
				
				// continue with target element
				if( link.BaseMetaModel is DslEditorModeling::IModelMergeElements )
				{
					(link.BaseMetaModel as DslEditorModeling::IModelMergeElements).ModelCreateMergeCopy(protoGroup);
				}
			}
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public virtual bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.BaseMetaModel.DomainClassId)) 
				{
					// Check that creating a link with this path doesn't cause multiplicity overflow: MetaModelLibraryHasImportedLibrary.BaseMetaModel
					if( DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Tum.PDE.LanguageDSL.MetaModelLibraryHasImportedLibrary.MetaModelLibraryDomainRoleId) != null )
						return false;
					return true;
				}
			}
			return false;
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public virtual void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to MetaModelLibrary because paste is not allowed."));
				return;
			}
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.BaseMetaModel.DomainClassId)) 
				{
					// get element id
					System.Guid newElementId = System.Guid.NewGuid();
					
					// create property assignments
					DslModeling::PropertyAssignment[] propertyAssignemnts = protoElement.GetPropertyAssignments(this.Store.DefaultPartition, newElementId);
					
		            // create the actual model element
					global::Tum.PDE.LanguageDSL.BaseMetaModel element = null;			
					if( global::Tum.PDE.LanguageDSL.MetaModel.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.MetaModel(this.Store, propertyAssignemnts);
					if( element == null )
						throw new System.ArgumentNullException("Element is null in ModelMerge: " + elementDomainInfo.Name);
					
					if( !element.ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
					{
						// add warning message
						groupMerger.MergeResult.AddMessage(new DslEditorModeling.ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to MetaModelLibrary because paste is not allowed."));
						
						element.Delete();
						return;
		 			}
					
					if( isRoot && groupMerger.ProtoGroup.Operation != DslEditorModeling.ModelProtoGroupOperation.Move)
					{
						//element.Name = "Copy of " + element.Name;
					}
					
					// update id mapping
					groupMerger.SetIdMapping(protoElement.ElementId, newElementId);
					
					// add child element
					DslModeling::DomainRoleInfo.SetLinkedElement(this, global::Tum.PDE.LanguageDSL.MetaModelLibraryHasImportedLibrary.MetaModelLibraryDomainRoleId, element);
		
					// continue with child elements (Embedding Relationship)
					System.Collections.Generic.List<DslEditorModeling::ModelProtoElement> embeddedProtoElements = groupMerger.GetEmbeddedElements(this.Store.DefaultPartition, protoElement);
					if( embeddedProtoElements.Count > 0 )
					{
						foreach (DslEditorModeling::ModelProtoElement p in embeddedProtoElements)
							(element as DslEditorModeling::IModelMergeElements).ModelMerge(p, groupMerger, false);
					}
				}
			}
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to MetaModelLibrary because move is not allowed."));
				return;
			}
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.BaseMetaModel.DomainClassId)) 
				{
		            DslModeling::ModelElement modelElement = this.Store.ElementDirectory.FindElement(protoElement.ElementId);
		            if( modelElement == null )
		            {
		                groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementMissingOnMoveId",
				             DslEditorModeling.ModelValidationViolationType.Error, "Element exists although the operation = Move."));
		                return;
					}
		
					// change parent
					DslModeling::DomainRoleInfo.SetLinkedElement(modelElement, global::Tum.PDE.LanguageDSL.MetaModelLibraryHasImportedLibrary.BaseMetaModelDomainRoleId, this);
					return;
				}
			}
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class BaseMetaModel : Tum.PDE.LanguageDSL.CopyPaste.IModelMergeElements
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public virtual bool ModelIsCopyAllowed()
		{
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public virtual bool ModelIsMoveAllowed()
		{
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public virtual bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public virtual DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public virtual DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public virtual void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public virtual bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return false;
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public virtual void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to BaseMetaModel because paste is not allowed."));
				return;
			}
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to BaseMetaModel because move is not allowed."));
				return;
			}
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class ViewContext : BaseViewContext
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
			// ViewContextHasDomainModelTreeView
			foreach (global::Tum.PDE.LanguageDSL.ViewContextHasDomainModelTreeView link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.ViewContextHasDomainModelTreeView>(this, global::Tum.PDE.LanguageDSL.ViewContextHasDomainModelTreeView.ViewContextDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewEmbeddingLink(protoLink);
				
				DslEditorModeling::ModelProtoElement protoElementRS = new DslEditorModeling::ModelProtoElement(link.DomainModelTreeView);
				protoGroup.AddNewElement(protoElementRS);
				
				// continue with target element
				if( link.DomainModelTreeView is DslEditorModeling::IModelMergeElements )
				{
					(link.DomainModelTreeView as DslEditorModeling::IModelMergeElements).ModelCreateMergeCopy(protoGroup);
				}
			}
			// ViewContextHasDiagramView
			foreach (global::Tum.PDE.LanguageDSL.ViewContextHasDiagramView link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.ViewContextHasDiagramView>(this, global::Tum.PDE.LanguageDSL.ViewContextHasDiagramView.ViewContextDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewEmbeddingLink(protoLink);
				
				DslEditorModeling::ModelProtoElement protoElementRS = new DslEditorModeling::ModelProtoElement(link.DiagramView);
				protoGroup.AddNewElement(protoElementRS);
				
				// continue with target element
				if( link.DiagramView is DslEditorModeling::IModelMergeElements )
				{
					(link.DiagramView as DslEditorModeling::IModelMergeElements).ModelCreateMergeCopy(protoGroup);
				}
			}
			// ViewContextReferencesModelContext
			foreach (global::Tum.PDE.LanguageDSL.ViewContextReferencesModelContext link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.ViewContextReferencesModelContext>(this, global::Tum.PDE.LanguageDSL.ViewContextReferencesModelContext.ViewContextDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewReferenceLink(protoLink);
			}
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.DomainModelTreeView.DomainClassId)) 
				{
					// Check that creating a link with this path doesn't cause multiplicity overflow: ViewContextHasDomainModelTreeView.DomainModelTreeView
					if( DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Tum.PDE.LanguageDSL.ViewContextHasDomainModelTreeView.ViewContextDomainRoleId) != null )
						return false;
					return true;
				}
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.DiagramView.DomainClassId)) 
				{
					// Check that creating a link with this path doesn't cause multiplicity overflow: ViewContextHasDiagramView.DiagramView
					if( DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Tum.PDE.LanguageDSL.ViewContextHasDiagramView.ViewContextDomainRoleId) != null )
						return false;
					return true;
				}
			}
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to ViewContext because paste is not allowed."));
				return;
			}
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.DomainModelTreeView.DomainClassId)) 
				{
					// get element id
					System.Guid newElementId = System.Guid.NewGuid();
					
					// create property assignments
					DslModeling::PropertyAssignment[] propertyAssignemnts = protoElement.GetPropertyAssignments(this.Store.DefaultPartition, newElementId);
					
		            // create the actual model element
					global::Tum.PDE.LanguageDSL.DomainModelTreeView element = null;			
					if( global::Tum.PDE.LanguageDSL.DomainModelTreeView.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.DomainModelTreeView(this.Store, propertyAssignemnts);
					if( element == null )
						throw new System.ArgumentNullException("Element is null in ModelMerge: " + elementDomainInfo.Name);
					
					if( !element.ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
					{
						// add warning message
						groupMerger.MergeResult.AddMessage(new DslEditorModeling.ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to ViewContext because paste is not allowed."));
						
						element.Delete();
						return;
		 			}
					
					if( isRoot && groupMerger.ProtoGroup.Operation != DslEditorModeling.ModelProtoGroupOperation.Move)
					{
						//element.Name = "Copy of " + element.Name;
					}
					
					// update id mapping
					groupMerger.SetIdMapping(protoElement.ElementId, newElementId);
					
					// add child element
					DslModeling::DomainRoleInfo.SetLinkedElement(this, global::Tum.PDE.LanguageDSL.ViewContextHasDomainModelTreeView.ViewContextDomainRoleId, element);
		
					// continue with child elements (Embedding Relationship)
					System.Collections.Generic.List<DslEditorModeling::ModelProtoElement> embeddedProtoElements = groupMerger.GetEmbeddedElements(this.Store.DefaultPartition, protoElement);
					if( embeddedProtoElements.Count > 0 )
					{
						foreach (DslEditorModeling::ModelProtoElement p in embeddedProtoElements)
							(element as DslEditorModeling::IModelMergeElements).ModelMerge(p, groupMerger, false);
					}
				}
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.DiagramView.DomainClassId)) 
				{
					// get element id
					System.Guid newElementId = System.Guid.NewGuid();
					
					// create property assignments
					DslModeling::PropertyAssignment[] propertyAssignemnts = protoElement.GetPropertyAssignments(this.Store.DefaultPartition, newElementId);
					
		            // create the actual model element
					global::Tum.PDE.LanguageDSL.DiagramView element = null;			
					if( global::Tum.PDE.LanguageDSL.DiagramView.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.DiagramView(this.Store, propertyAssignemnts);
					if( element == null )
						throw new System.ArgumentNullException("Element is null in ModelMerge: " + elementDomainInfo.Name);
					
					if( !element.ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
					{
						// add warning message
						groupMerger.MergeResult.AddMessage(new DslEditorModeling.ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to ViewContext because paste is not allowed."));
						
						element.Delete();
						return;
		 			}
					
					if( isRoot && groupMerger.ProtoGroup.Operation != DslEditorModeling.ModelProtoGroupOperation.Move)
					{
						//element.Name = "Copy of " + element.Name;
					}
					
					// update id mapping
					groupMerger.SetIdMapping(protoElement.ElementId, newElementId);
					
					// add child element
					DslModeling::DomainRoleInfo.SetLinkedElement(this, global::Tum.PDE.LanguageDSL.ViewContextHasDiagramView.ViewContextDomainRoleId, element);
		
					// continue with child elements (Embedding Relationship)
					System.Collections.Generic.List<DslEditorModeling::ModelProtoElement> embeddedProtoElements = groupMerger.GetEmbeddedElements(this.Store.DefaultPartition, protoElement);
					if( embeddedProtoElements.Count > 0 )
					{
						foreach (DslEditorModeling::ModelProtoElement p in embeddedProtoElements)
							(element as DslEditorModeling::IModelMergeElements).ModelMerge(p, groupMerger, false);
					}
				}
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			DslModeling::DomainRelationshipInfo linkDomainInfo = null;
			if (protoLink != null)
			{
				linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(protoLink.DomainClassId);
			}
			else
			{
				// try getting the linkDomainInfo from name
				if( protoLink.Name == "ViewContextReferencesModelContext" && linkDomainInfo == null)
				{
					linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(ViewContextReferencesModelContext.DomainClassId);
				}
			}
			
			if( linkDomainInfo == null )
			{
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkDomainTypeMissing",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link can not be created as the corresponding domain type is missing."));
				return;
			}
		
				if (linkDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.ViewContextReferencesModelContext.DomainClassId)) 
				{
					// see if this element is taking part in this role
					bool bTakesPart = false;
					
					DslEditorModeling::ModelProtoRolePlayer sourceRolePlayer = protoLink.GetSourceRolePlayer(this.Store.DefaultPartition);
					DslEditorModeling::ModelProtoElement sourceProtoElement = groupMerger.GetElementById(sourceRolePlayer.RolePlayerId);
					System.Guid mappedSourceIdTP = System.Guid.Empty;
					if( sourceProtoElement != null )
					{
						mappedSourceIdTP = groupMerger.GetIdMapping(sourceRolePlayer.RolePlayerId);
						if( mappedSourceIdTP == this.Id )
							bTakesPart = true;
					}
		
					if( bTakesPart )
					{		
						bool bExists = true;
		        	    if( this.Store.ElementDirectory.FindElement(protoLink.ElementId) == null )
		        	        bExists = false;
							
						if( bExists && groupMerger.ProtoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
		        	    {
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkExistsOnMoveId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link exists although the operation = Move."));
						}
						
						#region Target
						// see if target element was copied
						DslEditorModeling::ModelProtoRolePlayer targetRolePlayer = protoLink.GetTargetRolePlayer(this.Store.DefaultPartition);
						DslEditorModeling::ModelProtoElement targetProtoElement = groupMerger.GetElementById(targetRolePlayer.RolePlayerId);
						System.Guid mappedTargetId = System.Guid.Empty;
						if( targetProtoElement != null )
						{
						 	mappedTargetId= groupMerger.GetIdMapping(targetRolePlayer.RolePlayerId);
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element
							mappedTargetId = targetRolePlayer.RolePlayerId;
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element with the same name as the previous element
							// TODO
						}
		
						if( mappedTargetId == System.Guid.Empty )
						{
							// log warning
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotCopiedId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not copied. Relationship: ViewContextReferencesModelContext"));
						}
						else
						{
							DslModeling::ModelElement targetElement = this.Store.ElementDirectory.FindElement(mappedTargetId);
							if( targetElement == null )
							{
								// log error
		        	        	groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotFoundId",
					            	DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not found. Relationship: ViewContextReferencesModelContext"));
							}
							else
							{
								bool bContinue = true;
		
								// check cardinalities, so we don't violate them by additing a new relationship
								if( DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Tum.PDE.LanguageDSL.ViewContextReferencesModelContext.ViewContextDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: ViewContextReferencesModelContext"));
									
									bContinue = false;
								}
								if( DslModeling::DomainRoleInfo.GetLinkedElement(targetElement, global::Tum.PDE.LanguageDSL.ViewContextReferencesModelContext.LibraryModelContextDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: ViewContextReferencesModelContext"));
									
									bContinue = false;
								}
								
								if( bContinue )
								{
									// create property assignments
									DslModeling::PropertyAssignment[] propertyAssignemnts = protoLink.GetPropertyAssignments(this.Store.DefaultPartition, 
										System.Guid.NewGuid());
								
									// create role assignments
									DslModeling.RoleAssignment[] roleAssignments = new DslModeling.RoleAssignment[2];
		                	        roleAssignments[0] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.ViewContextReferencesModelContext.ViewContextDomainRoleId, this);
									roleAssignments[1] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.ViewContextReferencesModelContext.LibraryModelContextDomainRoleId, targetElement);
									
									// create new relationship
									new global::Tum.PDE.LanguageDSL.ViewContextReferencesModelContext(this.Store, roleAssignments, propertyAssignemnts);
								}
							}
						}
						#endregion
					}
				}
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to ViewContext because move is not allowed."));
				return;
			}
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.DomainModelTreeView.DomainClassId)) 
				{
		            DslModeling::ModelElement modelElement = this.Store.ElementDirectory.FindElement(protoElement.ElementId);
		            if( modelElement == null )
		            {
		                groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementMissingOnMoveId",
				             DslEditorModeling.ModelValidationViolationType.Error, "Element exists although the operation = Move."));
		                return;
					}
		
					// change parent
					DslModeling::DomainRoleInfo.SetLinkedElement(modelElement, global::Tum.PDE.LanguageDSL.ViewContextHasDomainModelTreeView.DomainModelTreeViewDomainRoleId, this);
					return;
				}
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.DiagramView.DomainClassId)) 
				{
		            DslModeling::ModelElement modelElement = this.Store.ElementDirectory.FindElement(protoElement.ElementId);
		            if( modelElement == null )
		            {
		                groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementMissingOnMoveId",
				             DslEditorModeling.ModelValidationViolationType.Error, "Element exists although the operation = Move."));
		                return;
					}
		
					// change parent
					DslModeling::DomainRoleInfo.SetLinkedElement(modelElement, global::Tum.PDE.LanguageDSL.ViewContextHasDiagramView.DiagramViewDomainRoleId, this);
					return;
				}
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class LibraryModelContextBase : BaseModelContext
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
			// LibraryModelContextHasClasses
			foreach (global::Tum.PDE.LanguageDSL.LibraryModelContextHasClasses link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.LibraryModelContextHasClasses>(this, global::Tum.PDE.LanguageDSL.LibraryModelContextHasClasses.LibraryModelContextDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewEmbeddingLink(protoLink);
				
				DslEditorModeling::ModelProtoElement protoElementRS = new DslEditorModeling::ModelProtoElement(link.DomainClass);
				protoGroup.AddNewElement(protoElementRS);
				
				// continue with target element
				if( link.DomainClass is DslEditorModeling::IModelMergeElements )
				{
					(link.DomainClass as DslEditorModeling::IModelMergeElements).ModelCreateMergeCopy(protoGroup);
				}
			}
			// LibraryModelContextHasDiagramClasses
			foreach (global::Tum.PDE.LanguageDSL.LibraryModelContextHasDiagramClasses link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.LibraryModelContextHasDiagramClasses>(this, global::Tum.PDE.LanguageDSL.LibraryModelContextHasDiagramClasses.LibraryModelContextDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewEmbeddingLink(protoLink);
				
				DslEditorModeling::ModelProtoElement protoElementRS = new DslEditorModeling::ModelProtoElement(link.DiagramClass);
				protoGroup.AddNewElement(protoElementRS);
				
				// continue with target element
				if( link.DiagramClass is DslEditorModeling::IModelMergeElements )
				{
					(link.DiagramClass as DslEditorModeling::IModelMergeElements).ModelCreateMergeCopy(protoGroup);
				}
			}
			// LibraryModelContextHasRelationships
			foreach (global::Tum.PDE.LanguageDSL.LibraryModelContextHasRelationships link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.LibraryModelContextHasRelationships>(this, global::Tum.PDE.LanguageDSL.LibraryModelContextHasRelationships.LibraryModelContextDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewEmbeddingLink(protoLink);
				
				DslEditorModeling::ModelProtoElement protoElementRS = new DslEditorModeling::ModelProtoElement(link.DomainRelationship);
				protoGroup.AddNewElement(protoElementRS);
				
				// continue with target element
				if( link.DomainRelationship is DslEditorModeling::IModelMergeElements )
				{
					(link.DomainRelationship as DslEditorModeling::IModelMergeElements).ModelCreateMergeCopy(protoGroup);
				}
			}
			// LibraryModelContextHasSerializationModel
			foreach (global::Tum.PDE.LanguageDSL.LibraryModelContextHasSerializationModel link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.LibraryModelContextHasSerializationModel>(this, global::Tum.PDE.LanguageDSL.LibraryModelContextHasSerializationModel.LibraryModelContextDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewEmbeddingLink(protoLink);
				
				DslEditorModeling::ModelProtoElement protoElementRS = new DslEditorModeling::ModelProtoElement(link.SerializationModel);
				protoGroup.AddNewElement(protoElementRS);
				
				// continue with target element
				if( link.SerializationModel is DslEditorModeling::IModelMergeElements )
				{
					(link.SerializationModel as DslEditorModeling::IModelMergeElements).ModelCreateMergeCopy(protoGroup);
				}
			}
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.DomainClass.DomainClassId)) 
				{
					if( protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
					{
						foreach (global::Tum.PDE.LanguageDSL.LibraryModelContextHasClasses link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.LibraryModelContextHasClasses>(this, global::Tum.PDE.LanguageDSL.LibraryModelContextHasClasses.LibraryModelContextDomainRoleId))				
							if( link.DomainClass.Id == protoElement.ElementId )
								return false;
					}
					return true;
				}
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.DiagramClass.DomainClassId)) 
				{
					if( protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
					{
						foreach (global::Tum.PDE.LanguageDSL.LibraryModelContextHasDiagramClasses link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.LibraryModelContextHasDiagramClasses>(this, global::Tum.PDE.LanguageDSL.LibraryModelContextHasDiagramClasses.LibraryModelContextDomainRoleId))				
							if( link.DiagramClass.Id == protoElement.ElementId )
								return false;
					}
					return true;
				}
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.DomainRelationship.DomainClassId)) 
				{
					if( protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
					{
						foreach (global::Tum.PDE.LanguageDSL.LibraryModelContextHasRelationships link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.LibraryModelContextHasRelationships>(this, global::Tum.PDE.LanguageDSL.LibraryModelContextHasRelationships.LibraryModelContextDomainRoleId))				
							if( link.DomainRelationship.Id == protoElement.ElementId )
								return false;
					}
					return true;
				}
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.SerializationModel.DomainClassId)) 
				{
					// Check that creating a link with this path doesn't cause multiplicity overflow: LibraryModelContextHasSerializationModel.SerializationModel
					if( DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Tum.PDE.LanguageDSL.LibraryModelContextHasSerializationModel.LibraryModelContextDomainRoleId) != null )
						return false;
					return true;
				}
			}
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to LibraryModelContext because paste is not allowed."));
				return;
			}
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.DomainClass.DomainClassId)) 
				{
					// get element id
					System.Guid newElementId = System.Guid.NewGuid();
					
					// create property assignments
					DslModeling::PropertyAssignment[] propertyAssignemnts = protoElement.GetPropertyAssignments(this.Store.DefaultPartition, newElementId);
					
		            // create the actual model element
					global::Tum.PDE.LanguageDSL.DomainClass element = null;			
					if( global::Tum.PDE.LanguageDSL.DomainClass.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.DomainClass(this.Store, propertyAssignemnts);
					if( element == null )
						throw new System.ArgumentNullException("Element is null in ModelMerge: " + elementDomainInfo.Name);
					
					if( !element.ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
					{
						// add warning message
						groupMerger.MergeResult.AddMessage(new DslEditorModeling.ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to LibraryModelContext because paste is not allowed."));
						
						element.Delete();
						return;
		 			}
					
					if( isRoot && groupMerger.ProtoGroup.Operation != DslEditorModeling.ModelProtoGroupOperation.Move)
					{
						//element.Name = "Copy of " + element.Name;
					}
					
					// update id mapping
					groupMerger.SetIdMapping(protoElement.ElementId, newElementId);
					
					// add child element
					GetRoleCollection<DslModeling::LinkedElementCollection<global::Tum.PDE.LanguageDSL.DomainClass>, global::Tum.PDE.LanguageDSL.DomainClass>(global::Tum.PDE.LanguageDSL.LibraryModelContextHasClasses.LibraryModelContextDomainRoleId).Add(element);
		
					// continue with child elements (Embedding Relationship)
					System.Collections.Generic.List<DslEditorModeling::ModelProtoElement> embeddedProtoElements = groupMerger.GetEmbeddedElements(this.Store.DefaultPartition, protoElement);
					if( embeddedProtoElements.Count > 0 )
					{
						foreach (DslEditorModeling::ModelProtoElement p in embeddedProtoElements)
							(element as DslEditorModeling::IModelMergeElements).ModelMerge(p, groupMerger, false);
					}
				}
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.DiagramClass.DomainClassId)) 
				{
					// get element id
					System.Guid newElementId = System.Guid.NewGuid();
					
					// create property assignments
					DslModeling::PropertyAssignment[] propertyAssignemnts = protoElement.GetPropertyAssignments(this.Store.DefaultPartition, newElementId);
					
		            // create the actual model element
					global::Tum.PDE.LanguageDSL.DiagramClass element = null;			
					if( global::Tum.PDE.LanguageDSL.DiagramClass.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.DiagramClass(this.Store, propertyAssignemnts);
					if( global::Tum.PDE.LanguageDSL.DesignerDiagramClass.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.DesignerDiagramClass(this.Store, propertyAssignemnts);
					if( global::Tum.PDE.LanguageDSL.TemplatedDiagramClass.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.TemplatedDiagramClass(this.Store, propertyAssignemnts);
					if( global::Tum.PDE.LanguageDSL.DependencyDiagram.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.DependencyDiagram(this.Store, propertyAssignemnts);
					if( global::Tum.PDE.LanguageDSL.SpecificDependencyDiagram.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.SpecificDependencyDiagram(this.Store, propertyAssignemnts);
					if( global::Tum.PDE.LanguageDSL.DesignerSurfaceDiagram.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.DesignerSurfaceDiagram(this.Store, propertyAssignemnts);
					if( global::Tum.PDE.LanguageDSL.ModalDiagram.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.ModalDiagram(this.Store, propertyAssignemnts);
					if( global::Tum.PDE.LanguageDSL.SpecificElementsDiagram.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.SpecificElementsDiagram(this.Store, propertyAssignemnts);
					if( element == null )
						throw new System.ArgumentNullException("Element is null in ModelMerge: " + elementDomainInfo.Name);
					
					if( !element.ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
					{
						// add warning message
						groupMerger.MergeResult.AddMessage(new DslEditorModeling.ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to LibraryModelContext because paste is not allowed."));
						
						element.Delete();
						return;
		 			}
					
					if( isRoot && groupMerger.ProtoGroup.Operation != DslEditorModeling.ModelProtoGroupOperation.Move)
					{
						//element.Name = "Copy of " + element.Name;
					}
					
					// update id mapping
					groupMerger.SetIdMapping(protoElement.ElementId, newElementId);
					
					// add child element
					GetRoleCollection<DslModeling::LinkedElementCollection<global::Tum.PDE.LanguageDSL.DiagramClass>, global::Tum.PDE.LanguageDSL.DiagramClass>(global::Tum.PDE.LanguageDSL.LibraryModelContextHasDiagramClasses.LibraryModelContextDomainRoleId).Add(element);
		
					// continue with child elements (Embedding Relationship)
					System.Collections.Generic.List<DslEditorModeling::ModelProtoElement> embeddedProtoElements = groupMerger.GetEmbeddedElements(this.Store.DefaultPartition, protoElement);
					if( embeddedProtoElements.Count > 0 )
					{
						foreach (DslEditorModeling::ModelProtoElement p in embeddedProtoElements)
							(element as DslEditorModeling::IModelMergeElements).ModelMerge(p, groupMerger, false);
					}
				}
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.DomainRelationship.DomainClassId)) 
				{
					// get element id
					System.Guid newElementId = System.Guid.NewGuid();
					
					// create property assignments
					DslModeling::PropertyAssignment[] propertyAssignemnts = protoElement.GetPropertyAssignments(this.Store.DefaultPartition, newElementId);
					
		            // create the actual model element
					global::Tum.PDE.LanguageDSL.DomainRelationship element = null;			
					if( global::Tum.PDE.LanguageDSL.EmbeddingRelationship.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.EmbeddingRelationship(this.Store, propertyAssignemnts);
					if( global::Tum.PDE.LanguageDSL.ReferenceRelationship.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.ReferenceRelationship(this.Store, propertyAssignemnts);
					if( element == null )
						throw new System.ArgumentNullException("Element is null in ModelMerge: " + elementDomainInfo.Name);
					
					if( !element.ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
					{
						// add warning message
						groupMerger.MergeResult.AddMessage(new DslEditorModeling.ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to LibraryModelContext because paste is not allowed."));
						
						element.Delete();
						return;
		 			}
					
					if( isRoot && groupMerger.ProtoGroup.Operation != DslEditorModeling.ModelProtoGroupOperation.Move)
					{
						//element.Name = "Copy of " + element.Name;
					}
					
					// update id mapping
					groupMerger.SetIdMapping(protoElement.ElementId, newElementId);
					
					// add child element
					GetRoleCollection<DslModeling::LinkedElementCollection<global::Tum.PDE.LanguageDSL.DomainRelationship>, global::Tum.PDE.LanguageDSL.DomainRelationship>(global::Tum.PDE.LanguageDSL.LibraryModelContextHasRelationships.LibraryModelContextDomainRoleId).Add(element);
		
					// continue with child elements (Embedding Relationship)
					System.Collections.Generic.List<DslEditorModeling::ModelProtoElement> embeddedProtoElements = groupMerger.GetEmbeddedElements(this.Store.DefaultPartition, protoElement);
					if( embeddedProtoElements.Count > 0 )
					{
						foreach (DslEditorModeling::ModelProtoElement p in embeddedProtoElements)
							(element as DslEditorModeling::IModelMergeElements).ModelMerge(p, groupMerger, false);
					}
				}
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.SerializationModel.DomainClassId)) 
				{
					// get element id
					System.Guid newElementId = System.Guid.NewGuid();
					
					// create property assignments
					DslModeling::PropertyAssignment[] propertyAssignemnts = protoElement.GetPropertyAssignments(this.Store.DefaultPartition, newElementId);
					
		            // create the actual model element
					global::Tum.PDE.LanguageDSL.SerializationModel element = null;			
					if( global::Tum.PDE.LanguageDSL.SerializationModel.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.SerializationModel(this.Store, propertyAssignemnts);
					if( element == null )
						throw new System.ArgumentNullException("Element is null in ModelMerge: " + elementDomainInfo.Name);
					
					if( !element.ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
					{
						// add warning message
						groupMerger.MergeResult.AddMessage(new DslEditorModeling.ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to LibraryModelContext because paste is not allowed."));
						
						element.Delete();
						return;
		 			}
					
					if( isRoot && groupMerger.ProtoGroup.Operation != DslEditorModeling.ModelProtoGroupOperation.Move)
					{
						//element.Name = "Copy of " + element.Name;
					}
					
					// update id mapping
					groupMerger.SetIdMapping(protoElement.ElementId, newElementId);
					
					// add child element
					DslModeling::DomainRoleInfo.SetLinkedElement(this, global::Tum.PDE.LanguageDSL.LibraryModelContextHasSerializationModel.LibraryModelContextDomainRoleId, element);
		
					// continue with child elements (Embedding Relationship)
					System.Collections.Generic.List<DslEditorModeling::ModelProtoElement> embeddedProtoElements = groupMerger.GetEmbeddedElements(this.Store.DefaultPartition, protoElement);
					if( embeddedProtoElements.Count > 0 )
					{
						foreach (DslEditorModeling::ModelProtoElement p in embeddedProtoElements)
							(element as DslEditorModeling::IModelMergeElements).ModelMerge(p, groupMerger, false);
					}
				}
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			DslModeling::DomainRelationshipInfo linkDomainInfo = null;
			if (protoLink != null)
			{
				linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(protoLink.DomainClassId);
			}
			else
			{
				// try getting the linkDomainInfo from name
			}
			
			if( linkDomainInfo == null )
			{
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkDomainTypeMissing",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link can not be created as the corresponding domain type is missing."));
				return;
			}
		
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to LibraryModelContext because move is not allowed."));
				return;
			}
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.DomainClass.DomainClassId)) 
				{
		            DslModeling::ModelElement modelElement = this.Store.ElementDirectory.FindElement(protoElement.ElementId);
		            if( modelElement == null )
		            {
		                groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementMissingOnMoveId",
				             DslEditorModeling.ModelValidationViolationType.Error, "Element exists although the operation = Move."));
		                return;
					}
		
					// change parent
					DslModeling::DomainRoleInfo.SetLinkedElement(modelElement, global::Tum.PDE.LanguageDSL.LibraryModelContextHasClasses.DomainClassDomainRoleId, this);
					return;
				}
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.DiagramClass.DomainClassId)) 
				{
		            DslModeling::ModelElement modelElement = this.Store.ElementDirectory.FindElement(protoElement.ElementId);
		            if( modelElement == null )
		            {
		                groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementMissingOnMoveId",
				             DslEditorModeling.ModelValidationViolationType.Error, "Element exists although the operation = Move."));
		                return;
					}
		
					// change parent
					DslModeling::DomainRoleInfo.SetLinkedElement(modelElement, global::Tum.PDE.LanguageDSL.LibraryModelContextHasDiagramClasses.DiagramClassDomainRoleId, this);
					return;
				}
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.DomainRelationship.DomainClassId)) 
				{
		            DslModeling::ModelElement modelElement = this.Store.ElementDirectory.FindElement(protoElement.ElementId);
		            if( modelElement == null )
		            {
		                groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementMissingOnMoveId",
				             DslEditorModeling.ModelValidationViolationType.Error, "Element exists although the operation = Move."));
		                return;
					}
		
					// change parent
					DslModeling::DomainRoleInfo.SetLinkedElement(modelElement, global::Tum.PDE.LanguageDSL.LibraryModelContextHasRelationships.DomainRelationshipDomainRoleId, this);
					return;
				}
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.SerializationModel.DomainClassId)) 
				{
		            DslModeling::ModelElement modelElement = this.Store.ElementDirectory.FindElement(protoElement.ElementId);
		            if( modelElement == null )
		            {
		                groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementMissingOnMoveId",
				             DslEditorModeling.ModelValidationViolationType.Error, "Element exists although the operation = Move."));
		                return;
					}
		
					// change parent
					DslModeling::DomainRoleInfo.SetLinkedElement(modelElement, global::Tum.PDE.LanguageDSL.LibraryModelContextHasSerializationModel.SerializationModelDomainRoleId, this);
					return;
				}
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class View : Tum.PDE.LanguageDSL.CopyPaste.IModelMergeElements
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public virtual bool ModelIsCopyAllowed()
		{
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public virtual bool ModelIsMoveAllowed()
		{
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public virtual bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public virtual DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public virtual DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public virtual void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			// ViewHasViewContexts
			foreach (global::Tum.PDE.LanguageDSL.ViewHasViewContexts link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.ViewHasViewContexts>(this, global::Tum.PDE.LanguageDSL.ViewHasViewContexts.ViewDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewEmbeddingLink(protoLink);
				
				DslEditorModeling::ModelProtoElement protoElementRS = new DslEditorModeling::ModelProtoElement(link.BaseViewContext);
				protoGroup.AddNewElement(protoElementRS);
				
				// continue with target element
				if( link.BaseViewContext is DslEditorModeling::IModelMergeElements )
				{
					(link.BaseViewContext as DslEditorModeling::IModelMergeElements).ModelCreateMergeCopy(protoGroup);
				}
			}
			// ViewHasModelTree
			foreach (global::Tum.PDE.LanguageDSL.ViewHasModelTree link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.ViewHasModelTree>(this, global::Tum.PDE.LanguageDSL.ViewHasModelTree.ViewDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewEmbeddingLink(protoLink);
				
				DslEditorModeling::ModelProtoElement protoElementRS = new DslEditorModeling::ModelProtoElement(link.ModelTree);
				protoGroup.AddNewElement(protoElementRS);
				
				// continue with target element
				if( link.ModelTree is DslEditorModeling::IModelMergeElements )
				{
					(link.ModelTree as DslEditorModeling::IModelMergeElements).ModelCreateMergeCopy(protoGroup);
				}
			}
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public virtual bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.BaseViewContext.DomainClassId)) 
				{
					if( protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
					{
						foreach (global::Tum.PDE.LanguageDSL.ViewHasViewContexts link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.ViewHasViewContexts>(this, global::Tum.PDE.LanguageDSL.ViewHasViewContexts.ViewDomainRoleId))				
							if( link.BaseViewContext.Id == protoElement.ElementId )
								return false;
					}
					return true;
				}
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.ModelTree.DomainClassId)) 
				{
					// Check that creating a link with this path doesn't cause multiplicity overflow: ViewHasModelTree.ModelTree
					if( DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Tum.PDE.LanguageDSL.ViewHasModelTree.ViewDomainRoleId) != null )
						return false;
					return true;
				}
			}
			return false;
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public virtual void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to View because paste is not allowed."));
				return;
			}
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.BaseViewContext.DomainClassId)) 
				{
					// get element id
					System.Guid newElementId = System.Guid.NewGuid();
					
					// create property assignments
					DslModeling::PropertyAssignment[] propertyAssignemnts = protoElement.GetPropertyAssignments(this.Store.DefaultPartition, newElementId);
					
		            // create the actual model element
					global::Tum.PDE.LanguageDSL.BaseViewContext element = null;			
					if( global::Tum.PDE.LanguageDSL.ViewContext.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.ViewContext(this.Store, propertyAssignemnts);
					if( global::Tum.PDE.LanguageDSL.ExternViewContext.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.ExternViewContext(this.Store, propertyAssignemnts);
					if( element == null )
						throw new System.ArgumentNullException("Element is null in ModelMerge: " + elementDomainInfo.Name);
					
					if( !element.ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
					{
						// add warning message
						groupMerger.MergeResult.AddMessage(new DslEditorModeling.ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to View because paste is not allowed."));
						
						element.Delete();
						return;
		 			}
					
					if( isRoot && groupMerger.ProtoGroup.Operation != DslEditorModeling.ModelProtoGroupOperation.Move)
					{
						//element.Name = "Copy of " + element.Name;
					}
					
					// update id mapping
					groupMerger.SetIdMapping(protoElement.ElementId, newElementId);
					
					// add child element
					GetRoleCollection<DslModeling::LinkedElementCollection<global::Tum.PDE.LanguageDSL.BaseViewContext>, global::Tum.PDE.LanguageDSL.BaseViewContext>(global::Tum.PDE.LanguageDSL.ViewHasViewContexts.ViewDomainRoleId).Add(element);
		
					// continue with child elements (Embedding Relationship)
					System.Collections.Generic.List<DslEditorModeling::ModelProtoElement> embeddedProtoElements = groupMerger.GetEmbeddedElements(this.Store.DefaultPartition, protoElement);
					if( embeddedProtoElements.Count > 0 )
					{
						foreach (DslEditorModeling::ModelProtoElement p in embeddedProtoElements)
							(element as DslEditorModeling::IModelMergeElements).ModelMerge(p, groupMerger, false);
					}
				}
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.ModelTree.DomainClassId)) 
				{
					// get element id
					System.Guid newElementId = System.Guid.NewGuid();
					
					// create property assignments
					DslModeling::PropertyAssignment[] propertyAssignemnts = protoElement.GetPropertyAssignments(this.Store.DefaultPartition, newElementId);
					
		            // create the actual model element
					global::Tum.PDE.LanguageDSL.ModelTree element = null;			
					if( global::Tum.PDE.LanguageDSL.ModelTree.DomainClassId == elementDomainInfo.Id )
						element = new global::Tum.PDE.LanguageDSL.ModelTree(this.Store, propertyAssignemnts);
					if( element == null )
						throw new System.ArgumentNullException("Element is null in ModelMerge: " + elementDomainInfo.Name);
					
					if( !element.ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
					{
						// add warning message
						groupMerger.MergeResult.AddMessage(new DslEditorModeling.ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to View because paste is not allowed."));
						
						element.Delete();
						return;
		 			}
					
					if( isRoot && groupMerger.ProtoGroup.Operation != DslEditorModeling.ModelProtoGroupOperation.Move)
					{
						//element.Name = "Copy of " + element.Name;
					}
					
					// update id mapping
					groupMerger.SetIdMapping(protoElement.ElementId, newElementId);
					
					// add child element
					DslModeling::DomainRoleInfo.SetLinkedElement(this, global::Tum.PDE.LanguageDSL.ViewHasModelTree.ViewDomainRoleId, element);
		
					// continue with child elements (Embedding Relationship)
					System.Collections.Generic.List<DslEditorModeling::ModelProtoElement> embeddedProtoElements = groupMerger.GetEmbeddedElements(this.Store.DefaultPartition, protoElement);
					if( embeddedProtoElements.Count > 0 )
					{
						foreach (DslEditorModeling::ModelProtoElement p in embeddedProtoElements)
							(element as DslEditorModeling::IModelMergeElements).ModelMerge(p, groupMerger, false);
					}
				}
			}
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to View because move is not allowed."));
				return;
			}
			if (protoElement != null)
			{
				DslModeling::DomainClassInfo elementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(protoElement.DomainClassId);
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.BaseViewContext.DomainClassId)) 
				{
		            DslModeling::ModelElement modelElement = this.Store.ElementDirectory.FindElement(protoElement.ElementId);
		            if( modelElement == null )
		            {
		                groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementMissingOnMoveId",
				             DslEditorModeling.ModelValidationViolationType.Error, "Element exists although the operation = Move."));
		                return;
					}
		
					// change parent
					DslModeling::DomainRoleInfo.SetLinkedElement(modelElement, global::Tum.PDE.LanguageDSL.ViewHasViewContexts.BaseViewContextDomainRoleId, this);
					return;
				}
				if (elementDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.ModelTree.DomainClassId)) 
				{
		            DslModeling::ModelElement modelElement = this.Store.ElementDirectory.FindElement(protoElement.ElementId);
		            if( modelElement == null )
		            {
		                groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementMissingOnMoveId",
				             DslEditorModeling.ModelValidationViolationType.Error, "Element exists although the operation = Move."));
		                return;
					}
		
					// change parent
					DslModeling::DomainRoleInfo.SetLinkedElement(modelElement, global::Tum.PDE.LanguageDSL.ViewHasModelTree.ModelTreeDomainRoleId, this);
					return;
				}
			}
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class PropertyGridEditorBase : Tum.PDE.LanguageDSL.CopyPaste.IModelMergeElements
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public virtual bool ModelIsCopyAllowed()
		{
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public virtual bool ModelIsMoveAllowed()
		{
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public virtual bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public virtual DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public virtual DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public virtual void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public virtual bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return false;
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public virtual void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to PropertyGridEditor because paste is not allowed."));
				return;
			}
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			DslModeling::DomainRelationshipInfo linkDomainInfo = null;
			if (protoLink != null)
			{
				linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(protoLink.DomainClassId);
			}
			else
			{
				// try getting the linkDomainInfo from name
			}
			
			if( linkDomainInfo == null )
			{
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkDomainTypeMissing",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link can not be created as the corresponding domain type is missing."));
				return;
			}
		
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to PropertyGridEditor because move is not allowed."));
				return;
			}
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class BaseModelContext : NamedDomainElement
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to BaseModelContext because paste is not allowed."));
				return;
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to BaseModelContext because move is not allowed."));
				return;
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class ExternModelContext : BaseModelContext
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to ExternModelContext because paste is not allowed."));
				return;
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			DslModeling::DomainRelationshipInfo linkDomainInfo = null;
			if (protoLink != null)
			{
				linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(protoLink.DomainClassId);
			}
			else
			{
				// try getting the linkDomainInfo from name
				if( protoLink.Name == "ExternModelContextReferencesModelContext" && linkDomainInfo == null)
				{
					linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(ExternModelContextReferencesModelContext.DomainClassId);
				}
			}
			
			if( linkDomainInfo == null )
			{
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkDomainTypeMissing",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link can not be created as the corresponding domain type is missing."));
				return;
			}
		
				if (linkDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.ExternModelContextReferencesModelContext.DomainClassId)) 
				{
					// see if this element is taking part in this role
					bool bTakesPart = false;
					
					DslEditorModeling::ModelProtoRolePlayer sourceRolePlayer = protoLink.GetSourceRolePlayer(this.Store.DefaultPartition);
					DslEditorModeling::ModelProtoElement sourceProtoElement = groupMerger.GetElementById(sourceRolePlayer.RolePlayerId);
					System.Guid mappedSourceIdTP = System.Guid.Empty;
					if( sourceProtoElement != null )
					{
						mappedSourceIdTP = groupMerger.GetIdMapping(sourceRolePlayer.RolePlayerId);
						if( mappedSourceIdTP == this.Id )
							bTakesPart = true;
					}
		
					if( bTakesPart )
					{		
						bool bExists = true;
		        	    if( this.Store.ElementDirectory.FindElement(protoLink.ElementId) == null )
		        	        bExists = false;
							
						if( bExists && groupMerger.ProtoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
		        	    {
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkExistsOnMoveId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link exists although the operation = Move."));
						}
						
						#region Target
						// see if target element was copied
						DslEditorModeling::ModelProtoRolePlayer targetRolePlayer = protoLink.GetTargetRolePlayer(this.Store.DefaultPartition);
						DslEditorModeling::ModelProtoElement targetProtoElement = groupMerger.GetElementById(targetRolePlayer.RolePlayerId);
						System.Guid mappedTargetId = System.Guid.Empty;
						if( targetProtoElement != null )
						{
						 	mappedTargetId= groupMerger.GetIdMapping(targetRolePlayer.RolePlayerId);
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element
							mappedTargetId = targetRolePlayer.RolePlayerId;
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element with the same name as the previous element
							// TODO
						}
		
						if( mappedTargetId == System.Guid.Empty )
						{
							// log warning
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotCopiedId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not copied. Relationship: ExternModelContextReferencesModelContext"));
						}
						else
						{
							DslModeling::ModelElement targetElement = this.Store.ElementDirectory.FindElement(mappedTargetId);
							if( targetElement == null )
							{
								// log error
		        	        	groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotFoundId",
					            	DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not found. Relationship: ExternModelContextReferencesModelContext"));
							}
							else
							{
								bool bContinue = true;
		
								// check cardinalities, so we don't violate them by additing a new relationship
								if( DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Tum.PDE.LanguageDSL.ExternModelContextReferencesModelContext.ExternModelContextDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: ExternModelContextReferencesModelContext"));
									
									bContinue = false;
								}
								
								if( bContinue )
								{
									// create property assignments
									DslModeling::PropertyAssignment[] propertyAssignemnts = protoLink.GetPropertyAssignments(this.Store.DefaultPartition, 
										System.Guid.NewGuid());
								
									// create role assignments
									DslModeling.RoleAssignment[] roleAssignments = new DslModeling.RoleAssignment[2];
		                	        roleAssignments[0] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.ExternModelContextReferencesModelContext.ExternModelContextDomainRoleId, this);
									roleAssignments[1] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.ExternModelContextReferencesModelContext.ModelContextDomainRoleId, targetElement);
									
									// create new relationship
									new global::Tum.PDE.LanguageDSL.ExternModelContextReferencesModelContext(this.Store, roleAssignments, propertyAssignemnts);
								}
							}
						}
						#endregion
					}
				}
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to ExternModelContext because move is not allowed."));
				return;
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class BaseViewContext : Tum.PDE.LanguageDSL.CopyPaste.IModelMergeElements
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public virtual bool ModelIsCopyAllowed()
		{
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public virtual bool ModelIsMoveAllowed()
		{
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public virtual bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public virtual DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public virtual DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public virtual void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public virtual bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return false;
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public virtual void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to BaseViewContext because paste is not allowed."));
				return;
			}
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to BaseViewContext because move is not allowed."));
				return;
			}
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class ExternViewContext : BaseViewContext
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
			// ExternViewContextReferencesExternModelContext
			foreach (global::Tum.PDE.LanguageDSL.ExternViewContextReferencesExternModelContext link in DslModeling::DomainRoleInfo.GetElementLinks<global::Tum.PDE.LanguageDSL.ExternViewContextReferencesExternModelContext>(this, global::Tum.PDE.LanguageDSL.ExternViewContextReferencesExternModelContext.ExternViewContextDomainRoleId))
			{
				DslEditorModeling::ModelProtoLink protoLink = new DslEditorModeling::ModelProtoLink(link);
				protoGroup.AddNewReferenceLink(protoLink);
			}
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to ExternViewContext because paste is not allowed."));
				return;
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			DslModeling::DomainRelationshipInfo linkDomainInfo = null;
			if (protoLink != null)
			{
				linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(protoLink.DomainClassId);
			}
			else
			{
				// try getting the linkDomainInfo from name
				if( protoLink.Name == "ExternViewContextReferencesExternModelContext" && linkDomainInfo == null)
				{
					linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(ExternViewContextReferencesExternModelContext.DomainClassId);
				}
			}
			
			if( linkDomainInfo == null )
			{
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkDomainTypeMissing",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link can not be created as the corresponding domain type is missing."));
				return;
			}
		
				if (linkDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.ExternViewContextReferencesExternModelContext.DomainClassId)) 
				{
					// see if this element is taking part in this role
					bool bTakesPart = false;
					
					DslEditorModeling::ModelProtoRolePlayer sourceRolePlayer = protoLink.GetSourceRolePlayer(this.Store.DefaultPartition);
					DslEditorModeling::ModelProtoElement sourceProtoElement = groupMerger.GetElementById(sourceRolePlayer.RolePlayerId);
					System.Guid mappedSourceIdTP = System.Guid.Empty;
					if( sourceProtoElement != null )
					{
						mappedSourceIdTP = groupMerger.GetIdMapping(sourceRolePlayer.RolePlayerId);
						if( mappedSourceIdTP == this.Id )
							bTakesPart = true;
					}
		
					if( bTakesPart )
					{		
						bool bExists = true;
		        	    if( this.Store.ElementDirectory.FindElement(protoLink.ElementId) == null )
		        	        bExists = false;
							
						if( bExists && groupMerger.ProtoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
		        	    {
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkExistsOnMoveId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link exists although the operation = Move."));
						}
						
						#region Target
						// see if target element was copied
						DslEditorModeling::ModelProtoRolePlayer targetRolePlayer = protoLink.GetTargetRolePlayer(this.Store.DefaultPartition);
						DslEditorModeling::ModelProtoElement targetProtoElement = groupMerger.GetElementById(targetRolePlayer.RolePlayerId);
						System.Guid mappedTargetId = System.Guid.Empty;
						if( targetProtoElement != null )
						{
						 	mappedTargetId= groupMerger.GetIdMapping(targetRolePlayer.RolePlayerId);
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element
							mappedTargetId = targetRolePlayer.RolePlayerId;
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element with the same name as the previous element
							// TODO
						}
		
						if( mappedTargetId == System.Guid.Empty )
						{
							// log warning
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotCopiedId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not copied. Relationship: ExternViewContextReferencesExternModelContext"));
						}
						else
						{
							DslModeling::ModelElement targetElement = this.Store.ElementDirectory.FindElement(mappedTargetId);
							if( targetElement == null )
							{
								// log error
		        	        	groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotFoundId",
					            	DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not found. Relationship: ExternViewContextReferencesExternModelContext"));
							}
							else
							{
								bool bContinue = true;
		
								// check cardinalities, so we don't violate them by additing a new relationship
								if( DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Tum.PDE.LanguageDSL.ExternViewContextReferencesExternModelContext.ExternViewContextDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: ExternViewContextReferencesExternModelContext"));
									
									bContinue = false;
								}
								if( DslModeling::DomainRoleInfo.GetLinkedElement(targetElement, global::Tum.PDE.LanguageDSL.ExternViewContextReferencesExternModelContext.ExternModelContextDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: ExternViewContextReferencesExternModelContext"));
									
									bContinue = false;
								}
								
								if( bContinue )
								{
									// create property assignments
									DslModeling::PropertyAssignment[] propertyAssignemnts = protoLink.GetPropertyAssignments(this.Store.DefaultPartition, 
										System.Guid.NewGuid());
								
									// create role assignments
									DslModeling.RoleAssignment[] roleAssignments = new DslModeling.RoleAssignment[2];
		                	        roleAssignments[0] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.ExternViewContextReferencesExternModelContext.ExternViewContextDomainRoleId, this);
									roleAssignments[1] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.ExternViewContextReferencesExternModelContext.ExternModelContextDomainRoleId, targetElement);
									
									// create new relationship
									new global::Tum.PDE.LanguageDSL.ExternViewContextReferencesExternModelContext(this.Store, roleAssignments, propertyAssignemnts);
								}
							}
						}
						#endregion
					}
				}
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to ExternViewContext because move is not allowed."));
				return;
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class ModelContext : LibraryModelContext
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to ModelContext because paste is not allowed."));
				return;
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			DslModeling::DomainRelationshipInfo linkDomainInfo = null;
			if (protoLink != null)
			{
				linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(protoLink.DomainClassId);
			}
			else
			{
				// try getting the linkDomainInfo from name
			}
			
			if( linkDomainInfo == null )
			{
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkDomainTypeMissing",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link can not be created as the corresponding domain type is missing."));
				return;
			}
		
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to ModelContext because move is not allowed."));
				return;
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class ModelTree : Tum.PDE.LanguageDSL.CopyPaste.IModelMergeElements
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public virtual bool ModelIsCopyAllowed()
		{
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public virtual bool ModelIsMoveAllowed()
		{
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public virtual bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public virtual DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public virtual DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public virtual void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public virtual bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return false;
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public virtual void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to ModelTree because paste is not allowed."));
				return;
			}
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to ModelTree because move is not allowed."));
				return;
			}
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public virtual void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class TemplatedDiagramClass : DiagramClass
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to TemplatedDiagramClass because paste is not allowed."));
				return;
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to TemplatedDiagramClass because move is not allowed."));
				return;
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class DependencyDiagram : TemplatedDiagramClass
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to DependencyDiagram because paste is not allowed."));
				return;
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to DependencyDiagram because move is not allowed."));
				return;
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class SpecificDependencyDiagram : DependencyDiagram
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to SpecificDependencyDiagram because paste is not allowed."));
				return;
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			DslModeling::DomainRelationshipInfo linkDomainInfo = null;
			if (protoLink != null)
			{
				linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(protoLink.DomainClassId);
			}
			else
			{
				// try getting the linkDomainInfo from name
				if( protoLink.Name == "SpecificDependencyDiagramReferencesDomainClass" && linkDomainInfo == null)
				{
					linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(SpecificDependencyDiagramReferencesDomainClass.DomainClassId);
				}
			}
			
			if( linkDomainInfo == null )
			{
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkDomainTypeMissing",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link can not be created as the corresponding domain type is missing."));
				return;
			}
		
				if (linkDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.SpecificDependencyDiagramReferencesDomainClass.DomainClassId)) 
				{
					// see if this element is taking part in this role
					bool bTakesPart = false;
					
					DslEditorModeling::ModelProtoRolePlayer sourceRolePlayer = protoLink.GetSourceRolePlayer(this.Store.DefaultPartition);
					DslEditorModeling::ModelProtoElement sourceProtoElement = groupMerger.GetElementById(sourceRolePlayer.RolePlayerId);
					System.Guid mappedSourceIdTP = System.Guid.Empty;
					if( sourceProtoElement != null )
					{
						mappedSourceIdTP = groupMerger.GetIdMapping(sourceRolePlayer.RolePlayerId);
						if( mappedSourceIdTP == this.Id )
							bTakesPart = true;
					}
		
					if( bTakesPart )
					{		
						bool bExists = true;
		        	    if( this.Store.ElementDirectory.FindElement(protoLink.ElementId) == null )
		        	        bExists = false;
							
						if( bExists && groupMerger.ProtoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
		        	    {
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkExistsOnMoveId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link exists although the operation = Move."));
						}
						
						#region Target
						// see if target element was copied
						DslEditorModeling::ModelProtoRolePlayer targetRolePlayer = protoLink.GetTargetRolePlayer(this.Store.DefaultPartition);
						DslEditorModeling::ModelProtoElement targetProtoElement = groupMerger.GetElementById(targetRolePlayer.RolePlayerId);
						System.Guid mappedTargetId = System.Guid.Empty;
						if( targetProtoElement != null )
						{
						 	mappedTargetId= groupMerger.GetIdMapping(targetRolePlayer.RolePlayerId);
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element
							mappedTargetId = targetRolePlayer.RolePlayerId;
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element with the same name as the previous element
							// TODO
						}
		
						if( mappedTargetId == System.Guid.Empty )
						{
							// log warning
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotCopiedId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not copied. Relationship: SpecificDependencyDiagramReferencesDomainClass"));
						}
						else
						{
							DslModeling::ModelElement targetElement = this.Store.ElementDirectory.FindElement(mappedTargetId);
							if( targetElement == null )
							{
								// log error
		        	        	groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotFoundId",
					            	DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not found. Relationship: SpecificDependencyDiagramReferencesDomainClass"));
							}
							else
							{
								bool bContinue = true;
		
								// check cardinalities, so we don't violate them by additing a new relationship
								if( DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Tum.PDE.LanguageDSL.SpecificDependencyDiagramReferencesDomainClass.SpecificDependencyDiagramDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: SpecificDependencyDiagramReferencesDomainClass"));
									
									bContinue = false;
								}
								
								if( bContinue )
								{
									// create property assignments
									DslModeling::PropertyAssignment[] propertyAssignemnts = protoLink.GetPropertyAssignments(this.Store.DefaultPartition, 
										System.Guid.NewGuid());
								
									// create role assignments
									DslModeling.RoleAssignment[] roleAssignments = new DslModeling.RoleAssignment[2];
		                	        roleAssignments[0] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.SpecificDependencyDiagramReferencesDomainClass.SpecificDependencyDiagramDomainRoleId, this);
									roleAssignments[1] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.SpecificDependencyDiagramReferencesDomainClass.DomainClassDomainRoleId, targetElement);
									
									// create new relationship
									new global::Tum.PDE.LanguageDSL.SpecificDependencyDiagramReferencesDomainClass(this.Store, roleAssignments, propertyAssignemnts);
								}
							}
						}
						#endregion
					}
				}
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to SpecificDependencyDiagram because move is not allowed."));
				return;
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class ModalDiagram : RestorableTemplatedDiagramVMOnly
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to ModalDiagram because paste is not allowed."));
				return;
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			DslModeling::DomainRelationshipInfo linkDomainInfo = null;
			if (protoLink != null)
			{
				linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(protoLink.DomainClassId);
			}
			else
			{
				// try getting the linkDomainInfo from name
				if( protoLink.Name == "ModalDiagramReferencesDomainClass" && linkDomainInfo == null)
				{
					linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(ModalDiagramReferencesDomainClass.DomainClassId);
				}
			}
			
			if( linkDomainInfo == null )
			{
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkDomainTypeMissing",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link can not be created as the corresponding domain type is missing."));
				return;
			}
		
				if (linkDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.ModalDiagramReferencesDomainClass.DomainClassId)) 
				{
					// see if this element is taking part in this role
					bool bTakesPart = false;
					
					DslEditorModeling::ModelProtoRolePlayer sourceRolePlayer = protoLink.GetSourceRolePlayer(this.Store.DefaultPartition);
					DslEditorModeling::ModelProtoElement sourceProtoElement = groupMerger.GetElementById(sourceRolePlayer.RolePlayerId);
					System.Guid mappedSourceIdTP = System.Guid.Empty;
					if( sourceProtoElement != null )
					{
						mappedSourceIdTP = groupMerger.GetIdMapping(sourceRolePlayer.RolePlayerId);
						if( mappedSourceIdTP == this.Id )
							bTakesPart = true;
					}
		
					if( bTakesPart )
					{		
						bool bExists = true;
		        	    if( this.Store.ElementDirectory.FindElement(protoLink.ElementId) == null )
		        	        bExists = false;
							
						if( bExists && groupMerger.ProtoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
		        	    {
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkExistsOnMoveId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link exists although the operation = Move."));
						}
						
						#region Target
						// see if target element was copied
						DslEditorModeling::ModelProtoRolePlayer targetRolePlayer = protoLink.GetTargetRolePlayer(this.Store.DefaultPartition);
						DslEditorModeling::ModelProtoElement targetProtoElement = groupMerger.GetElementById(targetRolePlayer.RolePlayerId);
						System.Guid mappedTargetId = System.Guid.Empty;
						if( targetProtoElement != null )
						{
						 	mappedTargetId= groupMerger.GetIdMapping(targetRolePlayer.RolePlayerId);
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element
							mappedTargetId = targetRolePlayer.RolePlayerId;
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element with the same name as the previous element
							// TODO
						}
		
						if( mappedTargetId == System.Guid.Empty )
						{
							// log warning
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotCopiedId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not copied. Relationship: ModalDiagramReferencesDomainClass"));
						}
						else
						{
							DslModeling::ModelElement targetElement = this.Store.ElementDirectory.FindElement(mappedTargetId);
							if( targetElement == null )
							{
								// log error
		        	        	groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotFoundId",
					            	DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not found. Relationship: ModalDiagramReferencesDomainClass"));
							}
							else
							{
								bool bContinue = true;
		
								// check cardinalities, so we don't violate them by additing a new relationship
								if( DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Tum.PDE.LanguageDSL.ModalDiagramReferencesDomainClass.ModalDiagramDomainRoleId) != null )
								{
									// log warning
		        	        		groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkCreationViolatesMultiplicityId",
					            		DslEditorModeling.ModelValidationViolationType.Error, "Can not create relationship because one already exists. Relationship: ModalDiagramReferencesDomainClass"));
									
									bContinue = false;
								}
								
								if( bContinue )
								{
									// create property assignments
									DslModeling::PropertyAssignment[] propertyAssignemnts = protoLink.GetPropertyAssignments(this.Store.DefaultPartition, 
										System.Guid.NewGuid());
								
									// create role assignments
									DslModeling.RoleAssignment[] roleAssignments = new DslModeling.RoleAssignment[2];
		                	        roleAssignments[0] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.ModalDiagramReferencesDomainClass.ModalDiagramDomainRoleId, this);
									roleAssignments[1] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.ModalDiagramReferencesDomainClass.DomainClassDomainRoleId, targetElement);
									
									// create new relationship
									new global::Tum.PDE.LanguageDSL.ModalDiagramReferencesDomainClass(this.Store, roleAssignments, propertyAssignemnts);
								}
							}
						}
						#endregion
					}
				}
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to ModalDiagram because move is not allowed."));
				return;
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class SpecificElementsDiagram : RestorableChildlessDiagram
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to SpecificElementsDiagram because paste is not allowed."));
				return;
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			DslModeling::DomainRelationshipInfo linkDomainInfo = null;
			if (protoLink != null)
			{
				linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(protoLink.DomainClassId);
			}
			else
			{
				// try getting the linkDomainInfo from name
				if( protoLink.Name == "SpecificElementsDiagramReferencesDomainClasses" && linkDomainInfo == null)
				{
					linkDomainInfo = this.Partition.DomainDataDirectory.GetDomainRelationship(SpecificElementsDiagramReferencesDomainClasses.DomainClassId);
				}
			}
			
			if( linkDomainInfo == null )
			{
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkDomainTypeMissing",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link can not be created as the corresponding domain type is missing."));
				return;
			}
		
				if (linkDomainInfo.IsDerivedFrom(global::Tum.PDE.LanguageDSL.SpecificElementsDiagramReferencesDomainClasses.DomainClassId)) 
				{
					// see if this element is taking part in this role
					bool bTakesPart = false;
					
					DslEditorModeling::ModelProtoRolePlayer sourceRolePlayer = protoLink.GetSourceRolePlayer(this.Store.DefaultPartition);
					DslEditorModeling::ModelProtoElement sourceProtoElement = groupMerger.GetElementById(sourceRolePlayer.RolePlayerId);
					System.Guid mappedSourceIdTP = System.Guid.Empty;
					if( sourceProtoElement != null )
					{
						mappedSourceIdTP = groupMerger.GetIdMapping(sourceRolePlayer.RolePlayerId);
						if( mappedSourceIdTP == this.Id )
							bTakesPart = true;
					}
		
					if( bTakesPart )
					{		
						bool bExists = true;
		        	    if( this.Store.ElementDirectory.FindElement(protoLink.ElementId) == null )
		        	        bExists = false;
							
						if( bExists && groupMerger.ProtoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move )
		        	    {
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeElementLinkExistsOnMoveId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Element link exists although the operation = Move."));
						}
						
						#region Target
						// see if target element was copied
						DslEditorModeling::ModelProtoRolePlayer targetRolePlayer = protoLink.GetTargetRolePlayer(this.Store.DefaultPartition);
						DslEditorModeling::ModelProtoElement targetProtoElement = groupMerger.GetElementById(targetRolePlayer.RolePlayerId);
						System.Guid mappedTargetId = System.Guid.Empty;
						if( targetProtoElement != null )
						{
						 	mappedTargetId= groupMerger.GetIdMapping(targetRolePlayer.RolePlayerId);
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element
							mappedTargetId = targetRolePlayer.RolePlayerId;
						}
						
						if( mappedTargetId == System.Guid.Empty )
						{
							// try creating relationship to existing element with the same name as the previous element
							// TODO
						}
		
						if( mappedTargetId == System.Guid.Empty )
						{
							// log warning
		        	        groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotCopiedId",
					             DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not copied. Relationship: SpecificElementsDiagramReferencesDomainClasses"));
						}
						else
						{
							DslModeling::ModelElement targetElement = this.Store.ElementDirectory.FindElement(mappedTargetId);
							if( targetElement == null )
							{
								// log error
		        	        	groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeLinkElementNotFoundId",
					            	DslEditorModeling.ModelValidationViolationType.Error, "Referenced model element was not found. Relationship: SpecificElementsDiagramReferencesDomainClasses"));
							}
							else
							{
								bool bContinue = true;
		
								// check cardinalities, so we don't violate them by additing a new relationship
								
								if( bContinue )
								{
									// create property assignments
									DslModeling::PropertyAssignment[] propertyAssignemnts = protoLink.GetPropertyAssignments(this.Store.DefaultPartition, 
										System.Guid.NewGuid());
								
									// create role assignments
									DslModeling.RoleAssignment[] roleAssignments = new DslModeling.RoleAssignment[2];
		                	        roleAssignments[0] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.SpecificElementsDiagramReferencesDomainClasses.SpecificElementsDiagramDomainRoleId, this);
									roleAssignments[1] = new DslModeling.RoleAssignment(global::Tum.PDE.LanguageDSL.SpecificElementsDiagramReferencesDomainClasses.DomainClassDomainRoleId, targetElement);
									
									// create new relationship
									new global::Tum.PDE.LanguageDSL.SpecificElementsDiagramReferencesDomainClasses(this.Store, roleAssignments, propertyAssignemnts);
								}
							}
						}
						#endregion
					}
				}
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to SpecificElementsDiagram because move is not allowed."));
				return;
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class DesignerSurfaceDiagram : ChildlessDiagram
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to DesignerSurfaceDiagram because paste is not allowed."));
				return;
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to DesignerSurfaceDiagram because move is not allowed."));
				return;
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class ChildlessDiagram : TemplatedDiagramClass
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to ChildlessDiagram because paste is not allowed."));
				return;
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to ChildlessDiagram because move is not allowed."));
				return;
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class TemplatedDiagramViewModelOnly : ChildlessDiagram
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to TemplatedDiagramViewModelOnly because paste is not allowed."));
				return;
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to TemplatedDiagramViewModelOnly because move is not allowed."));
				return;
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class RestorableChildlessDiagram : ChildlessDiagram
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to RestorableChildlessDiagram because paste is not allowed."));
				return;
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to RestorableChildlessDiagram because move is not allowed."));
				return;
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}
namespace Tum.PDE.LanguageDSL
{
    public partial class RestorableTemplatedDiagramVMOnly : TemplatedDiagramViewModelOnly
    {
		#region IModelMergeElements
		/// <summary>
		/// Decides whether the element can be copied or not.
		/// </summary>
		/// <returns>True if the element can be copied. False otherwise.</returns>
		public override bool ModelIsCopyAllowed()
		{
			if( !base.ModelIsCopyAllowed() )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be moved or not.
		/// </summary>
		/// <returns>True if the element can be moved. False otherwise.</returns>
		public override bool ModelIsMoveAllowed()
		{
			if( !base.ModelIsMoveAllowed() )
				return false;
		
		
			return true;
		}
		
		/// <summary>
		/// Decides whether the element can be pasted or not based on the operation.
		/// </summary>
		/// <param name="protoGroupOperation">Proto group operation.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelIsPasteAllowed(DslEditorModeling::ModelProtoGroupOperation protoGroupOperation)
		{
			if( protoGroupOperation == DslEditorModeling.ModelProtoGroupOperation.Move )
				return ModelIsMoveAllowed();
		
			if( !base.ModelIsPasteAllowed(protoGroupOperation) )
				return false;
		
			return true;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMergeCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
		        if (!ModelIsCopyAllowed())
		            return null;
		
		    if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		    	return null;
		
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			ModelProcessMergeCopy(protoElement, protoGroup);
			
			return protoElement;
		}
		
		/// <summary>
		/// Create a proto element representation of the element, which can be used for paste later.
		/// </summary>
		/// <param name="protoGroup">Proto group to add the element to.</param>
		/// <returns>Proto element representation of the element.</returns>
		public override DslEditorModeling::ModelProtoElement ModelCreateMoveCopy(DslEditorModeling::ModelProtoGroup protoGroup)
		{
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Move)
		        if (!ModelIsMoveAllowed())
		            return null;
					
			if (protoGroup.Operation == DslEditorModeling.ModelProtoGroupOperation.Copy)
				return null;
				
			DslEditorModeling::ModelProtoElement protoElement = new DslEditorModeling::ModelProtoElement(this);
			protoGroup.AddNewElement(protoElement);
			
			return protoElement;		
		}
		
		/// <summary>
		/// Processes a proto element representation of the element and adds required proto links. 
		/// This method is called on base classes from derived classes.
		/// 
		/// Hint: Properties do not need to be added in this method.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		public override void ModelProcessMergeCopy(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			base.ModelProcessMergeCopy(protoElement, protoGroup);
		
		}
		
		/// <summary>
		/// Decides whether the element that is represented by the proto element can be pasted or not.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element.</param>
		/// <param name="protoGroup">Proto group the proto element belongs to.</param>
		/// <returns>True if the element can be pasted. False otherwise.</returns>
		public override bool ModelCanMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroup protoGroup)
		{
			return base.ModelCanMerge(protoElement, protoGroup);
		}
		
		/// <summary>
		/// Adds a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		/// <param name="isRoot">Root element?</param>
		public override void ModelMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger, bool isRoot)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergePasteDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to RestorableTemplatedDiagramVMOnly because paste is not allowed."));
				return;
			}
		
			base.ModelMerge(protoElement, groupMerger, isRoot);
		}
		
		/// <summary>
		/// Adds a proto link to the current element.
		/// </summary>
		/// <param name="protoLink">Proto link representation of the element link that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMerge(DslEditorModeling::ModelProtoLink protoLink, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelMerge(protoLink, groupMerger);
			
		}
		
		/// <summary>
		/// Moves a proto element to the current element.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelMove(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
			if( !ModelIsPasteAllowed(groupMerger.ProtoGroup.Operation) )
			{
				// add warning message
				groupMerger.MergeResult.AddMessage(new DslEditorModeling::ValidationMessage("ModelMergeMoveDisallowedId",
		                     DslEditorModeling.ModelValidationViolationType.Warning, "Element couldn't be addded to RestorableTemplatedDiagramVMOnly because move is not allowed."));
				return;
			}
		
			base.ModelMove(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize. This method is called on each copied element once all the elements and links are processed.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalize(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalize(protoElement, groupMerger);
		}
		
		/// <summary>
		/// Finalize merge.
		/// </summary>
		/// <param name="protoElement">Proto element representation of the element that is to be added.</param>
		/// <param name="groupMerger">
		/// Group merger class used to track id mapping, merge errors/warnings and 
		/// postprocess merging by rebuilding reference relationships.
		/// </param>
		public override void ModelFinalizeMerge(DslEditorModeling::ModelProtoElement protoElement, DslEditorModeling::ModelProtoGroupMerger groupMerger)
		{
		
			base.ModelFinalizeMerge(protoElement, groupMerger);
		}
		#endregion
	}
}

